---
layout: multipage-overview
title: Трейт Iterable

discourse: true

partof: collections-213
overview-name: Collections

num: 4
previous-page: overview
next-page: seqs

language: ru

---

На самом верху иерархии коллекций находится трейт `Iterable`. Все методы в этого трейта описаны как абстрактные, `iterator` - это метод, который выдает элементы коллекции один за другим.

    def iterator: Iterator[A]

Классы коллекций, которые базируются на `Iterable`, должны определять этот метод; все остальные методы могут быть просто унаследованы от `Iterable`.

`Iterable` также определяет несколько конкретных методов, все они делятся на категории, которые опишем в следующей таблице:

* **Сложения**, `concat`, которая объединяет две коллекции вместе либо добавляет все элементы итератора к коллекции.
* **Применения ко всем** операции `map`, `flatMap` и `collect`, которые создают новую коллекцию, применяя некую функцию к элементам коллекции.
* **Конверсии** `toArray`, `toList`, `toIterable`, `toSeq`, `toIndexedSeq`, `toStream`, `toSet`, `toMap`, которые превращают `Iterable` коллекцию во что-то более конкретное. Все эти преобразования возвращают потребляемые аргументы без изменений, если тип коллекции во время выполнения уже соответствует запрашиваемому типу коллекции. Например, применение команды `toList` к списку вернет в результате тотже самый список.
* **Копирования**  `copyToArray` - как следует из названия, копирует элементы коллекции в массив.
* **Размерности** это операции `isEmpty`, `nonEmpty`, `size`, `knownSize`, `sizeIs`. Работают с количеством элементов коллекции, в некоторых случаях может потребовать обхода всех элементов (например для `List`). В других случаях коллекция может вообще иметь неограниченное количество элементов (например, `LazyList.from(1)`).
* **Выбора элементов** это операции `head`, `last`, `headOption`, `lastOption`, и `find`. Они выбирают первый или последний элемент коллекции, или же первый элемент, который соответствует условию. Обратите внимание, однако, что не все коллекции имеют четкое определенние того, что они подразумевают под "first"(первым) и "last"(последним) элементом. Например, хэши можгут хранить элементы в соответствии с их ключами, которые могут меняться от запуска к запуску. В таком случае "первый" элемент во множестве хэшей может быть разным, при каждом запуске программы. Однако если коллекция _упорядоченная_, то она всегда выдает свои элементы в одном и том же порядке. Большинство коллекций упорядоченные, но некоторые (_в том числе HashSet_) нет. Отсутствие упорядоченности дает им дополнительную эффективность работы. Упорядочивание часто необходимо для проведения воспроизводимых тестов и помощи в отладке. С этой целью коллекции Scala предоставляют упорядоченные альтернативы для всех типов коллекций. Например, упорядоченной альтернативой для `HashSet` является `LinkedHashSet`.
* **Выбора под-коллекций** `tail`, `init`, `slice`, `take`, `drop`, `takeWhile`, `dropWhile`, `filter`, `filterNot`, `withFilter`. Все они возвращают какую-то подколлекцию, определяемую индексным диапазоном или каким-либо предикатом.
* **Разделительных операций** `splitAt`, `span`, `partition`, `partitionMap`, `groupBy`, `groupMap`, `groupMapReduce`, которые разделяют элементы исходной коллекции на несколько подколлекций.
* **Проверки элементов** `exists`, `forall`, `count` которые проверяют элементы коллекции с определенным предикатом.
* **Свертки** `foldLeft`, `foldRight`, `reduceLeft`, `reduceRight` которые применяют двуместную операцию к последовательным элементам.
* **Определённых сверток** `sum`, `product`, `min`, `max`, которые работают над коллекциями конкретных типов (числовыми или сопоставимыми).
* **Строковая** операции `mkString`, `addString`, `className`, которые дают альтернативные способы преобразования коллекции в строку.
* **Отображения** - это такая коллекция, которая лениво вычисляется. Позже мы расмотрим отображения [подробнее](views.html).

В `Iterable` есть два метода, которые возвращают итераторы: `grouped` и `sliding`. Правда эти итераторы возвращают не отдельные элементы, а целые подпоследовательности элементов исходной коллекции. Максимальный размер таких подпоследовательностей задается аргументом. Метод `grouped` возвращает свои элементы "нарезанные" на фиксированные части, тогда как `sliding` возвращает результат "прохода окна" (заданной длинны) над элементами. Разница между ними станет очевидной, если взглянуть на следующий результат в консоли:

    scala> val xs = List(1, 2, 3, 4, 5)
    xs: List[Int] = List(1, 2, 3, 4, 5)
    scala> val git = xs grouped 3
    git: Iterator[List[Int]] = non-empty iterator
    scala> git.next()
    res3: List[Int] = List(1, 2, 3)
    scala> git.next()
    res4: List[Int] = List(4, 5)
    scala> val sit = xs sliding 3
    sit: Iterator[List[Int]] = non-empty iterator
    scala> sit.next()
    res5: List[Int] = List(1, 2, 3)
    scala> sit.next()
    res6: List[Int] = List(2, 3, 4)
    scala> sit.next()
    res7: List[Int] = List(3, 4, 5)

### Операции в Классе Iterable ###

| НАЗВАНИЕ	  	    | ЧТО ДЕЛАЕТ				     |
| ------       	       	    | ------					     |
|  **Абстрактный Метод:**     |						     |
|  `xs.iterator`	    |Возвращает итератор, который выдает каждый элемент из `xs`.|
|  **Другие Итераторы:**     |						     |
|  `xs foreach f`	    |Выполняет функцию `f` на каждом элементе `xs`.|
|  `xs grouped size`   	    |Итератор, который нарезает коллекцию на кусочки фиксированного размера. |
|  `xs sliding size`   	    |Итератор, который выдает результат прохождения окна фиксированного размера над элементами исходной коллекции. |
|  **Сложения:**     	    |						     |
|  `xs concat ys`<br>(либо `xs ++ ys`)	    |Результат состоит из элементов обоих коллекций `xs` и `ys`. `ys` - [IterableOnce](http://www.scala-lang.org/api/{{ site.scala-version }}/scala/collection/IterableOnce.html) коллекция, т. е., либо [Iterable](http://www.scala-lang.org/api/{{ site.scala-version }}/scala/collection/Iterable.html) либо [Iterator](http://www.scala-lang.org/api/{{ site.scala-version }}/scala/collection/Iterator.html).|
|  **Применения ко всем:**     	    |						     |
|  `xs map f`		    |Коллекция, полученная применением функции `f` к каждому элементу в `xs`.|
|  `xs flatMap f`	    |Коллекция, полученная применением функции производящей коллекции `f` к каждому элементу в`xs` с объединением результатов в единую коллекцию.|
|  `xs collect f`	    |Коллекция, полученная применением частично определенной функции `f` к каждому элементу в `xs`, для которого она определена, с последующем сбором результатов. |
|  **Конверсии:**         |						     |
|  `xs.toArray`	    	    |Преобразует коллекцию в массив.	     |
|  `xs.toList`	    	    |Преобразует коллекцию в список.		     |
|  `xs.toIterable`    	    |Преобразует коллекцию в итерабельную коллекцию.	     |
|  `xs.toSeq`	    	    |Преобразует коллекцию в последовательность.	     |
|  `xs.toIndexedSeq`   	    |Преобразует коллекцию в индексированную последовательность. |
|  `xs.toSet`	    	    |Преобразует коллекцию в множество.		     |
|  `xs.toMap`	    	    |Преобразует набор пар ключ/значение в Map. Если в исходной коллекции нет пар, то вызов этой операции приведёт к ошибке при статической проверки типов.|
|  `xs.to(SortedSet)`       | Общая операция преобразования, в которой в качестве параметра используется производящая коллекция.  |
|  **Копирования:**             |						     |
|  `xs copyToArray(arr, s, n)`|Копирует не более `n` элементов коллекции в массив `arr`, начиная с индекса `s`. Два последних аргумента являются необязательными.|
|  **Размерности:**           |						     |
|  `xs.isEmpty`	    	    |Проверяет, пуста ли коллекция.	     |
|  `xs.nonEmpty`    	    |Проверяет, содержит ли коллекция элементы. |
|  `xs.size`	    	    |Количество элементов в коллекции.	     |
|  `xs.knownSize`	    	    |Количество элементов, вычисляется только если для вычисления количества требуется константное время (`О(1)`) , иначе `-1`.   |
|  `xs.sizeCompare(ys)`	    |Возвращает отрицательное значение, если `xs` короче коллекции `ys`, положительное значение, если она длиннее, и `0` если у них одинаковый размер. Работает даже если коллекция бесконечна, например, `LazyList.from(1) sizeCompare List(1, 2)` возвращает положительное значение.	     |
|  `xs.sizeCompare(n)`	    |Возвращает отрицательное значение, если `xs` короче `n`, положительное значение, если больше, и `0` если размер равен `n`. Работает даже если коллекция бесконечна, например, `LazyList.from(1) sizeCompare 42` возвращает положительное значение.	     |
|  `xs.sizeIs < 42`, `xs.sizeIs != 42`, и так далее |Обеспечивает более удобный синтаксис для `xs.sizeCompare(42) <0`, `xs.sizeCompare(42) !=0` и т.д., соответственно.|
|  **Выбора элементов:**   |						     |
|  `xs.head`	    	    |Первый элемент коллекции (или какой-то элемент, если порядок не определен).|
|  `xs.headOption`	    |Первый элемент `xs` в опциональном значении, или None, если `xs` пуст.|
|  `xs.last`	    	    |Последний элемент коллекции (или какой-то элемент, если порядок не определен).|
|  `xs.lastOption`	    |Последний элемент `xs` в опциональном значении, или None, если `xs` пуст.|
|  `xs find p`	    	    |Опциональное значение, содержащее первый элемент из `xs`, которое удовлетворяет `p`, или `None` если ни один из элементов не удовлетворяет требованиям.|
|  **Выбора под-коллекций:**      |						     |
|  `xs.tail`	    	    |Оставшаяся часть коллекции, без `xs.head`.    |
|  `xs.init`	    	    |Оставшаяся часть коллекции, без `xs.last`.    |
|  `xs.slice(from, to)`    |Коллекция, состоящая из элементов в определенном диапазоне `xs` (от `from` до, но не включая `to`).|
|  `xs take n`	    	    |Коллекция, состоящая из первых `n` элементов `xs` (или некоторых произвольных `n` элементов, если порядок не определен).|
|  `xs drop n`	    	    |Оставшаяся часть коллекции, без `xs take n`.|
|  `xs takeWhile p`	    |Самый длинный префикс элементов в коллекции, удовлетворяющий `p`.|
|  `xs dropWhile p`	    |Коллекция без самого длинного префикса элементов, удовлетворяющего `p`.|
|  `xs takeRight n`	    |Коллекция, состоящая из последних `n` элементов `xs` (или некоторых произвольных `n` элементов, если порядок не определен).|
|  `xs dropRight n`	    |Оставшаяся часть коллекции, без `xs takeRight n`.|
|  `xs filter p`	    |Коллекция, состоящая из тех элементов `xs`, которые удовлетворяют предикату `p`.|
|  `xs withFilter p`	    |Нестрогий фильтр коллекции. Последовательность вызовов `map`, `flatMap`, `foreach` и `withFilter`, будет применятся только к тем элементам `xs`, для которых условие `p` верно.|
|  `xs filterNot p`	    |Коллекция, состоящая из элементов `xs`, которые не удовлетворяют предикату `p`.|
|  **Разделительных Операций:**        |						     |
|  `xs splitAt n`	    |Разделяет `xs` на две коллекции `(xs take n, xs drop n)` |
|  `xs span p`	    	    |Разделяет `xs` в соответствии с предикатом, образуя пару коллекций `(xs takeWhile p, xs.dropWhile p)`.|
|  `xs partition p`	    |Разделяет `xs` на пару коллекций; одна с элементами, удовлетворяющими предикату `p`, другая с элементами, которые не удовлетворяют, образуя пару коллекций `(xs filter p, xs.filterNot p)`.|
|  `xs groupBy f`	    |Разделяет `xs` на пары ключ/значение в соответствии с разделительной функцией `f`.|
|  `xs.groupMap(f)(g)`|Разделяет `xs` на пары ключ/значение в соответствии с разделительной функцией `f` и применяет функцию преобразования `g` к каждому элементу в группе.|
|  `xs.groupMapReduce(f)(g)(h)`|Разделяет `xs` в соответствии с разделительной функцией `f`, применяет функцию `g` к каждому элементу в группе, а затем объединяет результаты при помощи функции `h`.|
|  **Сведенья об элементах:**  |						     |
|  `xs forall p`	    |Логическое выражение того, соответствует ли предикат `p` всем элементам `xs`.|
|  `xs exists p`	    |Логическое выражение того, соответствует ли предикат `p` какому-либо элементу в `xs`.|
|  `xs count p`	    	    |Количество элементов в `xs`, удовлетворяющих предикату `p`.|
|  **Свертки:** 		    |						     |
|  `xs.foldLeft(z)(op)`	    |Применяет двуместную операцию `op` между последовательными элементами `x`, слева направо и начиная с `z`.|
|  `xs.foldRight(z)(op)`	    |Применяет двуместную операцию `op` между последовательными элементами `x`, переходя справа налево и заканчивая `z`.|
|  `xs reduceLeft op`	    |Применяет двуместную операцию `op` между последовательными элементами непустой коллекции `xs`, идущей слева направо.|
|  `xs reduceRight op`	    |Применяет двуместную операцию `op` между последовательными элементами непустой коллекции `xs`, идущей справа налево.|
|  **Определённых Сверток:**      |						     |
|  `xs.sum`	    	    |Сумма числовых значений элементов коллекции `xs`.|
|  `xs.product`	    	    |Произведение числовых значений элементов коллекции `xs`.|
|  `xs.min`	    	    |Минимальное порядковое значение элемента коллекции `xs`.|
|  `xs.max`	    	    |Максимальное порядковое значение элемента коллекции `xs`.|
|  `xs.minOption`	    |Как `min` но возвращает `None` если `xs` пустой.|
|  `xs.maxOption`	    |Как `max` но возвращает `None` если `xs` пустой.|
|  **Строковые:**             |						     |
|  `xs.addString(b, start, sep, end)`|Добавляет строку `b` в `StringBuilder`, которая показывает все элементы `xs` разделенные `sep`, окруженные строками `start` и `end`. `end`. `start`, `sep` - не обязательные параметры.|
|  `xs.mkString(start, sep, end)`|Преобразовывает коллекцию в строку, которая отображает все элементы `xs` разделенные `sep`, окруженные строками `start` и `end`. `end`. `start`, `sep` - не обязательные параметры.|
|  `xs.stringPrefix`	    |Возвращает название коллекции `xs.toString'.|
|  **Связывание:** 	    |						     |
|  `xs zip ys`	    	    |Коллекция пар соответствующих элементов из `xs` и `ys`.|
|  `xs.zipAll(ys, x, y)`   |Коллекция пар соответствующих элементов из `xs`и `ys`, где более короткая последовательность расширяется, чтобы соответствовать более длинной, добавляя элементы `x` или `y`.|
|  `xs.zipWithIndex`	    |Коллекция пар элементов из `xs` с их индексами.|
|  **Отображения:**               |						     |
|  `xs.view`	    	    |Выводит ленивое отображение для коллекции `xs`.|

В иерархии наследования сразу под `Iterable` расположены три трейта: [Seq](https://www.scala-lang.org/api/{{ site.scala-version }}/scala/collection/Seq.html), [Set](https://www.scala-lang.org/api/{{ site.scala-version }}/scala/collection/Set.html), и [Map](https://www.scala-lang.org/api/{{ site.scala-version }}/scala/collection/Map.html).`Seq` и `Map` реализуют [PartialFunction](https://www.scala-lang.org/api/{{ site.scala-version }}/scala/PartialFunction.html) трейт с его `apply` и `isDefinedAt` методами, но по-своему. `Set` получил свой `apply` метод от [SetOps](https://www.scala-lang.org/api/{{ site.scala-version }}/scala/collection/SetOps.html).

Для последовательностей, `apply` это указание на позицию элемента, которая указывается всегда номером от `0`. Поэтому `Seq(1, 2, 3)(1)` дает `2`. Для множеств `apply` проверка членов этого множества. Например, `Set('a', 'b', 'c')('b')` дает `true` тогда как `Set()('a')` дает `false`. И наконец, для _пар ключ-значение_, `apply` это запрос элемента. Например, `Map('a' -> 1, 'b' -> 10, 'c' -> 100)('b')` дает `10`.

Далее мы более подробно рассмотрим каждую, из этих трех видов, коллекций.
