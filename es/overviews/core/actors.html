
<!DOCTYPE html>
<html>
  <head>

    <title>API de actores en Scala - Scala Documentation</title>
    
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>

    <link rel="icon" type="image/png" href="/resources/favicon.ico">

    <!-- prettify js and CSS -->
    <link rel="stylesheet" href="/resources/stylesheets/prettify.css" type="text/css" />
    <script src="/resources/javascript/prettify/prettify.js" type="text/javascript" ></script>


    <!-- jquery js -->
    <script src="/resources/javascript/jquery.js" type="text/javascript" ></script>
    <script src="/resources/javascript/effects.core.js" type="text/javascript" ></script>
    <script src="/resources/javascript/effects.highlight.js" type="text/javascript" ></script>
    <script src="/resources/javascript/moveScroller.js" type="text/javascript" ></script>

    <!-- Bootstrap JS and CSS -->
    <link rel="stylesheet" href="/resources/stylesheets/bootstrap.css" type="text/css" />
	  <script src="/resources/javascript/bootstrap-dropdown.js" type="text/javascript" ></script>
	  <script src="/resources/javascript/bootstrap-dropdown-app.js" type="text/javascript" ></script>

    <!-- Base stylesheet for all pages -->
    <link rel="stylesheet" href="/resources/stylesheets/base.css" type="text/css" />

    <!-- table of contents js -->
    <script src="/resources/javascript/toc.js" type="text/javascript" ></script>

    <!-- google analytics -->
	<script type="text/javascript">

	  var _gaq = _gaq || [];
	  _gaq.push(['_setAccount', 'UA-574683-5']);
	  _gaq.push(['_trackPageview']);

	  (function() {
	    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
	    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
	    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
	  })();

	</script>

    <!-- prettyprint js to prepend generated pre/code tags -->
    <script type="text/javascript">
      function styleCode()
        {
          if (typeof disableStyleCode != "undefined")
          {
              return;
          }
          var a = false;
          $("pre code").parent().each(function()
          {
              if (!$(this).hasClass("prettyprint"))
              {
                  $(this).addClass("prettyprint lang-scala linenums");
                  a = true
              }
          });
          if (a) { prettyPrint() }
      }
    </script>

    <script type="text/javascript">
      jQuery(document).ready(function($) {

            $(".scroll").click(function(event){
              event.preventDefault();
              $('html,body').animate({scrollTop:$(this.hash).offset().top}, 500);
              $('html,body').animate({scrollTop:$(this.hash).offset().top-=50}, 500);
              $(this.hash).effect("highlight", {color: "#FFCC85"}, 3000);
            });
      });
    </script>

    <script type="text/javascript">
      $(window).ready(function goToSubsection() {
          if (window.location.hash)
          {
              $('html,body').animate({scrollTop:$(window.location.hash).offset().top}, 500);
              $('html,body').animate({scrollTop:$(window.location.hash).offset().top-=50}, 500);
              $(window.location.hash).effect("highlight", {color: "#FFCC85"}, 3000);
          }
        });
    </script>

    <style type="text/css">

       p.contents {
           margin-left: 15px;
           font-weight: bold;
           font-size: 16px;
       }

       div#toc ul {
           list-style: none;
       }

       div#toc ul a {
           display: block;
           list-style: none;
           line-height: 22px;
           font-weight: bold;
           width: 100%;
       }

      div#toc ul li ul {
           list-style: disc;
      }

      div#toc ul li ul a {
           line-height: 18px;
           font-weight: normal;
      }

      div#toc ul li ul li ul {
           list-style: square;
      }
       div#toc ul li ul li ul a {
       }

       div#scroller-anchor {
           width: inherit;
       }

       div#scroller {
           width: inherit;
       }

       div#guide-title {
        text-transform: capitalize;
        font-size: 16px;
        padding-bottom: 6px;
        color: #BFBFBF;
        text-transform: uppercase;
        font-weight: bold;
       }

       input, textarea, select, .uneditable-input {
	       width: 165px;
	     }

    </style>

</head>
  <body onload="styleCode()">

    <!-- Topbar
    ================================================== -->
<div class="topbar">
    <div class="topbar-inner">
        <div class="container">
            <a class="brand" href="/index.html"><img src="/resources/images/scala-logo.png"> Documentation</a>
            <ul class="nav">

                <li class="menu">
                      <a href="#" class="menu">API</a>
                      <ul class="menu-dropdown">
                        <li><a href="http://www.scala-lang.org/api/current/">Current</a></li>
                        <li><a href="http://www.scala-lang.org/archives/downloads/distrib/files/nightly/docs/library/index.html">Nightly</a></li>
                        <!--<li class="divider"></li>
                        <li><a href="#">Previous Versions</a></li>
                        -->
                      </ul>
                </li>

                <li class="menu">
                      <a href="#" class="menu">Learn</a>
                      <ul class="menu-dropdown">
                        <li><a href="/overviews">Guides & Overviews</a></li>
                        <li><a href="/tutorials">Tutorials</a></li>
                        <li><a href="/style">Scala Style Guide</a></li>
                      </ul>
                </li>

                <li class="menu">
                      <a href="#" class="menu">Quickref</a>
                      <ul class="menu-dropdown">
                        <li><a href="/glossary">Glossary</a></li>
                        <li><a href="/cheatsheets">Cheatsheets</a></li>
                      </ul>
                </li>

                <li><a href="/contribute.html">Contribute</a></li>
                <li><a href="/sips">SIPs</a></li>
                <li><a href="http://wiki.scala-lang.org">Wiki</a></li>
          </ul>
          <form method="get" id="searchform" action="/search.html">
            <input type="text" placeholder="Search"  class="field" name="q" id="q"/>
          </form>
           </li>
          </ul>
        </div>
    </div>
</div>

<div class="container">
  <div class="row">
    
    <div class="span10"><h1>API de actores en Scala</h1></div>

    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
        
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    

    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    

    
      
      
    

    <div class="span6">
      
        <a href="/overviews/core/actors.html"><img src="/resources/images/language/en.png" title="Language: en"/></a> 
        
          <a href="/es/overviews/core/actors.html"><img src="/resources/images/language/es.png" title="Language: es"/></a> 
        
      
    </div>

    <div class="span10">
      <p><strong>Philipp Haller and Stephen Tu</strong></p>

<p><strong>Traducción e interpretación: Miguel Ángel Pastor Olivar</strong></p>

<h2 id='introduccin'>Introducción</h2>

<p>La presente guía describe el API del paquete <code>scala.actors</code> de Scala 2.8/2.9. El documento se estructura en diferentes grupos lógicos. La jerarquía de &#8220;traits&#8221; es tenida en cuenta para llevar a cabo la estructuración de las secciones individuales. La atención se centra en el comportamiento exhibido en tiempo de ejecución por varios de los métodos presentes en los traits anteriores, complementando la documentación existente en el Scaladoc API.</p>

<h2 id='traits_de_actores_reactor_replyreactor_y_actor'>Traits de actores: Reactor, ReplyReactor, y Actor</h2>

<h3 id='the_reactor_trait'>The Reactor trait</h3>

<p><code>Reactor</code> es el padre de todos los traits relacionados con los actores. Heredando de este trait podremos definir actores con una funcionalidad básica de envío y recepción de mensajes.</p>

<p>El comportamiento de un <code>Reactor</code> se define mediante la implementación de su método <code>act</code>. Este método es ejecutado una vez el <code>Reactor</code> haya sido iniciado mediante la invocación del método <code>start</code>, retornando el <code>Reactor</code>. El método <code>start</code>es <em>idempotente</em>, lo cual significa que la invocación del mismo sobre un actor que ya ha sido iniciado no surte ningún efecto.</p>

<p>El trait <code>Reactor</code> tiene un parámetro de tipo <code>Msg</code> el cual determina el tipo de mensajes que un actor es capaz de recibir.</p>

<p>La invocación del método <code>!</code> de un <code>Reactor</code> envía un mensaje al receptor. La operación de envío de un mensaje mediante el operador <code>!</code> es asíncrona por lo que el actor que envía el mensaje no se bloquea esperando a que el mensaje sea recibido sino que su ejecución continua de manera inmediata. Por ejemplo, <code>a ! msg</code> envia <code>msg</code> a <code>a</code>. Todos los actores disponen de un <em>buzón</em> encargado de regular los mensajes entrantes hasta que son procesados.</p>

<p>El trait <code>Reactor</code> trait también define el método <code>forward</code>. Este método es heredado de <code>OutputChannel</code> y tiene el mismo efecto que el método <code>!</code>. Aquellos traits que hereden de <code>Reactor</code>, en particular el trait <code>ReplyActor</code>, sobreescriben este método para habilitar lo que comunmente se conocen como <em>&#8220;implicit reply destinations&#8221;</em> (ver a continuación)</p>

<p>Un <code>Reactor</code> recibe mensajes utilizando el método <code>react</code>. Este método espera un argumento de tipo <code>PartialFunction[Msg, Unit]</code> el cual define cómo los mensajes de tipo <code>Msg</code> son tratados una vez llegan al buzón de un actor. En el siguiente ejemplo, el actor espera recibir la cadena &#8220;Hello&#8221;, para posteriomente imprimir un saludo:</p>

<pre><code>react {
  case &quot;Hello&quot; =&gt; println(&quot;Hi there&quot;)
}</code></pre>

<p>La invocación del método <code>react</code> nunca retorna. Por tanto, cualquier código que deba ejecutarse tras la recepción de un mensaje deberá ser incluido dentro de la función parcial pasada al método <code>react</code>. Por ejemplo, dos mensajes pueden ser recibidos secuencialmente mediante la anidación de dos llamadas a <code>react</code>:</p>

<pre><code>react {
  case Get(from) =&gt;
    react {
      case Put(x) =&gt; from ! x
    }
}</code></pre>

<p>El trait <code>Reactor</code> también ofrece una serie de estructuras de control que facilitan la programación utilizando el mecanismo de <code>react</code>.</p>

<h4 id='terminacin_y_estados_de_ejecucin'>Terminación y estados de ejecución</h4>

<p>La ejecución de un <code>Reactor</code> finaliza cuando el cuerpo del método <code>act</code> ha sido completado. Un <code>Reactor</code> también pueden terminarse a si mismo de manera explícita mediante el uso del método <code>exit</code>. El tipo de retorno de <code>exit</code> es <code>Nothing</code>, dado que <code>exit</code> siempre dispara una excepción. Esta excepción únicamente se utiliza de manera interna y nunca debería ser capturada.</p>

<p>Un <code>Reactor</code> finalizado pueden ser reiniciado mediante la invocación de su método <code>restart</code>. La invocación del método anterior sobre un <code>Reactor</code> que no ha terminado su ejecución lanza una excepción de tipo <code>IllegalStateException</code>. El reinicio de un actor que ya ha terminado provoca que el método <code>act</code> se ejecute nuevamente.</p>

<p>El tipo <code>Reactor</code> define el método <code>getState</code>, el cual retorna, como un miembro de la enumeración <code>Actor.State</code>, el estado actual de la ejecución del actor. Un actor que todavía no ha sido iniciado se encuentra en el estado <code>Actor.State.New</code>. Si el actor se está ejecutando pero no está esperando por ningún mensaje su estado será <code>Actor.State.Runnable</code>. En caso de que el actor haya sido suspendido mientras espera por un mensaje estará en el estado <code>Actor.State.Suspended</code>. Por último, un actor ya terminado se encontrará en el estado <code>Actor.State.Terminated</code>.</p>

<h4 id='manejo_de_excepciones'>Manejo de excepciones</h4>

<p>El miembro <code>exceptionHandler</code> permite llevar a cabo la definición de un manejador de excepciones que estará habilitado durante toda la vida del <code>Reactor</code>:</p>

<pre><code>def exceptionHandler: PartialFunction[Exception, Unit]</code></pre>

<p>Este manejador de excepciones (<code>exceptionHandler</code>) retorna una función parcial que se utiliza para gestionar excepciones que no hayan sido tratadas de ninguna otra manera. Siempre que una excepción se propague fuera del método <code>act</code> de un <code>Reactor</code> el manejador anterior será aplicado a dicha excepción, permitiendo al actor ejecutar código de limpieza antes de que se termine. Nótese que la visibilidad de <code>exceptionHandler</code> es <code>protected</code>.</p>

<p>El manejo de excepciones mediante el uso de <code>exceptionHandler</code> encaja a la perfección con las estructuras de control utilizadas para programas con el método <code>react</code>. Siempre que una excepción es manejada por la función parcial retornada por <code>excepctionHandler</code>, la ejecución continua con la &#8220;closure&#8221; actual:</p>

<pre><code>loop {
  react {
    case Msg(data) =&gt;
      if (cond) // process data
      else throw new Exception(&quot;cannot process data&quot;)
  }
}</code></pre>

<p>Assumiendo que <code>Reactor</code> sobreescribe el atributo <code>exceptionHandler</code>, tras el lanzamiento de una excepción en el cuerpo del método <code>react</code>, y una vez ésta ha sido gestionada, la ejecución continua con la siguiente iteración del bucle.</p>

<h3 id='the_replyreactor_trait'>The ReplyReactor trait</h3>

<p>El trait <code>ReplyReactor</code> extiende <code>Reactor[Any]</code> y sobrescribe y/o añade los siguientes métodos:</p>

<ul>
<li>
<p>El método <code>!</code> es sobrescrito para obtener una referencia al actor actual (el emisor). Junto al mensaje actual, la referencia a dicho emisor es enviada al buzón del actor receptor. Este último dispone de acceso al emisor del mensaje mediante el uso del método <code>sender</code> (véase más abajo).</p>
</li>

<li>
<p>El método <code>forward</code> es sobrescrito para obtener una referencia al emisor del mensaje que actualmente está siendo procesado. Junto con el mensaje actual, esta referencia es enviada como el emisor del mensaje actual. Como consuencia de este hecho, <code>forward</code> nos permite reenviar mensajes en nombre de actores diferentes al actual.</p>
</li>

<li>
<p>El método (añadido) <code>sender</code> retorna el emisor del mensaje que está siendo actualmente procesado. Puesto que un mensaje puede haber sido reenviado, <code>sender</code> podría retornar un actor diferente al que realmente envió el mensaje.</p>
</li>

<li>
<p>El método (añadido) <code>reply</code> envía una respuesta al emisor del último mensaje. <code>reply</code> también es utilizado para responder a mensajes síncronos o a mensajes que han sido enviados mediante un &#8220;future&#8221; (ver más adelante).</p>
</li>

<li>
<p>El método (añadido) <code>!?</code> ofrece un <em>mecanismo síncrono de envío de mensajes</em>. La invocación de <code>!?</code> provoca que el actor emisor del mensaje se bloquee hasta que se recibe una respuesta, momento en el cual retorna dicha respuesta. Existen dos variantes sobrecargadas. La versión con dos parámetros recibe un argumento adicional que representa el tiempo de espera (medido en milisegundos) y su tipo de retorno es <code>Option[Any]</code> en lugar de <code>Any</code>. En caso de que el emisor no reciba una respuesta en el periodo de espera establecido, el método <code>!?</code> retornará <code>None</code>; en otro caso retornará la respuesta recibida recubierta con <code>Some</code>.</p>
</li>

<li>
<p>Los métodos (añadidos) <code>!!</code> son similares al envío síncrono de mensajes en el sentido de que el receptor puede enviar una respuesta al emisor del mensaje. Sin embargo, en lugar de bloquear el actor emisor hasta que una respuesta es recibida, retornan una instancia de <code>Future</code>. Esta última puede ser utilizada para recuperar la respuesta del receptor una vez se encuentre disponible; asimismo puede ser utilizada para comprobar si la respuesta está disponible sin la necesidad de bloquear el emisor. Existen dos versiones sobrecargadas. La versión que acepta dos parámetros recibe un argumento adicional de tipo <code>PartialFuntion[Any, A]</code>. Esta función parcial es utilizada para realizar el post-procesado de la respuesta del receptor. Básicamente, <code>!!</code> retorna un &#8220;future&#8221; que aplicará la anterior función parcial a la repuesta (una vez recibida). El resultado del &#8220;future&#8221; es el resultado de este post-procesado.</p>
</li>

<li>
<p>El método (añadido) <code>reactWithin</code> permite llevar a cabo la recepción de mensajes en un periodo determinado de tiempo. En comparación con el método <code>react</code>, recibe un parámetro adicional, <code>msec</code>, el cual representa el periodo de tiempo, expresado en milisegundos, hasta que el patrón <code>TIMEOUT</code> es satisfecho (<code>TIMEOUT</code> es un &#8220;case object&#8221; presente en el paquete <code>scala.actors</code>). Ejemplo:</p>

<p>reactWithin(2000) { case Answer(text) =&gt; // process text case TIMEOUT =&gt; println(&#8220;no answer within 2 seconds&#8221;) }</p>
</li>

<li>
<p>El método <code>reactWithin</code> también permite realizar accesos no bloqueantes al buzón. Si especificamos un tiempo de espera de 0 milisegundos, primeramente el buzón será escaneado en busca de un mensaje que concuerde. En caso de que no exista ningún mensaje concordante tras el primer escaneo, el patrón <code>TIMEOUT</code> será satisfecho. Por ejemplo, esto nos permite recibir determinado tipo de mensajes donde unos tienen una prioridad mayor que otros:</p>

<p>reactWithin(0) { case HighPriorityMsg =&gt; // &#8230; case TIMEOUT =&gt; react { case LowPriorityMsg =&gt; // &#8230; } }</p>

<p>En el ejemplo anterior, el actor procesa en primer lugar los mensajes <code>HighPriorityMsg</code> aunque exista un mensaje <code>LowPriorityMsg</code> más antiguo en el buzón. El actor sólo procesará mensajes <code>LowPriorityMsg</code> en primer lugar en aquella situación donde no exista ningún <code>HighProrityMsg</code> en el buzón.</p>
</li>
</ul>

<p>Adicionalmente, el tipo <code>ReplyActor</code> añade el estado de ejecución <code>Actor.State.TimedSuspended</code>. Un actor suspendido, esperando la recepción de un mensaje mediante el uso de <code>reactWithin</code> se encuentra en dicho estado.</p>

<h3 id='el_trait_actor'>El trait Actor</h3>

<p>El trait <code>Actor</code> extiende de <code>ReplyReactor</code> añadiendo y/o sobrescribiendo los siguientes miembros:</p>

<ul>
<li>
<p>El método (añadido) <code>receive</code> se comporta del mismo modo que <code>react</code>, con la excepción de que puede retornar un resultado. Este hecho se ve reflejado en la definición del tipo, que es polimórfico en el tipo del resultado:</p>

<p>def receiveRartialFunction<span>Any, R</span>): R</p>

<p>Sin embargo, la utilización de <code>receive</code> hace que el uso del actor sea más pesado, puesto que el hilo subyacente es bloqueado mientras el actor está esperando por la respuesta. El hilo bloqueado no está disponible para ejecutar otros actores hasta que la invocación del método <code>receive</code> haya retornado.</p>
</li>

<li>
<p>El método (añadido) <code>link</code> permite a un actor enlazarse y desenlazarse de otro actor respectivamente. El proceso de enlazado puede utilizarse para monitorizar y responder a la terminación de un actor. En particular, el proceso de enlazado afecta al comportamiento mostrado en la ejecución del método <code>exit</code> tal y como se escribe en el la documentación del API del trait <code>Actor</code>.</p>
</li>

<li>
<p>El atributo <code>trapExit</code> permite responder a la terminación de un actor enlazado, independientemente de los motivos de su terminación (es decir, carece de importancia si la terminación del actor es normal o no). Si <code>trapExit</code> toma el valor cierto en un actor, este nunca terminará por culpa de los actores enlazados. En cambio, siempre y cuando uno de sus actores enlazados finalice, recibirá un mensaje de tipo <code>Exit</code>. <code>Exit</code> es una &#8220;case class&#8221; que presenta dos atributos: <code>from</code> referenciando al actor que termina y <code>reason</code> conteniendo los motivos de la terminación.</p>
</li>
</ul>

<h4 id='terminacin_y_estados_de_ejecucin'>Terminación y estados de ejecución</h4>

<p>Cuando la ejecución de un actor finaliza, el motivo de dicha terminación puede ser establecida de manera explícita mediante la invocación de la siguiente variante del método <code>exit</code>:</p>

<pre><code>def exit(reason: AnyRef): Nothing</code></pre>

<p>Un actor cuyo estado de terminación es diferente del símbolo <code>&#39;normal</code> propaga los motivos de su terminación a todos aquellos actores que se encuentren enlazados a él. Si el motivo de la terminación es una excepción no controlada, el motivo de finalización será una instancia de la &#8220;case class&#8221; <code>UncaughtException</code>.</p>

<p>El trait <code>Actor</code> incluye dos nuevos estados de ejecución. Un actor que se encuentra esperando la recepción de un mensaje mediante la utilización del método <code>receive</code> se encuentra en el método <code>Actor.State.Blocked</code>. Un actor esperado la recepción de un mensaje mediante la utilización del método <code>receiveWithin</code> se encuentra en el estado <code>Actor.State.TimeBlocked</code>.</p>

<h2 id='estructuras_de_control'>Estructuras de control</h2>

<p>El trait <code>Reactor</code> define una serie de estructuras de control que simplifican el mecanismo de programación con la función sin retorno <code>react</code>. Normalmente, una invocación al método <code>react</code> no retorna nunca. Si el actor necesita ejecutar código a continuación de la invocación anterior, tendrá que pasar, de manera explícita, dicho código al método <code>react</code> o utilizar algunas de las estructuras que encapsulan este comportamiento.</p>

<p>La estructura de control más basica es <code>andThen</code>. Permite registrar una <code>closure</code> que será ejecutada una vez el actor haya terminado la ejecución de todo lo demas.</p>

<pre><code>actor {
  {
    react {
      case &quot;hello&quot; =&gt; // processing &quot;hello&quot;
    }: Unit
  } andThen {
    println(&quot;hi there&quot;)
  }
}</code></pre>

<p>Por ejemplo, el actor anterior imprime un saludo tras realizar el procesado del mensaje <code>hello</code>. Aunque la invocación del método <code>react</code> no retorna, podemos utilizar <code>andThen</code> para registrar el código encargado de imprimir el saludo a continuación de la ejecución del actor.</p>

<p>Nótese que existe una <em>atribución de tipo</em> a continuación de la invocación de <code>react</code> (<code>:Unit</code>). Básicamente, nos permite tratar el resultado de <code>react</code> como si fuese de tipo <code>Unit</code>, lo cual es legal, puesto que el resultado de una expresión siempre se puede eliminar. Es necesario llevar a cabo esta operación dado que <code>andThen</code> no puede ser un miembro del tipo <code>Unit</code>, que es el tipo del resultado retornado por <code>react</code>. Tratando el tipo de resultado retornado por <code>react</code> como <code>Unit</code> permite llevar a cabo la aplicación de una conversión implícita la cual hace que el miembro <code>andThen</code> esté disponible.</p>

<p>El API ofrece unas cuantas estructuras de control adicionales:</p>

<ul>
<li>
<p><code>loop { ... }</code>. Itera de manera indefinidia, ejecutando el código entre las llaves en cada una de las iteraciones. La invocación de <code>react</code> en el cuerpo del bucle provoca que el actor se comporte de manera habitual ante la llegada de un nuevo mensaje. Posteriormente a la recepción del mensaje, la ejecución continua con la siguiente iteración del bucle actual.</p>
</li>

<li>
<p><code>loopWhile (c) { ... }</code>. Ejecuta el código entre las llaves mientras la condición <code>c</code> tome el valor <code>true</code>. La invocación de <code>react</code> en el cuerpo del bucle ocasiona el mismo efecto que en el caso de <code>loop</code>.</p>
</li>

<li>
<p><code>continue</code>. Continua con la ejecución de la closure actual. La invocación de <code>continue</code> en el cuerpo de un <code>loop</code>o <code>loopWhile</code> ocasionará que el actor termine la iteración en curso y continue con la siguiente. Si la iteración en curso ha sido registrada utilizando <code>andThen</code>, la ejecución continua con la segunda &#8220;closure&#8221; pasada como segundo argumento a <code>andThen</code>.</p>
</li>
</ul>

<p>Las estructuras de control pueden ser utilizadas en cualquier parte del cuerpo del método <code>act</code> y en los cuerpos de los métodos que, transitivamente, son llamados por <code>act</code>. Aquellos actores creados utilizando la sintáxis <code>actor { ... }</code> pueden importar las estructuras de control desde el objeto <code>Actor</code>.</p>

<h4 id='futures'>Futures</h4>

<p>Los traits <code>RepyActor</code> y <code>Actor</code> soportan operaciones de envío de mensajes (métodos <code>!!</code>) que, de manera inmediata, retornan un <em>future</em>. Un <em>future</em>, es una instancia del trait <code>Future</code> y actúa como un manejador que puede ser utilizado para recuperar la respuesta a un mensaje &#8220;send-with-future&#8221;.</p>

<p>El emisor de un mensaje &#8220;send-with-future&#8221; puede esperar por la respuesta del future <em>aplicando</em> dicha future. Por ejemplo, el envío de un mensaje mediante <code>val fut = a !! msg</code> permite al emisor esperar por el resultado del future del siguiente modo: <code>val res = fut()</code>.</p>

<p>Adicionalmente, utilizando el método <code>isSet</code>, un <code>Future</code> puede ser consultado de manera no bloqueante para comprobar si el resultado está disponible.</p>

<p>Un mensaje &#8220;send-with-future&#8221; no es el único modo de obtener una referencia a un future. Estos pueden ser creados utilizando el método <code>future</code>. En el siguiente ejemplo, <code>body</code> se ejecuta de manera concurrente, retornando un future como resultado.</p>

<pre><code>val fut = future { body }
// ...
fut() // wait for future</code></pre>

<p>Lo que hace especial a los futures en el contexto de los actores es la posibilidad de recuperar su resultado utilizando las operaciones estándar de actores de recepción de mensajes como <code>receive</code>, etc. Además, es posible utilizar las operaciones basadas en eventos <code>react</code>y <code>reactWithin</code>. Esto permite a un actor esperar por el resultado de un future sin la necesidad de bloquear el hilo subyacente.</p>

<p>Las operaciones de recepción basadas en actores están disponibles a través del atributo <code>inputChannel</code> del future. Dado un future de tipo <code>Future[T]</code>, el tipo de <code>inputChannel</code> es <code>InputChannel[T]</code>. Por ejemplo:</p>

<pre><code>val fut = a !! msg
// ...
fut.inputChannel.react {
  case Response =&gt; // ...
}</code></pre>

<h2 id='canales'>Canales</h2>

<p>Los canales pueden ser utilizados para simplificar el manejo de mensajes que presentan tipos diferentes pero que son enviados al mismo actor. La jerarquía de canales se divide en <code>OutputChannel</code> e <code>InputChannel</code>.</p>

<p>Los <code>OutputChannel</code> pueden ser utilizados para enviar mensajes. Un <code>OutputChannel</code> <code>out</code> soporta las siguientes operaciones:</p>

<ul>
<li>
<p><code>out ! msg</code>. Envía el mensaje <code>msg</code> a <code>out</code> de manera asíncrona. Cuando <code>msg</code> es enviado directamente a un actor se incluye un referencia al actor emisor del mensaje.</p>
</li>

<li>
<p><code>out forward msg</code>. Reenvía el mensaje <code>msg</code> a <code>out</code> de manera asíncrona. El actor emisor se determina en el caso en el que <code>msg</code> es reenviado a un actor.</p>
</li>

<li>
<p><code>out.receiver</code>. Retorna el único actor que está recibiendo mensajes que están siendo enviados al canal <code>out</code>.</p>
</li>

<li>
<p><code>out.send(msg, from)</code>. Envía el mensaje <code>msg</code> a <code>out</code> de manera asíncrona, proporcionando a <code>from</code> como el emisor del mensaje.</p>
</li>
</ul>

<p>Nótese que el trait <code>OutputChannel</code> tiene un parámetro de tipo que especifica el tipo de los mensajes que pueden ser enviados al canal (utilizando <code>!</code>, <code>forward</code>, y <code>send</code>). Este parámetro de tipo es contra-variante:</p>

<pre><code>trait OutputChannel[-Msg]</code></pre>

<p>Los actores pueden recibir mensajes de un <code>InputChannel</code>. Del mismo modo que <code>OutputChannel</code>, el trait <code>InputChannel</code> presenta un parámetro de tipo que especifica el tipo de mensajes que pueden ser recibidos por el canal. En este caso, el parámetro de tipo es covariante:</p>

<pre><code>trait InputChannel[+Msg]</code></pre>

<p>Un <code>InputChannel[Msg]</code> <code>in</code> soportal las siguientes operaciones.</p>

<ul>
<li>
<p><code>in.receive { case Pat1 =&gt; ... ; case Patn =&gt; ... }</code> (y de manera similar, <code>in.receiveWithin</code>) recibe un mensaje proveniente de <code>in</code>. La invocación del método <code>receive</code> en un canal de entrada presenta la misma semántica que la operación estándar de actores <code>receive</code>. La única diferencia es que la función parcial pasada como argumento tiene tipo <code>PartialFunction[Msg, R]</code> donde <code>R</code> es el tipo de retorno de <code>receive</code>.</p>
</li>

<li>
<p><code>in.react { case Pat1 =&gt; ... ; case Patn =&gt; ... }</code> (y de manera similar, <code>in.reactWithin</code>). Recibe un mensaje de <code>in</code> utilizando la operación basada en eventos <code>react</code>. Del mismo modo que la operación <code>react</code> en actores, el tipo de retorno es <code>Nothing</code>, indicando que las invocaciones de este método nunca retornan. Al igual que la operación <code>receive</code> anterior, la función parcial que se pasa como argumento presenta un tipo más específico:</p>

<p>PartialFunction<span>Msg, Unit</span></p>
</li>
</ul>

<h3 id='creando_y_compartiendo_canales'>Creando y compartiendo canales</h3>

<p>Los canales son creados utilizando la clase concreta <code>Channel</code>. Esta clase extiende de <code>InputChannel</code> y <code>OutputChannel</code>. Un canal pueden ser compartido haciendo dicho canal visible en el ámbito de múltiples actores o enviándolo como mensaje.</p>

<p>El siguiente ejemplo muestra la compartición mediante publicación en ámbitos:</p>

<pre><code>actor {
  var out: OutputChannel[String] = null
  val child = actor {
    react {
      case &quot;go&quot; =&gt; out ! &quot;hello&quot;
    }
  }
  val channel = new Channel[String]
  out = channel
  child ! &quot;go&quot;
  channel.receive {
    case msg =&gt; println(msg.length)
  }
}</code></pre>

<p>La ejecución de este ejemplo imprime la cadena &#8220;5&#8221; en la consola. Nótese que el actor <code>child</code> únicamente tiene acceso a <code>out</code>, que es un <code>OutputChannel[String]</code>. La referencia al canal, la cual puede ser utilizada para llevar a cabo la recepción de mensajes, se encuentra oculta. Sin embargo, se deben tomar precauciones y asegurarse que el canal de salida es inicializado con un canal concreto antes de que <code>child</code> le envíe ningún mensaje. En el ejemplo que nos ocupa, esto es llevado a cabo mediante el mensaje &#8220;go&#8221;. Cuando se está recibiendo de <code>channel</code> utilizando el método <code>channel.receive</code> podemos hacer uso del hecho que <code>msg</code> es de tipo <code>String</code>, y por lo tanto tiene un miembro <code>length</code>.</p>

<p>Una alternativa a la compartición de canales es enviarlos a través de mensajes. El siguiente fragmento de código muestra un sencillo ejemplo de aplicación:</p>

<pre><code>case class ReplyTo(out: OutputChannel[String])

val child = actor {
  react {
    case ReplyTo(out) =&gt; out ! &quot;hello&quot;
  }
}

actor {
  val channel = new Channel[String]
  child ! ReplyTo(channel)
  channel.receive {
    case msg =&gt; println(msg.length)
  }
}</code></pre>

<p>La &#8220;case class&#8221; <code>ReplyTo</code> es un tipo de mensajes que utilizamos para distribuir una referencia a un <code>OutputChannel[String]</code>. Cuando el actor <code>child</code> recibe un mensaje de tipo <code>ReplyTo</code> éste envía una cadena a su canal de salida. El segundo actor recibe en el canal del mismo modo que anteriormente.</p>

<h2 id='planificadores'>Planificadores</h2>

<p>Un <code>Reactor</code>(o una instancia de uno de sus subtipos) es ejecutado utilizando un <em>planificador</em>. El trait <code>Reactor</code> incluye el miembro <code>scheduler</code> el cual retorna el planificador utilizado para ejecutar sus instancias:</p>

<pre><code>def scheduler: IScheduler</code></pre>

<p>La plataforma de ejecución ejecuta los actores enviando tareas al planificador mediante el uso de los métodos <code>execute</code> definidos en el trait <code>IScheduler</code>. La mayor parte del resto de métodos definidos en este trait únicamente adquieren cierto protagonismo cuando se necesita implementar un nuevo planificador desde cero; algo que no es necesario en muchas ocasiones.</p>

<p>Los planificadores por defecto utilizados para ejecutar instancias de <code>Reactor</code> y <code>Actor</code> detectan cuando los actores han finalizado su ejecución. En el momento que esto ocurre, el planificador se termina a si mismo (terminando con cualquier hilo que estuviera en uso por parte del planificador). Sin embargo, algunos planificadores como el <code>SingleThreadedScheduler</code> (definido en el paquete <code>scheduler</code>) necesita ser terminado de manera explícita mediante la invocación de su método <code>shutdown</code>).</p>

<p>La manera más sencilla de crear un planificador personalizado consisten en extender la clase <code>SchedulerAdapter</code>, implementando el siguiente método abstracto:</p>

<pre><code>def execute(fun: =&gt; Unit): Unit</code></pre>

<p>Por norma general, una implementación concreata utilizaría un pool de hilos para llevar a cabo la ejecución del argumento por nombre <code>fun</code>.</p>

<h2 id='actores_remotos'>Actores remotos</h2>

<p>Esta sección describe el API de los actores remotos. Su principal interfaz es el objecto <a href='http://www.scala-lang.org/api/2.9.1/scala/actors/remote/RemoteActor$.html'><code>RemoteActor</code></a> definido en el paquete <code>scala.actors.remote</code>. Este objeto facilita el conjunto de métodos necesarios para crear y establecer conexiones a instancias de actores remotos. En los fragmentos de código que se muestran a continuación se asume que todos los miembros de <code>RemoteActor</code> han sido importados; la lista completa de importaciones utilizadas es la siguiente:</p>

<pre><code>import scala.actors._
import scala.actors.Actor._
import scala.actors.remote._
import scala.actors.remote.RemoteActor._</code></pre>

<h3 id='iniciando_actores_remotos'>Iniciando actores remotos</h3>

<p>Un actore remot es identificado de manera unívoca por un <a href='http://www.scala-lang.org/api/2.9.1/scala/Symbol.html'><code>Symbol</code></a>. Este símbolo es único para la instancia de la máquina virual en la que se está ejecutando un actor. Un actor remoto identificado con el nombre <code>myActor</code> puede ser creado del siguiente modo.</p>

<pre><code>class MyActor extends Actor {
  def act() {
    alive(9000)
    register(&#39;myActor, self)
    // ...
  }
}</code></pre>

<p>Nótese que el nombre únicamente puede ser registrado con un único actor al mismo tiempo. Por ejemplo, para registrar el actor <em>A</em> como <code>&#39;myActor</code> y posteriormente registrar otro actor <em>B</em> como <code>&#39;myActor</code>, debería esperar hasta que <em>A</em> haya finalizado. Este requisito aplica a lo largo de todos los puertos, por lo que registrando a <em>B</em> en un puerto diferente no sería suficiente.</p>

<h3 id='connecting_to_remote_actors'>Connecting to remote actors</h3>

<p>Establecer la conexión con un actor remoto es un proceso simple. Para obtener una referencia remota a un actor remoto que está ejecutándose en la máquina <code>myMachine</code> en el puerto 8000 con el nombre <code>&#39;anActor</code>, tendremos que utilizar <code>select</code>del siguiente modo:</p>

<pre><code>val myRemoteActor = select(Node(&quot;myMachine&quot;, 8000), &#39;anActor)</code></pre>

<p>El actor retornado por <code>select</code> es de tipo <code>AbstractActor</code>, que proporciona esencialmente el mismo interfaz que un actor normal, y por lo tanto es compatible con las habituales operaciones de envío de mensajes:</p>

<pre><code>myRemoteActor ! &quot;Hello!&quot;
receive {
  case response =&gt; println(&quot;Response: &quot; + response)
}
myRemoteActor !? &quot;What is the meaning of life?&quot; match {
  case 42   =&gt; println(&quot;Success&quot;)
  case oops =&gt; println(&quot;Failed: &quot; + oops)
}
val future = myRemoteActor !! &quot;What is the last digit of PI?&quot;</code></pre>

<p>Nótese que la operación <code>select</code> es perezosa; no inicializa ninguna conexión de red. Simplemente crea una nueva instancia de <code>AbstractActor</code> que está preparada para iniciar una nueva conexión de red en el momento en que sea necesario (por ejemplo cuando el método &#8217;!&#8217; es invocado).</p>
      
    </div>
    
    <div class="span6">
      <div id="scroller-anchor">
  <div id="scroller">
    <p class="contents">Contents</p>
    <div id="toc"></div>    
              
  </div>
</div>

    </div>
    
	
  </div>
</div>

<div class="footer">
	<div class="container">
		<ul>
			<li><h5>API</h5></li>
			<li><a href="http://www.scala-lang.org/api/current/">Current</a></li>
			<li><a href="http://www.scala-lang.org/archives/downloads/distrib/files/nightly/docs/library/index.html">Nightly</a></li>
		</ul>
		<ul>
			<li><h5>Learn</h5></li>
			<li><a href="/overviews">Guides & Overviews</a></li>
			<li><a href="/tutorials">Tutorials</a></li>
			<li><a href="/style">Scala Style Guide</a></li>				
		</ul>
		<ul>
			<li><h5>Quickref</h5></li>
			<li><a href="/glossary">Glossary</a></li>
			<li><a href="/cheatsheets">Cheatsheets</a></li>
		</ul>
		<ul>
			<li><h5>Contribute</h5></li>
			<li><a href="http://github.com/scala/scala.github.com">Source Code</a></li>
			<li><a href="/contribute.html">Contributors Guide</a></li>
			<li><a href="http://getsatisfaction.com/scaladocs">Suggestions</a></li>			
		</ul>
		<ul>
			<li><h5>Other Resources</h5></li>
			<li><a href="http://wiki.scala-lang.org">Wiki</a></li>
			<li><a href="/sips">Scala Improvement Process</a></li>				
		</ul>						
	</div>
	<div class="container copyright">
 		<p>
			Copyright &copy; 2011-2013 EPFL. All rights reserved.
			<a href="https://github.com/scala/scala.github.com/commits/gh-pages.atom"><img align="right" height="20px" width="20px" src="/resources/images/rss.png" alt="RSS feed of updates to the github repo hosting this site"></a>
		</p>		
	</div>
</div>


<script type="text/javascript">
  $('#toc').toc({exclude: 'h1, h5, h6', context: '', autoId: true, numerate: false});
</script>

<script type="text/javascript">
  $(function() {
    moveScroller();
  });
</script>

  </body>
</html>

    
