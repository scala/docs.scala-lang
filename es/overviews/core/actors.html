
<!DOCTYPE html>
<html>
  <head>

    <title>API de actores en Scala - Scala Documentation</title>
    
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>

    <link rel="icon" type="image/png" href="/resources/favicon.ico">

    <!-- prettify js and CSS -->
    <link rel="stylesheet" href="/resources/stylesheets/prettify.css" type="text/css" />
    <script src="/resources/javascript/prettify/prettify.js" type="text/javascript" ></script>


    <!-- jquery js -->
    <script src="/resources/javascript/jquery.js" type="text/javascript" ></script>
    <script src="/resources/javascript/effects.core.js" type="text/javascript" ></script>
    <script src="/resources/javascript/effects.highlight.js" type="text/javascript" ></script>
    <script src="/resources/javascript/moveScroller.js" type="text/javascript" ></script>

    <!-- Bootstrap JS and CSS -->
    <link rel="stylesheet" href="/resources/stylesheets/bootstrap.css" type="text/css" />
	  <script src="/resources/javascript/bootstrap-dropdown.js" type="text/javascript" ></script>
	  <script src="/resources/javascript/bootstrap-dropdown-app.js" type="text/javascript" ></script>

    <!-- Base stylesheet for all pages -->
    <link rel="stylesheet" href="/resources/stylesheets/base.css" type="text/css" />

    <!-- table of contents js -->
    <script src="/resources/javascript/toc.js" type="text/javascript" ></script>

    <!-- google analytics -->
	<script type="text/javascript">

	  var _gaq = _gaq || [];
	  _gaq.push(['_setAccount', 'UA-574683-5']);
	  _gaq.push(['_trackPageview']);

	  (function() {
	    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
	    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
	    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
	  })();

	</script>

    <!-- prettyprint js to prepend generated pre/code tags -->
    <script type="text/javascript">
      function styleCode()
        {
          if (typeof disableStyleCode != "undefined")
          {
              return;
          }
          var a = false;
          $("pre code").parent().each(function()
          {
              if (!$(this).hasClass("prettyprint"))
              {
                  $(this).addClass("prettyprint lang-scala linenums");
                  a = true
              }
          });
          if (a) { prettyPrint() }
      }
    </script>

    <script type="text/javascript">
      jQuery(document).ready(function($) {

            $(".scroll").click(function(event){
              event.preventDefault();
              $('html,body').animate({scrollTop:$(this.hash).offset().top}, 500);
              $('html,body').animate({scrollTop:$(this.hash).offset().top-=50}, 500);
              $(this.hash).effect("highlight", {color: "#FFCC85"}, 3000);
            });
      });
    </script>

    <script type="text/javascript">
      $(window).ready(function goToSubsection() {
          if (window.location.hash)
          {
              $('html,body').animate({scrollTop:$(window.location.hash).offset().top}, 500);
              $('html,body').animate({scrollTop:$(window.location.hash).offset().top-=50}, 500);
              $(window.location.hash).effect("highlight", {color: "#FFCC85"}, 3000);
          }
        });
    </script>

    <style type="text/css">

       p.contents {
           margin-left: 15px;
           font-weight: bold;
           font-size: 16px;
       }

       div#toc ul {
           list-style: none;
       }

       div#toc ul a {
           display: block;
           list-style: none;
           line-height: 22px;
           font-weight: bold;
           width: 100%;
       }

      div#toc ul li ul {
           list-style: disc;
      }

      div#toc ul li ul a {
           line-height: 18px;
           font-weight: normal;
      }

      div#toc ul li ul li ul {
           list-style: square;
      }
       div#toc ul li ul li ul a {
       }

       div#scroller-anchor {
           width: inherit;
       }

       div#scroller {
           width: inherit;
       }

       div#guide-title {
        text-transform: capitalize;
        font-size: 16px;
        padding-bottom: 6px;
        color: #BFBFBF;
        text-transform: uppercase;
        font-weight: bold;
       }

       input, textarea, select, .uneditable-input {
	       width: 165px;
	     }

    </style>

</head>
  <body onload="styleCode()">

    <!-- Topbar
    ================================================== -->
<div class="topbar">
    <div class="topbar-inner">
        <div class="container">
            <a class="brand" href="/index.html"><img src="/resources/images/scala-logo.png"> Documentation</a>
            <ul class="nav">

                <li class="menu">
                      <a href="#" class="menu">API</a>
                      <ul class="menu-dropdown">
                        <li><a href="http://www.scala-lang.org/api/current/">Current</a></li>
                        <li><a href="http://www.scala-lang.org/archives/downloads/distrib/files/nightly/docs/library/index.html">Nightly</a></li>
                        <!--<li class="divider"></li>
                        <li><a href="#">Previous Versions</a></li>
                        -->
                      </ul>
                </li>

                <li class="menu">
                      <a href="#" class="menu">Learn</a>
                      <ul class="menu-dropdown">
                        <li><a href="/overviews">Guides & Overviews</a></li>
                        <li><a href="/tutorials">Tutorials</a></li>
                        <li><a href="/style">Scala Style Guide</a></li>
                      </ul>
                </li>

                <li class="menu">
                      <a href="#" class="menu">Quickref</a>
                      <ul class="menu-dropdown">
                        <li><a href="/glossary">Glossary</a></li>
                        <li><a href="/cheatsheets">Cheatsheets</a></li>
                      </ul>
                </li>

                <li><a href="/contribute.html">Contribute</a></li>
                <li><a href="/sips">SIPs</a></li>
                <li><a href="http://wiki.scala-lang.org">Wiki</a></li>
          </ul>
          <form method="get" id="searchform" action="/search.html">
            <input type="text" placeholder="Search"  class="field" name="q" id="q"/>
          </form>
           </li>
          </ul>
        </div>
    </div>
</div>

<div class="container">
  <div class="row">
    
    <div class="span10"><h1>API de actores en Scala</h1></div>

    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
        
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    

    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    

    
      
      
    

    <div class="span6">
      
        <a href="/overviews/core/actors.html"><img src="/resources/images/language/en.png" title="Language: en"/></a> 
        
          <a href="/es/overviews/core/actors.html"><img src="/resources/images/language/es.png" title="Language: es"/></a> 
        
      
    </div>

    <div class="span10">
      <p><strong>Philipp Haller and Stephen Tu</strong></p>

<p><strong>Traducci√≥n e interpretaci√≥n: Miguel √Ångel Pastor Olivar</strong></p>

<h2 id='introduccin'>Introducci√≥n</h2>

<p>La presente gu√≠a describe el API del paquete <code>scala.actors</code> de Scala 2.8/2.9. El documento se estructura en diferentes grupos l√≥gicos. La jerarqu√≠a de &#8220;traits&#8221; es tenida en cuenta para llevar a cabo la estructuraci√≥n de las secciones individuales. La atenci√≥n se centra en el comportamiento exhibido en tiempo de ejecuci√≥n por varios de los m√©todos presentes en los traits anteriores, complementando la documentaci√≥n existente en el Scaladoc API.</p>

<h2 id='traits_de_actores_reactor_replyreactor_y_actor'>Traits de actores: Reactor, ReplyReactor, y Actor</h2>

<h3 id='the_reactor_trait'>The Reactor trait</h3>

<p><code>Reactor</code> es el padre de todos los traits relacionados con los actores. Heredando de este trait podremos definir actores con una funcionalidad b√°sica de env√≠o y recepci√≥n de mensajes.</p>

<p>El comportamiento de un <code>Reactor</code> se define mediante la implementaci√≥n de su m√©todo <code>act</code>. Este m√©todo es ejecutado una vez el <code>Reactor</code> haya sido iniciado mediante la invocaci√≥n del m√©todo <code>start</code>, retornando el <code>Reactor</code>. El m√©todo <code>start</code>es <em>idempotente</em>, lo cual significa que la invocaci√≥n del mismo sobre un actor que ya ha sido iniciado no surte ning√∫n efecto.</p>

<p>El trait <code>Reactor</code> tiene un par√°metro de tipo <code>Msg</code> el cual determina el tipo de mensajes que un actor es capaz de recibir.</p>

<p>La invocaci√≥n del m√©todo <code>!</code> de un <code>Reactor</code> env√≠a un mensaje al receptor. La operaci√≥n de env√≠o de un mensaje mediante el operador <code>!</code> es as√≠ncrona por lo que el actor que env√≠a el mensaje no se bloquea esperando a que el mensaje sea recibido sino que su ejecuci√≥n continua de manera inmediata. Por ejemplo, <code>a ! msg</code> envia <code>msg</code> a <code>a</code>. Todos los actores disponen de un <em>buz√≥n</em> encargado de regular los mensajes entrantes hasta que son procesados.</p>

<p>El trait <code>Reactor</code> trait tambi√©n define el m√©todo <code>forward</code>. Este m√©todo es heredado de <code>OutputChannel</code> y tiene el mismo efecto que el m√©todo <code>!</code>. Aquellos traits que hereden de <code>Reactor</code>, en particular el trait <code>ReplyActor</code>, sobreescriben este m√©todo para habilitar lo que comunmente se conocen como <em>&#8220;implicit reply destinations&#8221;</em> (ver a continuaci√≥n)</p>

<p>Un <code>Reactor</code> recibe mensajes utilizando el m√©todo <code>react</code>. Este m√©todo espera un argumento de tipo <code>PartialFunction[Msg, Unit]</code> el cual define c√≥mo los mensajes de tipo <code>Msg</code> son tratados una vez llegan al buz√≥n de un actor. En el siguiente ejemplo, el actor espera recibir la cadena &#8220;Hello&#8221;, para posteriomente imprimir un saludo:</p>

<pre><code>react {
  case &quot;Hello&quot; =&gt; println(&quot;Hi there&quot;)
}</code></pre>

<p>La invocaci√≥n del m√©todo <code>react</code> nunca retorna. Por tanto, cualquier c√≥digo que deba ejecutarse tras la recepci√≥n de un mensaje deber√° ser incluido dentro de la funci√≥n parcial pasada al m√©todo <code>react</code>. Por ejemplo, dos mensajes pueden ser recibidos secuencialmente mediante la anidaci√≥n de dos llamadas a <code>react</code>:</p>

<pre><code>react {
  case Get(from) =&gt;
    react {
      case Put(x) =&gt; from ! x
    }
}</code></pre>

<p>El trait <code>Reactor</code> tambi√©n ofrece una serie de estructuras de control que facilitan la programaci√≥n utilizando el mecanismo de <code>react</code>.</p>

<h4 id='terminacin_y_estados_de_ejecucin'>Terminaci√≥n y estados de ejecuci√≥n</h4>

<p>La ejecuci√≥n de un <code>Reactor</code> finaliza cuando el cuerpo del m√©todo <code>act</code> ha sido completado. Un <code>Reactor</code> tambi√©n pueden terminarse a si mismo de manera expl√≠cita mediante el uso del m√©todo <code>exit</code>. El tipo de retorno de <code>exit</code> es <code>Nothing</code>, dado que <code>exit</code> siempre dispara una excepci√≥n. Esta excepci√≥n √∫nicamente se utiliza de manera interna y nunca deber√≠a ser capturada.</p>

<p>Un <code>Reactor</code> finalizado pueden ser reiniciado mediante la invocaci√≥n de su m√©todo <code>restart</code>. La invocaci√≥n del m√©todo anterior sobre un <code>Reactor</code> que no ha terminado su ejecuci√≥n lanza una excepci√≥n de tipo <code>IllegalStateException</code>. El reinicio de un actor que ya ha terminado provoca que el m√©todo <code>act</code> se ejecute nuevamente.</p>

<p>El tipo <code>Reactor</code> define el m√©todo <code>getState</code>, el cual retorna, como un miembro de la enumeraci√≥n <code>Actor.State</code>, el estado actual de la ejecuci√≥n del actor. Un actor que todav√≠a no ha sido iniciado se encuentra en el estado <code>Actor.State.New</code>. Si el actor se est√° ejecutando pero no est√° esperando por ning√∫n mensaje su estado ser√° <code>Actor.State.Runnable</code>. En caso de que el actor haya sido suspendido mientras espera por un mensaje estar√° en el estado <code>Actor.State.Suspended</code>. Por √∫ltimo, un actor ya terminado se encontrar√° en el estado <code>Actor.State.Terminated</code>.</p>

<h4 id='manejo_de_excepciones'>Manejo de excepciones</h4>

<p>El miembro <code>exceptionHandler</code> permite llevar a cabo la definici√≥n de un manejador de excepciones que estar√° habilitado durante toda la vida del <code>Reactor</code>:</p>

<pre><code>def exceptionHandler: PartialFunction[Exception, Unit]</code></pre>

<p>Este manejador de excepciones (<code>exceptionHandler</code>) retorna una funci√≥n parcial que se utiliza para gestionar excepciones que no hayan sido tratadas de ninguna otra manera. Siempre que una excepci√≥n se propague fuera del m√©todo <code>act</code> de un <code>Reactor</code> el manejador anterior ser√° aplicado a dicha excepci√≥n, permitiendo al actor ejecutar c√≥digo de limpieza antes de que se termine. N√≥tese que la visibilidad de <code>exceptionHandler</code> es <code>protected</code>.</p>

<p>El manejo de excepciones mediante el uso de <code>exceptionHandler</code> encaja a la perfecci√≥n con las estructuras de control utilizadas para programas con el m√©todo <code>react</code>. Siempre que una excepci√≥n es manejada por la funci√≥n parcial retornada por <code>excepctionHandler</code>, la ejecuci√≥n continua con la &#8220;closure&#8221; actual:</p>

<pre><code>loop {
  react {
    case Msg(data) =&gt;
      if (cond) // process data
      else throw new Exception(&quot;cannot process data&quot;)
  }
}</code></pre>

<p>Assumiendo que <code>Reactor</code> sobreescribe el atributo <code>exceptionHandler</code>, tras el lanzamiento de una excepci√≥n en el cuerpo del m√©todo <code>react</code>, y una vez √©sta ha sido gestionada, la ejecuci√≥n continua con la siguiente iteraci√≥n del bucle.</p>

<h3 id='the_replyreactor_trait'>The ReplyReactor trait</h3>

<p>El trait <code>ReplyReactor</code> extiende <code>Reactor[Any]</code> y sobrescribe y/o a√±ade los siguientes m√©todos:</p>

<ul>
<li>
<p>El m√©todo <code>!</code> es sobrescrito para obtener una referencia al actor actual (el emisor). Junto al mensaje actual, la referencia a dicho emisor es enviada al buz√≥n del actor receptor. Este √∫ltimo dispone de acceso al emisor del mensaje mediante el uso del m√©todo <code>sender</code> (v√©ase m√°s abajo).</p>
</li>

<li>
<p>El m√©todo <code>forward</code> es sobrescrito para obtener una referencia al emisor del mensaje que actualmente est√° siendo procesado. Junto con el mensaje actual, esta referencia es enviada como el emisor del mensaje actual. Como consuencia de este hecho, <code>forward</code> nos permite reenviar mensajes en nombre de actores diferentes al actual.</p>
</li>

<li>
<p>El m√©todo (a√±adido) <code>sender</code> retorna el emisor del mensaje que est√° siendo actualmente procesado. Puesto que un mensaje puede haber sido reenviado, <code>sender</code> podr√≠a retornar un actor diferente al que realmente envi√≥ el mensaje.</p>
</li>

<li>
<p>El m√©todo (a√±adido) <code>reply</code> env√≠a una respuesta al emisor del √∫ltimo mensaje. <code>reply</code> tambi√©n es utilizado para responder a mensajes s√≠ncronos o a mensajes que han sido enviados mediante un &#8220;future&#8221; (ver m√°s adelante).</p>
</li>

<li>
<p>El m√©todo (a√±adido) <code>!?</code> ofrece un <em>mecanismo s√≠ncrono de env√≠o de mensajes</em>. La invocaci√≥n de <code>!?</code> provoca que el actor emisor del mensaje se bloquee hasta que se recibe una respuesta, momento en el cual retorna dicha respuesta. Existen dos variantes sobrecargadas. La versi√≥n con dos par√°metros recibe un argumento adicional que representa el tiempo de espera (medido en milisegundos) y su tipo de retorno es <code>Option[Any]</code> en lugar de <code>Any</code>. En caso de que el emisor no reciba una respuesta en el periodo de espera establecido, el m√©todo <code>!?</code> retornar√° <code>None</code>; en otro caso retornar√° la respuesta recibida recubierta con <code>Some</code>.</p>
</li>

<li>
<p>Los m√©todos (a√±adidos) <code>!!</code> son similares al env√≠o s√≠ncrono de mensajes en el sentido de que el receptor puede enviar una respuesta al emisor del mensaje. Sin embargo, en lugar de bloquear el actor emisor hasta que una respuesta es recibida, retornan una instancia de <code>Future</code>. Esta √∫ltima puede ser utilizada para recuperar la respuesta del receptor una vez se encuentre disponible; asimismo puede ser utilizada para comprobar si la respuesta est√° disponible sin la necesidad de bloquear el emisor. Existen dos versiones sobrecargadas. La versi√≥n que acepta dos par√°metros recibe un argumento adicional de tipo <code>PartialFuntion[Any, A]</code>. Esta funci√≥n parcial es utilizada para realizar el post-procesado de la respuesta del receptor. B√°sicamente, <code>!!</code> retorna un &#8220;future&#8221; que aplicar√° la anterior funci√≥n parcial a la repuesta (una vez recibida). El resultado del &#8220;future&#8221; es el resultado de este post-procesado.</p>
</li>

<li>
<p>El m√©todo (a√±adido) <code>reactWithin</code> permite llevar a cabo la recepci√≥n de mensajes en un periodo determinado de tiempo. En comparaci√≥n con el m√©todo <code>react</code>, recibe un par√°metro adicional, <code>msec</code>, el cual representa el periodo de tiempo, expresado en milisegundos, hasta que el patr√≥n <code>TIMEOUT</code> es satisfecho (<code>TIMEOUT</code> es un &#8220;case object&#8221; presente en el paquete <code>scala.actors</code>). Ejemplo:</p>

<p>reactWithin(2000) { case Answer(text) =&gt; // process text case TIMEOUT =&gt; println(&#8220;no answer within 2 seconds&#8221;) }</p>
</li>

<li>
<p>El m√©todo <code>reactWithin</code> tambi√©n permite realizar accesos no bloqueantes al buz√≥n. Si especificamos un tiempo de espera de 0 milisegundos, primeramente el buz√≥n ser√° escaneado en busca de un mensaje que concuerde. En caso de que no exista ning√∫n mensaje concordante tras el primer escaneo, el patr√≥n <code>TIMEOUT</code> ser√° satisfecho. Por ejemplo, esto nos permite recibir determinado tipo de mensajes donde unos tienen una prioridad mayor que otros:</p>

<p>reactWithin(0) { case HighPriorityMsg =&gt; // &#8230; case TIMEOUT =&gt; react { case LowPriorityMsg =&gt; // &#8230; } }</p>

<p>En el ejemplo anterior, el actor procesa en primer lugar los mensajes <code>HighPriorityMsg</code> aunque exista un mensaje <code>LowPriorityMsg</code> m√°s antiguo en el buz√≥n. El actor s√≥lo procesar√° mensajes <code>LowPriorityMsg</code> en primer lugar en aquella situaci√≥n donde no exista ning√∫n <code>HighProrityMsg</code> en el buz√≥n.</p>
</li>
</ul>

<p>Adicionalmente, el tipo <code>ReplyActor</code> a√±ade el estado de ejecuci√≥n <code>Actor.State.TimedSuspended</code>. Un actor suspendido, esperando la recepci√≥n de un mensaje mediante el uso de <code>reactWithin</code> se encuentra en dicho estado.</p>

<h3 id='el_trait_actor'>El trait Actor</h3>

<p>El trait <code>Actor</code> extiende de <code>ReplyReactor</code> a√±adiendo y/o sobrescribiendo los siguientes miembros:</p>

<ul>
<li>
<p>El m√©todo (a√±adido) <code>receive</code> se comporta del mismo modo que <code>react</code>, con la excepci√≥n de que puede retornar un resultado. Este hecho se ve reflejado en la definici√≥n del tipo, que es polim√≥rfico en el tipo del resultado:</p>

<p>def receiveRartialFunction<span>Any, R</span>): R</p>

<p>Sin embargo, la utilizaci√≥n de <code>receive</code> hace que el uso del actor sea m√°s pesado, puesto que el hilo subyacente es bloqueado mientras el actor est√° esperando por la respuesta. El hilo bloqueado no est√° disponible para ejecutar otros actores hasta que la invocaci√≥n del m√©todo <code>receive</code> haya retornado.</p>
</li>

<li>
<p>El m√©todo (a√±adido) <code>link</code> permite a un actor enlazarse y desenlazarse de otro actor respectivamente. El proceso de enlazado puede utilizarse para monitorizar y responder a la terminaci√≥n de un actor. En particular, el proceso de enlazado afecta al comportamiento mostrado en la ejecuci√≥n del m√©todo <code>exit</code> tal y como se escribe en el la documentaci√≥n del API del trait <code>Actor</code>.</p>
</li>

<li>
<p>El atributo <code>trapExit</code> permite responder a la terminaci√≥n de un actor enlazado, independientemente de los motivos de su terminaci√≥n (es decir, carece de importancia si la terminaci√≥n del actor es normal o no). Si <code>trapExit</code> toma el valor cierto en un actor, este nunca terminar√° por culpa de los actores enlazados. En cambio, siempre y cuando uno de sus actores enlazados finalice, recibir√° un mensaje de tipo <code>Exit</code>. <code>Exit</code> es una &#8220;case class&#8221; que presenta dos atributos: <code>from</code> referenciando al actor que termina y <code>reason</code> conteniendo los motivos de la terminaci√≥n.</p>
</li>
</ul>

<h4 id='terminacin_y_estados_de_ejecucin'>Terminaci√≥n y estados de ejecuci√≥n</h4>

<p>Cuando la ejecuci√≥n de un actor finaliza, el motivo de dicha terminaci√≥n puede ser establecida de manera expl√≠cita mediante la invocaci√≥n de la siguiente variante del m√©todo <code>exit</code>:</p>

<pre><code>def exit(reason: AnyRef): Nothing</code></pre>

<p>Un actor cuyo estado de terminaci√≥n es diferente del s√≠mbolo <code>&#39;normal</code> propaga los motivos de su terminaci√≥n a todos aquellos actores que se encuentren enlazados a √©l. Si el motivo de la terminaci√≥n es una excepci√≥n no controlada, el motivo de finalizaci√≥n ser√° una instancia de la &#8220;case class&#8221; <code>UncaughtException</code>.</p>

<p>El trait <code>Actor</code> incluye dos nuevos estados de ejecuci√≥n. Un actor que se encuentra esperando la recepci√≥n de un mensaje mediante la utilizaci√≥n del m√©todo <code>receive</code> se encuentra en el m√©todo <code>Actor.State.Blocked</code>. Un actor esperado la recepci√≥n de un mensaje mediante la utilizaci√≥n del m√©todo <code>receiveWithin</code> se encuentra en el estado <code>Actor.State.TimeBlocked</code>.</p>

<h2 id='estructuras_de_control'>Estructuras de control</h2>

<p>El trait <code>Reactor</code> define una serie de estructuras de control que simplifican el mecanismo de programaci√≥n con la funci√≥n sin retorno <code>react</code>. Normalmente, una invocaci√≥n al m√©todo <code>react</code> no retorna nunca. Si el actor necesita ejecutar c√≥digo a continuaci√≥n de la invocaci√≥n anterior, tendr√° que pasar, de manera expl√≠cita, dicho c√≥digo al m√©todo <code>react</code> o utilizar algunas de las estructuras que encapsulan este comportamiento.</p>

<p>La estructura de control m√°s basica es <code>andThen</code>. Permite registrar una <code>closure</code> que ser√° ejecutada una vez el actor haya terminado la ejecuci√≥n de todo lo demas.</p>

<pre><code>actor {
  {
    react {
      case &quot;hello&quot; =&gt; // processing &quot;hello&quot;
    }: Unit
  } andThen {
    println(&quot;hi there&quot;)
  }
}</code></pre>

<p>Por ejemplo, el actor anterior imprime un saludo tras realizar el procesado del mensaje <code>hello</code>. Aunque la invocaci√≥n del m√©todo <code>react</code> no retorna, podemos utilizar <code>andThen</code> para registrar el c√≥digo encargado de imprimir el saludo a continuaci√≥n de la ejecuci√≥n del actor.</p>

<p>N√≥tese que existe una <em>atribuci√≥n de tipo</em> a continuaci√≥n de la invocaci√≥n de <code>react</code> (<code>:Unit</code>). B√°sicamente, nos permite tratar el resultado de <code>react</code> como si fuese de tipo <code>Unit</code>, lo cual es legal, puesto que el resultado de una expresi√≥n siempre se puede eliminar. Es necesario llevar a cabo esta operaci√≥n dado que <code>andThen</code> no puede ser un miembro del tipo <code>Unit</code>, que es el tipo del resultado retornado por <code>react</code>. Tratando el tipo de resultado retornado por <code>react</code> como <code>Unit</code> permite llevar a cabo la aplicaci√≥n de una conversi√≥n impl√≠cita la cual hace que el miembro <code>andThen</code> est√© disponible.</p>

<p>El API ofrece unas cuantas estructuras de control adicionales:</p>

<ul>
<li>
<p><code>loop { ... }</code>. Itera de manera indefinidia, ejecutando el c√≥digo entre las llaves en cada una de las iteraciones. La invocaci√≥n de <code>react</code> en el cuerpo del bucle provoca que el actor se comporte de manera habitual ante la llegada de un nuevo mensaje. Posteriormente a la recepci√≥n del mensaje, la ejecuci√≥n continua con la siguiente iteraci√≥n del bucle actual.</p>
</li>

<li>
<p><code>loopWhile (c) { ... }</code>. Ejecuta el c√≥digo entre las llaves mientras la condici√≥n <code>c</code> tome el valor <code>true</code>. La invocaci√≥n de <code>react</code> en el cuerpo del bucle ocasiona el mismo efecto que en el caso de <code>loop</code>.</p>
</li>

<li>
<p><code>continue</code>. Continua con la ejecuci√≥n de la closure actual. La invocaci√≥n de <code>continue</code> en el cuerpo de un <code>loop</code>o <code>loopWhile</code> ocasionar√° que el actor termine la iteraci√≥n en curso y continue con la siguiente. Si la iteraci√≥n en curso ha sido registrada utilizando <code>andThen</code>, la ejecuci√≥n continua con la segunda &#8220;closure&#8221; pasada como segundo argumento a <code>andThen</code>.</p>
</li>
</ul>

<p>Las estructuras de control pueden ser utilizadas en cualquier parte del cuerpo del m√©todo <code>act</code> y en los cuerpos de los m√©todos que, transitivamente, son llamados por <code>act</code>. Aquellos actores creados utilizando la sint√°xis <code>actor { ... }</code> pueden importar las estructuras de control desde el objeto <code>Actor</code>.</p>

<h4 id='futures'>Futures</h4>

<p>Los traits <code>RepyActor</code> y <code>Actor</code> soportan operaciones de env√≠o de mensajes (m√©todos <code>!!</code>) que, de manera inmediata, retornan un <em>future</em>. Un <em>future</em>, es una instancia del trait <code>Future</code> y act√∫a como un manejador que puede ser utilizado para recuperar la respuesta a un mensaje &#8220;send-with-future&#8221;.</p>

<p>El emisor de un mensaje &#8220;send-with-future&#8221; puede esperar por la respuesta del future <em>aplicando</em> dicha future. Por ejemplo, el env√≠o de un mensaje mediante <code>val fut = a !! msg</code> permite al emisor esperar por el resultado del future del siguiente modo: <code>val res = fut()</code>.</p>

<p>Adicionalmente, utilizando el m√©todo <code>isSet</code>, un <code>Future</code> puede ser consultado de manera no bloqueante para comprobar si el resultado est√° disponible.</p>

<p>Un mensaje &#8220;send-with-future&#8221; no es el √∫nico modo de obtener una referencia a un future. Estos pueden ser creados utilizando el m√©todo <code>future</code>. En el siguiente ejemplo, <code>body</code> se ejecuta de manera concurrente, retornando un future como resultado.</p>

<pre><code>val fut = future { body }
// ...
fut() // wait for future</code></pre>

<p>Lo que hace especial a los futures en el contexto de los actores es la posibilidad de recuperar su resultado utilizando las operaciones est√°ndar de actores de recepci√≥n de mensajes como <code>receive</code>, etc. Adem√°s, es posible utilizar las operaciones basadas en eventos <code>react</code>y <code>reactWithin</code>. Esto permite a un actor esperar por el resultado de un future sin la necesidad de bloquear el hilo subyacente.</p>

<p>Las operaciones de recepci√≥n basadas en actores est√°n disponibles a trav√©s del atributo <code>inputChannel</code> del future. Dado un future de tipo <code>Future[T]</code>, el tipo de <code>inputChannel</code> es <code>InputChannel[T]</code>. Por ejemplo:</p>

<pre><code>val fut = a !! msg
// ...
fut.inputChannel.react {
  case Response =&gt; // ...
}</code></pre>

<h2 id='canales'>Canales</h2>

<p>Los canales pueden ser utilizados para simplificar el manejo de mensajes que presentan tipos diferentes pero que son enviados al mismo actor. La jerarqu√≠a de canales se divide en <code>OutputChannel</code> e <code>InputChannel</code>.</p>

<p>Los <code>OutputChannel</code> pueden ser utilizados para enviar mensajes. Un <code>OutputChannel</code> <code>out</code> soporta las siguientes operaciones:</p>

<ul>
<li>
<p><code>out ! msg</code>. Env√≠a el mensaje <code>msg</code> a <code>out</code> de manera as√≠ncrona. Cuando <code>msg</code> es enviado directamente a un actor se incluye un referencia al actor emisor del mensaje.</p>
</li>

<li>
<p><code>out forward msg</code>. Reenv√≠a el mensaje <code>msg</code> a <code>out</code> de manera as√≠ncrona. El actor emisor se determina en el caso en el que <code>msg</code> es reenviado a un actor.</p>
</li>

<li>
<p><code>out.receiver</code>. Retorna el √∫nico actor que est√° recibiendo mensajes que est√°n siendo enviados al canal <code>out</code>.</p>
</li>

<li>
<p><code>out.send(msg, from)</code>. Env√≠a el mensaje <code>msg</code> a <code>out</code> de manera as√≠ncrona, proporcionando a <code>from</code> como el emisor del mensaje.</p>
</li>
</ul>

<p>N√≥tese que el trait <code>OutputChannel</code> tiene un par√°metro de tipo que especifica el tipo de los mensajes que pueden ser enviados al canal (utilizando <code>!</code>, <code>forward</code>, y <code>send</code>). Este par√°metro de tipo es contra-variante:</p>

<pre><code>trait OutputChannel[-Msg]</code></pre>

<p>Los actores pueden recibir mensajes de un <code>InputChannel</code>. Del mismo modo que <code>OutputChannel</code>, el trait <code>InputChannel</code> presenta un par√°metro de tipo que especifica el tipo de mensajes que pueden ser recibidos por el canal. En este caso, el par√°metro de tipo es covariante:</p>

<pre><code>trait InputChannel[+Msg]</code></pre>

<p>Un <code>InputChannel[Msg]</code> <code>in</code> soportal las siguientes operaciones.</p>

<ul>
<li>
<p><code>in.receive { case Pat1 =&gt; ... ; case Patn =&gt; ... }</code> (y de manera similar, <code>in.receiveWithin</code>) recibe un mensaje proveniente de <code>in</code>. La invocaci√≥n del m√©todo <code>receive</code> en un canal de entrada presenta la misma sem√°ntica que la operaci√≥n est√°ndar de actores <code>receive</code>. La √∫nica diferencia es que la funci√≥n parcial pasada como argumento tiene tipo <code>PartialFunction[Msg, R]</code> donde <code>R</code> es el tipo de retorno de <code>receive</code>.</p>
</li>

<li>
<p><code>in.react { case Pat1 =&gt; ... ; case Patn =&gt; ... }</code> (y de manera similar, <code>in.reactWithin</code>). Recibe un mensaje de <code>in</code> utilizando la operaci√≥n basada en eventos <code>react</code>. Del mismo modo que la operaci√≥n <code>react</code> en actores, el tipo de retorno es <code>Nothing</code>, indicando que las invocaciones de este m√©todo nunca retornan. Al igual que la operaci√≥n <code>receive</code> anterior, la funci√≥n parcial que se pasa como argumento presenta un tipo m√°s espec√≠fico:</p>

<p>PartialFunction<span>Msg, Unit</span></p>
</li>
</ul>

<h3 id='creando_y_compartiendo_canales'>Creando y compartiendo canales</h3>

<p>Los canales son creados utilizando la clase concreta <code>Channel</code>. Esta clase extiende de <code>InputChannel</code> y <code>OutputChannel</code>. Un canal pueden ser compartido haciendo dicho canal visible en el √°mbito de m√∫ltiples actores o envi√°ndolo como mensaje.</p>

<p>El siguiente ejemplo muestra la compartici√≥n mediante publicaci√≥n en √°mbitos:</p>

<pre><code>actor {
  var out: OutputChannel[String] = null
  val child = actor {
    react {
      case &quot;go&quot; =&gt; out ! &quot;hello&quot;
    }
  }
  val channel = new Channel[String]
  out = channel
  child ! &quot;go&quot;
  channel.receive {
    case msg =&gt; println(msg.length)
  }
}</code></pre>

<p>La ejecuci√≥n de este ejemplo imprime la cadena &#8220;5&#8221; en la consola. N√≥tese que el actor <code>child</code> √∫nicamente tiene acceso a <code>out</code>, que es un <code>OutputChannel[String]</code>. La referencia al canal, la cual puede ser utilizada para llevar a cabo la recepci√≥n de mensajes, se encuentra oculta. Sin embargo, se deben tomar precauciones y asegurarse que el canal de salida es inicializado con un canal concreto antes de que <code>child</code> le env√≠e ning√∫n mensaje. En el ejemplo que nos ocupa, esto es llevado a cabo mediante el mensaje &#8220;go&#8221;. Cuando se est√° recibiendo de <code>channel</code> utilizando el m√©todo <code>channel.receive</code> podemos hacer uso del hecho que <code>msg</code> es de tipo <code>String</code>, y por lo tanto tiene un miembro <code>length</code>.</p>

<p>Una alternativa a la compartici√≥n de canales es enviarlos a trav√©s de mensajes. El siguiente fragmento de c√≥digo muestra un sencillo ejemplo de aplicaci√≥n:</p>

<pre><code>case class ReplyTo(out: OutputChannel[String])

val child = actor {
  react {
    case ReplyTo(out) =&gt; out ! &quot;hello&quot;
  }
}

actor {
  val channel = new Channel[String]
  child ! ReplyTo(channel)
  channel.receive {
    case msg =&gt; println(msg.length)
  }
}</code></pre>

<p>La &#8220;case class&#8221; <code>ReplyTo</code> es un tipo de mensajes que utilizamos para distribuir una referencia a un <code>OutputChannel[String]</code>. Cuando el actor <code>child</code> recibe un mensaje de tipo <code>ReplyTo</code> √©ste env√≠a una cadena a su canal de salida. El segundo actor recibe en el canal del mismo modo que anteriormente.</p>

<h2 id='planificadores'>Planificadores</h2>

<p>Un <code>Reactor</code>(o una instancia de uno de sus subtipos) es ejecutado utilizando un <em>planificador</em>. El trait <code>Reactor</code> incluye el miembro <code>scheduler</code> el cual retorna el planificador utilizado para ejecutar sus instancias:</p>

<pre><code>def scheduler: IScheduler</code></pre>

<p>La plataforma de ejecuci√≥n ejecuta los actores enviando tareas al planificador mediante el uso de los m√©todos <code>execute</code> definidos en el trait <code>IScheduler</code>. La mayor parte del resto de m√©todos definidos en este trait √∫nicamente adquieren cierto protagonismo cuando se necesita implementar un nuevo planificador desde cero; algo que no es necesario en muchas ocasiones.</p>

<p>Los planificadores por defecto utilizados para ejecutar instancias de <code>Reactor</code> y <code>Actor</code> detectan cuando los actores han finalizado su ejecuci√≥n. En el momento que esto ocurre, el planificador se termina a si mismo (terminando con cualquier hilo que estuviera en uso por parte del planificador). Sin embargo, algunos planificadores como el <code>SingleThreadedScheduler</code> (definido en el paquete <code>scheduler</code>) necesita ser terminado de manera expl√≠cita mediante la invocaci√≥n de su m√©todo <code>shutdown</code>).</p>

<p>La manera m√°s sencilla de crear un planificador personalizado consisten en extender la clase <code>SchedulerAdapter</code>, implementando el siguiente m√©todo abstracto:</p>

<pre><code>def execute(fun: =&gt; Unit): Unit</code></pre>

<p>Por norma general, una implementaci√≥n concreata utilizar√≠a un pool de hilos para llevar a cabo la ejecuci√≥n del argumento por nombre <code>fun</code>.</p>

<h2 id='actores_remotos'>Actores remotos</h2>

<p>Esta secci√≥n describe el API de los actores remotos. Su principal interfaz es el objecto <a href='http://www.scala-lang.org/api/2.9.1/scala/actors/remote/RemoteActor$.html'><code>RemoteActor</code></a> definido en el paquete <code>scala.actors.remote</code>. Este objeto facilita el conjunto de m√©todos necesarios para crear y establecer conexiones a instancias de actores remotos. En los fragmentos de c√≥digo que se muestran a continuaci√≥n se asume que todos los miembros de <code>RemoteActor</code> han sido importados; la lista completa de importaciones utilizadas es la siguiente:</p>

<pre><code>import scala.actors._
import scala.actors.Actor._
import scala.actors.remote._
import scala.actors.remote.RemoteActor._</code></pre>

<h3 id='iniciando_actores_remotos'>Iniciando actores remotos</h3>

<p>Un actore remot es identificado de manera un√≠voca por un <a href='http://www.scala-lang.org/api/2.9.1/scala/Symbol.html'><code>Symbol</code></a>. Este s√≠mbolo es √∫nico para la instancia de la m√°quina virual en la que se est√° ejecutando un actor. Un actor remoto identificado con el nombre <code>myActor</code> puede ser creado del siguiente modo.</p>

<pre><code>class MyActor extends Actor {
  def act() {
    alive(9000)
    register(&#39;myActor, self)
    // ...
  }
}</code></pre>

<p>N√≥tese que el nombre √∫nicamente puede ser registrado con un √∫nico actor al mismo tiempo. Por ejemplo, para registrar el actor <em>A</em> como <code>&#39;myActor</code> y posteriormente registrar otro actor <em>B</em> como <code>&#39;myActor</code>, deber√≠a esperar hasta que <em>A</em> haya finalizado. Este requisito aplica a lo largo de todos los puertos, por lo que registrando a <em>B</em> en un puerto diferente no ser√≠a suficiente.</p>

<h3 id='connecting_to_remote_actors'>Connecting to remote actors</h3>

<p>Establecer la conexi√≥n con un actor remoto es un proceso simple. Para obtener una referencia remota a un actor remoto que est√° ejecut√°ndose en la m√°quina <code>myMachine</code> en el puerto 8000 con el nombre <code>&#39;anActor</code>, tendremos que utilizar <code>select</code>del siguiente modo:</p>

<pre><code>val myRemoteActor = select(Node(&quot;myMachine&quot;, 8000), &#39;anActor)</code></pre>

<p>El actor retornado por <code>select</code> es de tipo <code>AbstractActor</code>, que proporciona esencialmente el mismo interfaz que un actor normal, y por lo tanto es compatible con las habituales operaciones de env√≠o de mensajes:</p>

<pre><code>myRemoteActor ! &quot;Hello!&quot;
receive {
  case response =&gt; println(&quot;Response: &quot; + response)
}
myRemoteActor !? &quot;What is the meaning of life?&quot; match {
  case 42   =&gt; println(&quot;Success&quot;)
  case oops =&gt; println(&quot;Failed: &quot; + oops)
}
val future = myRemoteActor !! &quot;What is the last digit of PI?&quot;</code></pre>

<p>N√≥tese que la operaci√≥n <code>select</code> es perezosa; no inicializa ninguna conexi√≥n de red. Simplemente crea una nueva instancia de <code>AbstractActor</code> que est√° preparada para iniciar una nueva conexi√≥n de red en el momento en que sea necesario (por ejemplo cuando el m√©todo &#8217;!&#8217; es invocado).</p>
      
    </div>
    
    <div class="span6">
      <div id="scroller-anchor">
  <div id="scroller">
    <p class="contents">Contents</p>
    <div id="toc"></div>    
              
  </div>
</div>

    </div>
    
	
  </div>
</div>

<div class="footer">
	<div class="container">
		<ul>
			<li><h5>API</h5></li>
			<li><a href="http://www.scala-lang.org/api/current/">Current</a></li>
			<li><a href="http://www.scala-lang.org/archives/downloads/distrib/files/nightly/docs/library/index.html">Nightly</a></li>
		</ul>
		<ul>
			<li><h5>Learn</h5></li>
			<li><a href="/overviews">Guides & Overviews</a></li>
			<li><a href="/tutorials">Tutorials</a></li>
			<li><a href="/style">Scala Style Guide</a></li>				
		</ul>
		<ul>
			<li><h5>Quickref</h5></li>
			<li><a href="/glossary">Glossary</a></li>
			<li><a href="/cheatsheets">Cheatsheets</a></li>
		</ul>
		<ul>
			<li><h5>Contribute</h5></li>
			<li><a href="http://github.com/scala/scala.github.com">Source Code</a></li>
			<li><a href="/contribute.html">Contributors Guide</a></li>
			<li><a href="http://getsatisfaction.com/scaladocs">Suggestions</a></li>			
		</ul>
		<ul>
			<li><h5>Other Resources</h5></li>
			<li><a href="http://wiki.scala-lang.org">Wiki</a></li>
			<li><a href="/sips">Scala Improvement Process</a></li>				
		</ul>						
	</div>
	<div class="container copyright">
 		<p>
			Copyright &copy; 2011-2013 EPFL. All rights reserved.
			<a href="https://github.com/scala/scala.github.com/commits/gh-pages.atom"><img align="right" height="20px" width="20px" src="/resources/images/rss.png" alt="RSS feed of updates to the github repo hosting this site"></a>
		</p>		
	</div>
</div>


<script type="text/javascript">
  $('#toc').toc({exclude: 'h1, h5, h6', context: '', autoId: true, numerate: false});
</script>

<script type="text/javascript">
  $(function() {
    moveScroller();
  });
</script>

  </body>
</html>

    
