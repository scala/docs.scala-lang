---
layout: singlepage-overview
title: Огляд TASTy
language: uk
scala3: true
---
Створіть файл вихідного коду Scala 3 _Hello.scala_:

```scala
@main def hello = println("Hello, world")
```

і скомпілюйте файл з `scalac`:

```bash
$ scalac Hello.scala
```

ви помітите, що серед інших отриманих файлів, `scalac` створює файли з розширенням _.tasty_:

```bash
$ ls -1
Hello$package$.class
Hello$package.class
Hello$package.tasty
Hello.scala
hello.class
hello.tasty
```

Виникає питання: «Що таке tasty?»



## Що таке TASTy?

TASTy це акронім терміну, _Абстрактне синтаксичне дерево типів (Typed Abstract Syntax Trees)_.
Це високорівневий формат для Scala 3, і в цьому документі ми називатимемо його як _Tasty_.

Перше, що важливо знати, це те, що файли Tasty генеруються компілятором `scalac`,
та містять _всю_ інформацію про ваш вихідний код, включаючи синтаксичну структуру вашої програми,
і _повну_ інформацію про типи, позицію та навіть документацію.
Файли Tasty містять набагато більше інформації, ніж файли _.class_, які створюються для роботи на JVM. (Детальніше далі.)

У Scala 3 процес компіляції виглядає так:

```text
         +-------------+    +-------------+    +-------------+
$ scalac | Hello.scala | -> | Hello.tasty | -> | Hello.class |
         +-------------+    +-------------+    +-------------+
                ^                  ^                  ^
                |                  |                  |
           Ваш вихідний        Файл TASTy        Файл класу
               код             для scalac          для JVM
                            (містить повну       (неповна
                               інформацію)        інформація)
```

Ви можете переглянути вміст файлу _.tasty_ у зрозумілій формі, запустивши на ньому компілятор із прапорцем `-print-tasty`.
Ви також можете переглянути вміст, декомпільований у формі, подібній до вихідного коду Scala, використовуючи прапор `-decompile`.
```bash
$ scalac -print-tasty hello.tasty
$ scalac -decompile hello.tasty
```

### Проблеми з файлами _.class_

Через проблему [стирання типів][erasure], файли _.class_ містять неповне представлення про ваш код.
Простий спосіб продемонструвати це приклад з `List`.

_Стирання типів_ означає, що коли ви пишете наступний код Scala:

```scala
val xs: List[Int] = List(1, 2, 3)
```

цей код компілюється у файл _.class_, який має бути сумісним із JVM. Результатом цієї вимоги сумісності код всередині цього файлу класу — який ви можете побачити за допомогою команди `javap` — виглядає так:

```java
public scala.collection.immutable.List<java.lang.Object> xs();
```

Результат команди `javap` показує Java-уявлення того, що міститься у файлі класу. Зверніть увагу, що `xs` більше _не_ визначений як `List[Int]`; він по суті представлений як `List[java.lang.Object]`. Щоб ваш код Scala працював із JVM, тип `Int` має бути стертим.

Далі, коли ви отримуєте елемент вашого `List[Int]` у вашому Scala коді, наприклад:

```scala
val x = xs(0)
```

отриманий файл класу матиме операцію перетворення для цього рядка коду, яку ви можете уявити так:

```
int x = (Int) xs.get(0)               // Java-подібно
val x = xs.get(0).asInstanceOf[Int]   // більш Scala-подібно
```

Знову ж таки, це зроблено для сумісності, щоб ваш код Scala міг працювати на JVM.
Однак, інформація про те, що ми вже мали список цілих чисел, втрачається у файлах класу.
Це створює проблеми під час спроби збірки Scala програми з уже скомпільованою бібліотекою.
Для цього нам потрібно більше інформації, ніж зазвичай міститься у файлах класу.

Ця дискусія охоплює лише тему стирання типу.
Існують подібні проблеми для кожної іншої конструкції Scala, про які JVM не знає, включно з об'єднанням, перетином, трейтами з параметрами та багатьма іншими відмінностями Scala 3.

### На допомогу приходить TASTy
Таким чином, на відміну від відсутньої інформації про вихідні типи у _.class_ файлах або тільки публічного API (як у «Pickle» форматі Scala 2.13), формат TASTy зберігає повне абстрактне синтаксичне дерево (AST) після перевірки типів.
Зберігання всього AST має багато переваг: воно дає можливість окремої компіляції, перекомпіляції для іншої версії JVM, статичного аналізу програм і багато іншого.

### Ключові моменти

Отже, це перший висновок з цього розділу: типи, які ви вказуєте у своєму коді Scala, не зовсім точно представлені у файлах _.class_.

Другим ключовим моментом є розуміння того, що існують відмінності між інформацією, яка доступна під час _компіляції_ та _виконання_:

- Під **час компіляції**, `scalac` читає та аналізує ваш код, він знає, що `xs` є `List[Int]`
- Коли компілятор записує ваш код у файл класу, він записує `xs` як `List[Object]`, та додає інформацію про перетворення усюди, де йде звернення до `xs`
- Потім під **час виконання** — коли ваш код працює в JVM — JVM не знає, що ваш список є `List[Int]`

Зі Scala 3 та Tasty, є ще одна важлива примітка про час компіляції:

- Коли ви пишете код на Scala 3, що використовує інші Scala 3 бібліотеки, `scalac` більше не має читати їх _.class_ файли; 
  він може прочитати їх _.tasty_ файли, які, як згадувалось, є _точним_ представленням вашого коду.
  Це важливо для забезпечення окремої компіляції та сумісності між Scala 2.13 і Scala 3.


## Переваги Tasty

Як ви можете зрозуміти, доступ до повного представлення вашого коду має [багато переваг][benefits]:

- Компілятор використовує його для підтримки окремої компіляції.
- Сервер мови, що базується на _Мовному серверному протоколі (Language Server Protocol)_ використовує його для підтримки гіперпосилань, завершення команд, документації, та таких глобальних операцій як, пошук звернень та перейменування.
- Tasty створює чудову основу для нового покоління [макросів основаних на рефлексії][macros].
- Оптимізатори та аналізатори можуть використовувати його для глибокого аналізу коду та розширеної генерації коду.

У відповідній примітці, Scala 2.13.6 має програму для читання TASTy, а компілятор Scala 3 також може читати формат 2.13 «Pickle».
У [сторінці з classpath сумісності][compatibility-ref] посібнику з міграції на Scala 3 пояснюється перевага можливості крос-компіляції.



## Більше інформації

Підсумовуючи, Tasty — це високорівневий формат обміну для Scala 3, а файли _.tasty_ містять повне представлення вашого вихідного коду, що надає до переваги, описані у попередніх розділах.
Щоб дізнатися більше, перегляньте ці ресурси:

- У [цьому відео](https://www.youtube.com/watch?v=YQmVrUdx8TU), Jamie Thompson зі Scala Center детально розповідає про те, як працює Tasty, та його переваги
- Статті з [Бінарної сумісності для авторів бібліотек][binary] розглядаються теми бінарної сумісності, сумісності джерел та модель виконання JVM
- [Подальша сумісність для Scala 3](https://www.scala-lang.org/blog/2020/11/19/scala-3-forward-compat.html) демонструє методи використання Scala 2.13 і Scala 3 в одному проєкті

Ці статті містять додаткову інформацію про макроси Scala 3:

- [Бібліотеки макросів Scala](https://scalacenter.github.io/scala-3-migration-guide/docs/macros/macro-libraries.html)
- [Макроси: плани для Scala 3](https://www.scala-lang.org/blog/2018/04/30/in-a-nutshell.html)
- [Довідник по рефлексії цитат (Quotes Reflect)][quotes-reflect]
- [Довідник по макросах](/scala3/guides/macros)

[benefits]: https://www.scala-lang.org/blog/2018/04/30/in-a-nutshell.html
[erasure]: https://www.scala-lang.org/files/archive/spec/2.13/03-types.html#type-erasure
[binary]: {% link _overviews/tutorials/binary-compatibility-for-library-authors.md %}
[compatibility-ref]: {% link _overviews/scala3-migration/compatibility-classpath.md %}
[quotes-reflect]: {{ site.scala3ref }}/metaprogramming/reflection.html
[macros]: {{ site.scala3ref }}/metaprogramming/macros.html
