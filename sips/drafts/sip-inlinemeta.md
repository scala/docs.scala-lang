---
layout: sip
title: Inline Definitions and Meta Expressions
---

__Eugene Burmako__
__SÃ©bastien Doeraene__
__Vojin Jovanovic__
__Martin Odersky__
__Dmitry Petrashko__
__Denys Shabalin__

__May 2016__

# SIP NN: Inline Definitions and Meta Expressions (Public Draft)

## Motivation ##

## Inline Modifiers

We introduce a new reserved word: `inline`. `inline` can be used as a modifier for:

 - concrete value definitions, e.g.

        inline val x = 4

 - concrete methods, e.g.

        inline def square(x: Double) = x * x

 - parameters of inline methods, e.g.

        inline def pow(b: Double, inline n: Int): Double = {
          if (n == 0) 1
          else pow(b, n - 1)
        }

The previous rule of regarding a `final val` with no explicit type as
a compile-time constant (inherited from Java) is dropped. Instead we
write such `val`s now as `inline`.

Value and method definitions labeled `inline` are effectively final;
they cannot be overridden.  Inline members also never override other
members. Instead, every inline member becomes an overloaded alternative
of all other members with the same name. Normal overloading resolution
is applied to pick an inline member over some other member.

If an inline definition doesn't explicitly specify its result type,
the result type gets inferred according to the usual rules.

Inline definitions only exist at compile time; no storage is allocated for them in object layout
and no code is generated for them in object method tables.
That means that it is OK to have an inline member that
has the same type erasure as some other member with the same name.

## Inline Reductions

The compiler will do the following rewritings when encountering certain patterns of code
outside the bodies of inline methods.
When these patterns of code appear inside inline methods,
they will be ignored by the inliner and processed by the compiler as usual.

1. If `prefix.v` refers to an inline value, replace the expression with the value of `v`.

2. If `prefix.f[Ts](args1)...(argsN)` refers to a fully applied inline
method, hoist the prefix and the arguments into temporary variables
and then replace the expression with the method's right-hand side,
where parameter references are replaced by references to temporary variables
created for the corresponding arguments and enclosing `this` and self references
are replaced by references to the temporary variable created for the prefix.

        val x$prefix = prefix
        val x$1 = arg1
        ...
        val x$M = argM
        <f's body with parameter and this/self references replaced with x$'s>

   This hoisting is intended to preserve the semantics
of method applications under inlining. A method call should have the same
semantics with respect to side effects independently on whether the method was made `inline` or not.
If an inline method has by-name parameters, then corresponding arguments are not hoisted.

   The rewriting is done in accordance with hygiene. Any references from the method
body to its environment will be kept in the rewritten code. If the result of the rewriting
references private/protected definitions in the class that defines the inline method,
these references will be changed to use accessors generated automatically by the compiler.
To ensure that the rewriting works in the separate compilation setting, it is critical
for the compiler to generate the accessors in advance. Most of these accessors can be
pre-generated by analyzing the bodies of inline methods, except for members
that are referred to inside meta scopes. We don't have a good solution for the latter case,
so we will probably disallow such references.

   The rewriting is done in the "outside in" style, i.e. calls to inline methods
are expanded before possible calls to inline methods in their prefixes and arguments.
This is different from how the "inside out" style of macro expansion in Scala 2.10+,
where prefixes and arguments are expanded first. The old style of macro expansion
can, if necessary, be emulated by the new style of inline rewritings.

    The rewriting also verifies that arguments passed to inline parameters are literals.
It is an error if that does not hold. However, specification of rules for constant folding
is outside the scope of this proposal. We believe that, with additional effort, inline methods and
inline parameters can be used to express partial evaluation of methods like `pow` in the introduction,
but for now we rely on implementation-specific constant folding to take care of things like arithmetic
operation on constants, conditional expressions with constant conditions and so on.

3. If `prefix.f[Ts](args1)...(argsN)` refers to a partially applied inline
method, an error is raised. Eta expansion of inline methods is prohibited.

## Meta Expressions

A meta expression is an expression of the form

    meta { ... }

where `{ ... }` is some block of Scala code, called meta scope.
(In fact, `meta` may prefix arbitrary expressions, but blocks are expected to be used most commonly).

Meta expressions can appear both in the bodies of inline methods
(then their expansion is going to be deferred until these methods expand) and in normal code
(in that case, expansion will take place immediately at the place where the meta expression is written).

In a meta expression, `meta` is not a keyword, but a reference to a magic method
declared in the `scala.meta` metaprogramming library:

    package object meta {
      def apply[Result](body: implicit scala.meta.semantic.Context => Any): Result = ???
    }

The `scala.meta.semantic.Context` implicit value defines the reflection API available inside meta scopes.
Full description of the functionality exposed by `scala.meta` is outside of the scope of this proposal.

Meta expressions can be used with their type arguments omitted, in which case the type argument
is inferred from the expected type. For example, in `inline def async[T](x: T): T = meta { ...; q"..." }`, inference
results in `Result = T`. If a meta expression requires such kind of type inference,
then it is not allowed to use it in the context where an expected type is unspecified,
e.g. omitting the return type `T` of the inline method in the example above is prohibited. In that case,
one could write `inline def async[T](x: T) = meta { ...; q"..." }: T`, making the code valid again.

Meta scopes can only reference the following names in their environment,
with the types of the names undergoing the following transformations:

| Definition                                | Type |
|-------------------------------------------|------|
| Inline value                       | Unchanged |
| Inline method                      | Types of inline params unchanged,<br/>types of non-inline parameters</br> and return type changed to `scala.meta.Term` |
| Inline parameter                   | Unchanged  |
| Type parameter of an inline method | `scala.meta.Type` |
| Term parameter of an inline method | `scala.meta.Term` |
| Enclosing this and self references | `scala.meta.Term` |
| Global                             | Unchanged |

In other words, definitions that are statically available outside meta scopes remain available in meta scopes,
term and type arguments of inline methods become available as their representations,
while signatures of inline methods are recursively transformed according to the rules above.

As a consequence of how inline reductions work, by-value term parameters of enclosing inline methods
will be passed to macro scopes as trees representing references to temporary variables generated to
respect by-value semantics. In order for a macro scope to get access to representations of
actual arguments of an enclosing inline method, corresponding parameters need to be declared as by-name,
e.g. `inline def async[T](x: => T): T = meta { ... }`. A representation of a `this` or self reference always
follows the by-value scheme, and in order to obtain an actual prefix of an enclosing inline application,
one should use the functionality of `scala.meta.semantic.Context`.

Meta scopes can return anything that is convertible to `scala.meta.Term` by the means
of the `scala.meta.Lift` type class. There are standard instances of the type class that lift simple values
to literals as well as ones that support frequently used collections of liftable values.
Metaprogrammers may define and use their own instances as long as they are available in corresponding meta scopes.

## Meta Expansion

During typechecking, the compiler treats meta expressions, i.e. invocations of the `meta` method,
as normal method calls, typechecking the arguments of those calls (i.e. meta scopes), and
performing type inference if necessary, but nothing else.
In this proposal, meta expansion works differently from macro expansion in Scala 2.10+,
where macro applications are expanded immediately after being processed by the typechecker.

An important consequence is that meta expressions cannot refine their types during expansion.
This makes it impossible to use the proposed metaprogramming system to implement
[whitebox macros](http://docs.scala-lang.org/overviews/macros/blackbox-whitebox.html) from Scala 2.10+.
Alternative ways of enabling the most important whitebox functionality are outside the scope of this proposal.

At an implementation-defined point in the compilation pipeline,
the compiler expands meta expressions outside the bodies of inline methods.
When meta expressions appear inside inline methods,
they will be ignored by the meta expander and processed by the compiler as usual.

A meta expression is expanded by evaluating its body and replacing the original meta expression
with an expression that represents the result of the evaluation.
The implementation is responsible for instantiating a `scala.meta.semantic.Context` necessary for meta scopes
to evaluate and for converting between its internal representation for program elements and representations
defined in `scala.meta`, such as `scala.meta.Term` and `scala.meta.Type`.