
<!DOCTYPE html>
<html>
  <head>

    <title>The Architecture of Scala Collections - Scala Documentation</title>
    
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>

    <link rel="icon" type="image/png" href="/resources/favicon.ico">

    <!-- prettify js and CSS -->
    <link rel="stylesheet" href="/resources/stylesheets/prettify.css" type="text/css" />
    <script src="/resources/javascript/prettify/prettify.js" type="text/javascript" ></script>


    <!-- jquery js -->
    <script src="/resources/javascript/jquery.js" type="text/javascript" ></script>
    <script src="/resources/javascript/effects.core.js" type="text/javascript" ></script>
    <script src="/resources/javascript/effects.highlight.js" type="text/javascript" ></script>
    <script src="/resources/javascript/moveScroller.js" type="text/javascript" ></script>

    <!-- Bootstrap JS and CSS -->
    <link rel="stylesheet" href="/resources/stylesheets/bootstrap.css" type="text/css" />
	  <script src="/resources/javascript/bootstrap-dropdown.js" type="text/javascript" ></script>
	  <script src="/resources/javascript/bootstrap-dropdown-app.js" type="text/javascript" ></script>

    <!-- Base stylesheet for all pages -->
    <link rel="stylesheet" href="/resources/stylesheets/base.css" type="text/css" />

    <!-- table of contents js -->
    <script src="/resources/javascript/toc.js" type="text/javascript" ></script>

    <!-- google analytics -->
	<script type="text/javascript">

	  var _gaq = _gaq || [];
	  _gaq.push(['_setAccount', 'UA-574683-5']);
	  _gaq.push(['_trackPageview']);

	  (function() {
	    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
	    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
	    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
	  })();

	</script>

    <!-- prettyprint js to prepend generated pre/code tags -->
    <script type="text/javascript">
      function styleCode()
        {
          if (typeof disableStyleCode != "undefined")
          {
              return;
          }
          var a = false;
          $("pre code").parent().each(function()
          {
              if (!$(this).hasClass("prettyprint"))
              {
                  $(this).addClass("prettyprint lang-scala linenums");
                  a = true
              }
          });
          if (a) { prettyPrint() }
      }
    </script>

    <script type="text/javascript">
      jQuery(document).ready(function($) {

            $(".scroll").click(function(event){
              event.preventDefault();
              $('html,body').animate({scrollTop:$(this.hash).offset().top}, 500);
              $('html,body').animate({scrollTop:$(this.hash).offset().top-=50}, 500);
              $(this.hash).effect("highlight", {color: "#FFCC85"}, 3000);
            });
      });
    </script>

    <script type="text/javascript">
      $(window).ready(function goToSubsection() {
          if (window.location.hash)
          {
              $('html,body').animate({scrollTop:$(window.location.hash).offset().top}, 500);
              $('html,body').animate({scrollTop:$(window.location.hash).offset().top-=50}, 500);
              $(window.location.hash).effect("highlight", {color: "#FFCC85"}, 3000);
          }
        });
    </script>

    <style type="text/css">

       p.contents {
           margin-left: 15px;
           font-weight: bold;
           font-size: 16px;
       }

       div#toc ul {
           list-style: none;
       }

       div#toc ul a {
           display: block;
           list-style: none;
           line-height: 22px;
           font-weight: bold;
           width: 100%;
       }

      div#toc ul li ul {
           list-style: disc;
      }

      div#toc ul li ul a {
           line-height: 18px;
           font-weight: normal;
      }

      div#toc ul li ul li ul {
           list-style: square;
      }
       div#toc ul li ul li ul a {
       }

       div#scroller-anchor {
           width: inherit;
       }

       div#scroller {
           width: inherit;
       }

       div#guide-title {
        text-transform: capitalize;
        font-size: 16px;
        padding-bottom: 6px;
        color: #BFBFBF;
        text-transform: uppercase;
        font-weight: bold;
       }

       input, textarea, select, .uneditable-input {
	       width: 165px;
	     }

    </style>

</head>
  <body onload="styleCode()">

    <!-- Topbar
    ================================================== -->
<div class="topbar">
    <div class="topbar-inner">
        <div class="container">
            <a class="brand" href="/index.html"><img src="/resources/images/scala-logo.png"> Documentation</a>
            <ul class="nav">

                <li class="menu">
                      <a href="#" class="menu">API</a>
                      <ul class="menu-dropdown">
                        <li><a href="http://www.scala-lang.org/api/current/">Current</a></li>
                        <li><a href="http://www.scala-lang.org/archives/downloads/distrib/files/nightly/docs/library/index.html">Nightly</a></li>
                        <!--<li class="divider"></li>
                        <li><a href="#">Previous Versions</a></li>
                        -->
                      </ul>
                </li>

                <li class="menu">
                      <a href="#" class="menu">Learn</a>
                      <ul class="menu-dropdown">
                        <li><a href="/overviews">Guides & Overviews</a></li>
                        <li><a href="/tutorials">Tutorials</a></li>
                        <li><a href="/style">Scala Style Guide</a></li>
                      </ul>
                </li>

                <li class="menu">
                      <a href="#" class="menu">Quickref</a>
                      <ul class="menu-dropdown">
                        <li><a href="/glossary">Glossary</a></li>
                        <li><a href="/cheatsheets">Cheatsheets</a></li>
                      </ul>
                </li>

                <li><a href="/contribute.html">Contribute</a></li>
                <li><a href="/sips">SIPs</a></li>
                <li><a href="http://wiki.scala-lang.org">Wiki</a></li>
          </ul>
          <form method="get" id="searchform" action="/search.html">
            <input type="text" placeholder="Search"  class="field" name="q" id="q"/>
          </form>
           </li>
          </ul>
        </div>
    </div>
</div>

<div class="container">
  <div class="row">
    
    <div class="span10"><h1>The Architecture of Scala Collections</h1></div>

    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    

    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    

    
      
    

    <div class="span6">
      
    </div>

    <div class="span10">
      <p><strong>Martin Odersky and Lex Spoon</strong></p>

<p>These pages describe the architecture of the Scala collections framework in detail. Compared to <a href='/overviews/collections/introduction.html'>the Scala 2.8 Collections API</a> you will find out more about the internal workings of the framework. You will also learn how this architecture helps you define your own collections in a few lines of code, while reusing the overwhelming part of collection functionality from the framework.</p>

<p><a href='/overviews/collections/introduction.html'>The Scala 2.8 Collections API</a> contains a large number of collection operations, which exist uniformly on many different collection implementations. Implementing every collection operation anew for every collection type would lead to an enormous amount of code, most of which would be copied from somewhere else. Such code duplication could lead to inconsistencies over time, when an operation is added or modified in one part of the collection library but not in others. The principal design objective of the new collections framework was to avoid any duplication, defining every operation in as few places as possible. (Ideally, everything should be defined in one place only, but there are a few exceptions where things needed to be redefined.) The design approach was to implement most operations in collection &#8220;templates&#8221; that can be flexibly inherited from individual base classes and implementations. The following pages explain these templates and other classes and traits that constitute the &#8220;building blocks&#8221; of the framework, as well as the construction principles they support.</p>

<h2 id='builders'>Builders</h2>

<p>An outline of the <code>Builder</code> class:</p>

<pre><code>package scala.collection.mutable

class Builder[-Elem, +To] {
  def +=(elem: Elem): this.type
  def result(): To
  def clear(): Unit
  def mapResult[NewTo](f: To =&gt; NewTo): Builder[Elem, NewTo] = ...
}</code></pre>

<p>Almost all collection operations are implemented in terms of <em>traversals</em> and <em>builders</em>. Traversals are handled by <code>Traversable</code>&#8217;s <code>foreach</code> method, and building new collections is handled by instances of class <code>Builder</code>. The listing above presents a slightly abbreviated outline of this class.</p>

<p>You can add an element <code>x</code> to a builder <code>b</code> with <code>b += x</code>. There&#8217;s also syntax to add more than one element at once, for instance <code>b += (x, y)</code>, and <code>b ++= xs</code> work as for buffers (in fact, buffers are an enriched version of builders). The <code>result()</code> method returns a collection from a builder. The state of the builder is undefined after taking its result, but it can be reset into a new empty state using <code>clear()</code>. Builders are generic in both the element type, <code>Elem</code>, and in the type, <code>To</code>, of collections they return.</p>

<p>Often, a builder can refer to some other builder for assembling the elements of a collection, but then would like to transform the result of the other builder, for example to give it a different type. This task is simplified by method <code>mapResult</code> in class <code>Builder</code>. Suppose for instance you have an array buffer <code>buf</code>. Array buffers are builders for themselves, so taking the <code>result()</code> of an array buffer will return the same buffer. If you want to use this buffer to produce a builder that builds arrays, you can use <code>mapResult</code> like this:</p>

<pre><code>scala&gt; val buf = new ArrayBuffer[Int]
buf: scala.collection.mutable.ArrayBuffer[Int] = ArrayBuffer()

scala&gt; val bldr = buf mapResult (_.toArray)
bldr: scala.collection.mutable.Builder[Int,Array[Int]]
  = ArrayBuffer()</code></pre>

<p>The result value, <code>bldr</code>, is a builder that uses the array buffer, <code>buf</code>, to collect elements. When a result is demanded from <code>bldr</code>, the result of <code>buf</code> is computed, which yields the array buffer <code>buf</code> itself. This array buffer is then mapped with <code>_.toArray</code> to an array. So the end result is that <code>bldr</code> is a builder for arrays.</p>

<h2 id='factoring_out_common_operations'>Factoring out common operations</h2>

<h3 id='outline_of_class_traversablelike'>Outline of class TraversableLike</h3>

<pre><code>package scala.collection

class TraversableLike[+Elem, +Repr] {
  def newBuilder: Builder[Elem, Repr] // deferred
  def foreach[U](f: Elem =&gt; U)        // deferred
          ...
  def filter(p: Elem =&gt; Boolean): Repr = {
    val b = newBuilder
    foreach { elem =&gt; if (p(elem)) b += elem }
    b.result
  } 
}</code></pre>

<p>The main design objectives of the collection library redesign were to have, at the same time, natural types and maximal sharing of implementation code. In particular, Scala&#8217;s collections follow the &#8220;same-result-type&#8221; principle: wherever possible, a transformation method on a collection will yield a collection of the same type. For instance, the <code>filter</code> operation should yield, on every collection type, an instance of the same collection type. Applying <code>filter</code> on a <code>List</code> should give a <code>List</code>; applying it on a <code>Map</code> should give a <code>Map</code>, and so on. In the rest of this section, you will find out how this is achieved.</p>

<p>The Scala collection library avoids code duplication and achieves the &#8220;same-result-type&#8221; principle by using generic builders and traversals over collections in so-called <em>implementation traits</em>. These traits are named with a <code>Like</code> suffix; for instance, <code>IndexedSeqLike</code> is the implementation trait for <code>IndexedSeq</code>, and similarly, <code>TraversableLike</code> is the implementation trait for <code>Traversable</code>. Collection classes such as <code>Traversable</code> or <code>IndexedSeq</code> inherit all their concrete method implementations from these traits. Implementation traits have two type parameters instead of one for normal collections. They parameterize not only over the collection&#8217;s element type, but also over the collection&#8217;s <em>representation type</em>, i.e., the type of the underlying collection, such as <code>Seq[I]</code> or <code>List[T]</code>. For instance, here is the header of trait <code>TraversableLike</code>:</p>

<pre><code>trait TraversableLike[+Elem, +Repr] { ... }</code></pre>

<p>The type parameter, <code>Elem</code>, stands for the element type of the traversable whereas the type parameter <code>Repr</code> stands for its representation. There are no constraints on <code>Repr</code>. In particular <code>Repr</code> might be instantiated to a type that is itself not a subtype of <code>Traversable</code>. That way, classes outside the collections hierarchy such as <code>String</code> and <code>Array</code> can still make use of all operations defined in a collection implementation trait.</p>

<p>Taking <code>filter</code> as an example, this operation is defined once for all collection classes in the trait <code>TraversableLike</code>. An outline of the relevant code is shown in the above <a href='#outline_of_class_traversablelike'>outline of class <code>TraversableLike</code></a>. The trait declares two abstract methods, <code>newBuilder</code> and <code>foreach</code>, which are implemented in concrete collection classes. The <code>filter</code> operation is implemented in the same way for all collections using these methods. It first constructs a new builder for the representation type <code>Repr</code>, using <code>newBuilder</code>. It then traverses all elements of the current collection, using <code>foreach</code>. If an element <code>x</code> satisfies the given predicate <code>p</code> (i.e., <code>p(x)</code> is <code>true</code>), it is added with the builder. Finally, the elements collected in the builder are returned as an instance of the <code>Repr</code> collection type by calling the builder&#8217;s <code>result</code> method.</p>

<p>A bit more complicated is the <code>map</code> operation on collections. For instance, if <code>f</code> is a function from <code>String</code> to <code>Int</code>, and <code>xs</code> is a <code>List[String]</code>, then <code>xs map f</code> should give a <code>List[Int]</code>. Likewise, if <code>ys</code> is an <code>Array[String]</code>, then <code>ys map f</code> should give an <code>Array[Int]</code>. The problem is how to achieve that without duplicating the definition of the <code>map</code> method in lists and arrays. The <code>newBuilder</code>/<code>foreach</code> framework shown in <a href='#outline_of_class_traversablelike'>class <code>TraversableLike</code></a> is not sufficient for this because it only allows creation of new instances of the same collection <em>type</em> whereas <code>map</code> needs an instance of the same collection <em>type constructor</em>, but possibly with a different element type.</p>

<p>What&#8217;s more, even the result type constructor of a function like <code>map</code> might depend in non-trivial ways on the other argument types. Here is an example:</p>

<pre><code>scala&gt; import collection.immutable.BitSet
import collection.immutable.BitSet

scala&gt; val bits = BitSet(1, 2, 3)
bits: scala.collection.immutable.BitSet = BitSet(1, 2, 3)

scala&gt; bits map (_ * 2)
res13: scala.collection.immutable.BitSet = BitSet(2, 4, 6)

scala&gt; bits map (_.toFloat)
res14: scala.collection.immutable.Set[Float]
  = Set(1.0, 2.0, 3.0)</code></pre>

<p>If you <code>map</code> the doubling function <code>_ * 2</code> over a bit set you obtain another bit set. However, if you map the function <code>(_.toFloat)</code> over the same bit set, the result is a general <code>Set[Float]</code>. Of course, it can&#8217;t be a bit set because bit sets contain <code>Int</code>s, not <code>Float</code>s.</p>

<p>Note that <code>map</code>&#8217;s result type depends on the type of function that&#8217;s passed to it. If the result type of that function argument is again an <code>Int</code>, the result of <code>map</code> is a <code>BitSet</code>, but if the result type of the function argument is something else, the result of <code>map</code> is just a <code>Set</code>. You&#8217;ll find out soon how this type-flexibility is achieved in Scala.</p>

<p>The problem with <code>BitSet</code> is not an isolated case. Here are two more interactions with the interpreter that both map a function over a map:</p>

<pre><code>scala&gt; Map(&quot;a&quot; -&gt; 1, &quot;b&quot; -&gt; 2) map { case (x, y) =&gt; (y, x) }
res3: scala.collection.immutable.Map[Int,java.lang.String] 
  = Map(1 -&gt; a, 2 -&gt; b)

scala&gt; Map(&quot;a&quot; -&gt; 1, &quot;b&quot; -&gt; 2) map { case (x, y) =&gt; y }
res4: scala.collection.immutable.Iterable[Int] 
  = List(1, 2)</code></pre>

<p>The first function swaps two arguments of a key/value pair. The result of mapping this function is again a map, but now going in the other direction. In fact, the first expression yields the inverse of the original map, provided it is invertible. The second function, however, maps the key/value pair to an integer, namely its value component. In that case, we cannot form a <code>Map</code> from the results, but we still can form an <code>Iterable</code>, a supertrait of <code>Map</code>.</p>

<p>You might ask, why not restrict <code>map</code> so that it can always return the same kind of collection? For instance, on bit sets <code>map</code> could accept only <code>Int</code>-to-<code>Int</code> functions and on maps it could only accept pair-to-pair functions. Not only are such restrictions undesirable from an object-oriented modelling point of view, they are illegal because they would violate the Liskov substitution principle: A <code>Map</code> <em>is</em> an <code>Iterable</code>. So every operation that&#8217;s legal on an <code>Iterable</code> must also be legal on a <code>Map</code>.</p>

<p>Scala solves this problem instead with overloading: not the simple form of overloading inherited by Java (that would not be flexible enough), but the more systematic form of overloading that&#8217;s provided by implicit parameters.</p>

<p>Implementation of <code>map</code> in <code>TraversableLike</code>:</p>

<pre><code>def map[B, That](p: Elem =&gt; B)
    (implicit bf: CanBuildFrom[B, That, This]): That = {
  val b = bf(this)
  for (x &lt;- this) b += f(x)
  b.result
}</code></pre>

<p>The listing above shows trait <code>TraversableLike</code>&#8217;s implementation of <code>map</code>. It&#8217;s quite similar to the implementation of <code>filter</code> shown in <a href='#outline_of_class_traversablelike'>class <code>TraversableLike</code></a>. The principal difference is that where <code>filter</code> used the <code>newBuilder</code> method, which is abstract in class <code>TraversableLike</code>, <code>map</code> uses a <em>builder factory</em> that&#8217;s passed as an additional implicit parameter of type <code>CanBuildFrom</code>.</p>

<p>The <code>CanBuildFrom</code> trait:</p>

<pre><code>package scala.collection.generic

trait CanBuildFrom[-From, -Elem, +To] {
  // Creates a new builder 
  def apply(from: From): Builder[Elem, To] 
}</code></pre>

<p>The listing above shows the definition of the trait <code>CanBuildFrom</code>, which represents builder factories. It has three type parameters: <code>Elem</code> indicates the element type of the collection to be built, <code>To</code> indicates the type of collection to build, and <code>From</code> indicates the type for which this builder factory applies. By defining the right implicit definitions of builder factories, you can tailor the right typing behavior as needed. Take class <code>BitSet</code> as an example. Its companion object would contain a builder factory of type <code>CanBuildFrom[BitSet, Int, BitSet]</code>. This means that when operating on a <code>BitSet</code> you can construct another <code>BitSet</code> provided the type of the collection to build is <code>Int</code>. If this is not the case, you can always fall back to a different implicit builder factory, this time implemented in <code>mutable.Set</code>&#8217;s companion object. The type of this more general builder factory, where <code>A</code> is a generic type parameter, is:</p>

<pre><code>CanBuildFrom[Set[_], A, Set[A]]</code></pre>

<p>This means that when operating on an arbitrary <code>Set</code> (expressed by the existential type <code>Set[_]</code>) you can build a <code>Set</code> again, no matter what the element type <code>A</code> is. Given these two implicit instances of <code>CanBuildFrom</code>, you can then rely on Scala&#8217;s rules for implicit resolution to pick the one that&#8217;s appropriate and maximally specific.</p>

<p>So implicit resolution provides the correct static types for tricky collection operations such as <code>map</code>. But what about the dynamic types? Specifically, say you have a list value that has <code>Iterable</code> as its static type, and you map some function over that value:</p>

<pre><code>scala&gt; val xs: Iterable[Int] = List(1, 2, 3)
xs: Iterable[Int] = List(1, 2, 3)

scala&gt; val ys = xs map (x =&gt; x * x)
ys: Iterable[Int] = List(1, 4, 9)</code></pre>

<p>The static type of <code>ys</code> above is <code>Iterable</code>, as expected. But its dynamic type is (and should be) still <code>List</code>! This behavior is achieved by one more indirection. The <code>apply</code> method in <code>CanBuildFrom</code> is passed the source collection as argument. Most builder factories for generic traversables (in fact all except builder factories for leaf classes) forward the call to a method <code>genericBuilder</code> of a collection. The <code>genericBuilder</code> method in turn calls the builder that belongs to the collection in which it is defined. So Scala uses static implicit resolution to resolve constraints on the types of <code>map</code>, and virtual dispatch to pick the best dynamic type that corresponds to these constraints.</p>

<h2 id='integrating_new_collections'>Integrating new collections</h2>

<p>What needs to be done if you want to integrate a new collection class, so that it can profit from all predefined operations at the right types? On the next few pages you&#8217;ll be walked through two examples that do this.</p>

<h3 id='integrating_sequences'>Integrating sequences</h3>

<p>RNA Bases:</p>

<pre><code>abstract class Base
case object A extends Base
case object T extends Base
case object G extends Base
case object U extends Base

object Base {
  val fromInt: Int =&gt; Base = Array(A, T, G, U)
  val toInt: Base =&gt; Int = Map(A -&gt; 0, T -&gt; 1, G -&gt; 2, U -&gt; 3)
}</code></pre>

<p>Say you want to create a new sequence type for RNA strands, which are sequences of bases A (adenine), T (thymine), G (guanine), and U (uracil). The definitions for bases are easily set up as shown in the listing of RNA bases above.</p>

<p>Every base is defined as a case object that inherits from a common abstract class <code>Base</code>. The <code>Base</code> class has a companion object that defines two functions that map between bases and the integers 0 to 3. You can see in the examples two different ways to use collections to implement these functions. The <code>toInt</code> function is implemented as a <code>Map</code> from <code>Base</code> values to integers. The reverse function, <code>fromInt</code>, is implemented as an array. This makes use of the fact that both maps and arrays <em>are</em> functions because they inherit from the <code>Function1</code> trait.</p>

<p>The next task is to define a class for strands of RNA. Conceptually, a strand of RNA is simply a <code>Seq[Base]</code>. However, RNA strands can get quite long, so it makes sense to invest some work in a compact representation. Because there are only four bases, a base can be identified with two bits, and you can therefore store sixteen bases as two-bit values in an integer. The idea, then, is to construct a specialized subclass of <code>Seq[Base]</code>, which uses this packed representation.</p>

<h4 id='first_version_of_rna_strands_class'>First version of RNA strands class</h4>

<pre><code>import collection.IndexedSeqLike
import collection.mutable.{Builder, ArrayBuffer}
import collection.generic.CanBuildFrom

final class RNA1 private (val groups: Array[Int],
    val length: Int) extends IndexedSeq[Base] {

  import RNA1._

  def apply(idx: Int): Base = {
    if (idx &lt; 0 || length &lt;= idx)
      throw new IndexOutOfBoundsException
    Base.fromInt(groups(idx / N) &gt;&gt; (idx % N * S) &amp; M)
  }
}

object RNA1 {

  // Number of bits necessary to represent group
  private val S = 2            

  // Number of groups that fit in an Int
  private val N = 32 / S       

  // Bitmask to isolate a group
  private val M = (1 &lt;&lt; S) - 1 

  def fromSeq(buf: Seq[Base]): RNA1 = {
    val groups = new Array[Int]((buf.length + N - 1) / N)
    for (i &lt;- 0 until buf.length)
      groups(i / N) |= Base.toInt(buf(i)) &lt;&lt; (i % N * S)
    new RNA1(groups, buf.length)
  }

  def apply(bases: Base*) = fromSeq(bases)
}</code></pre>

<p>The <a href='#first_version_of_rna_strands_class'>RNA strands class listing</a> above presents the first version of this class. It will be refined later. The class <code>RNA1</code> has a constructor that takes an array of <code>Int</code>s as its first argument. This array contains the packed RNA data, with sixteen bases in each element, except for the last array element, which might be partially filled. The second argument, <code>length</code>, specifies the total number of bases on the array (and in the sequence). Class <code>RNA1</code> extends <code>IndexedSeq[Base]</code>. Trait <code>IndexedSeq</code>, which comes from package <code>scala.collection.immutable</code>, defines two abstract methods, <code>length</code> and <code>apply</code>. These need to be implemented in concrete subclasses. Class <code>RNA1</code> implements <code>length</code> automatically by defining a parametric field of the same name. It implements the indexing method <code>apply</code> with the code given in <a href='#first_version_of_rna_strands_class'>class <code>RNA1</code></a>. Essentially, <code>apply</code> first extracts an integer value from the <code>groups</code> array, then extracts the correct two-bit number from that integer using right shift (<code>&gt;&gt;</code>) and mask (<code>&amp;</code>). The private constants <code>S</code>, <code>N</code>, and <code>M</code> come from the <code>RNA1</code> companion object. <code>S</code> specifies the size of each packet (i.e., two); <code>N</code> specifies the number of two-bit packets per integer; and <code>M</code> is a bit mask that isolates the lowest <code>S</code> bits in a word.</p>

<p>Note that the constructor of class <code>RNA1</code> is <code>private</code>. This means that clients cannot create <code>RNA1</code> sequences by calling <code>new</code>, which makes sense, because it hides the representation of <code>RNA1</code> sequences in terms of packed arrays from the user. If clients cannot see what the representation details of RNA sequences are, it becomes possible to change these representation details at any point in the future without affecting client code. In other words, this design achieves a good decoupling of the interface of RNA sequences and its implementation. However, if constructing an RNA sequence with <code>new</code> is impossible, there must be some other way to create new RNA sequences, else the whole class would be rather useless. In fact there are two alternatives for RNA sequence creation, both provided by the <code>RNA1</code> companion object. The first way is method <code>fromSeq</code>, which converts a given sequence of bases (i.e., a value of type <code>Seq[Base]</code>) into an instance of class <code>RNA1</code>. The <code>fromSeq</code> method does this by packing all the bases contained in its argument sequence into an array, then calling <code>RNA1</code>&#8217;s private constructor with that array and the length of the original sequence as arguments. This makes use of the fact that a private constructor of a class is visible in the class&#8217;s companion object.</p>

<p>The second way to create an <code>RNA1</code> value is provided by the <code>apply</code> method in the <code>RNA1</code> object. It takes a variable number of <code>Base</code> arguments and simply forwards them as a sequence to <code>fromSeq</code>. Here are the two creation schemes in action:</p>

<pre><code>scala&gt; val xs = List(A, G, T, A)
xs: List[Product with Base] = List(A, G, T, A)

scala&gt; RNA1.fromSeq(xs)
res1: RNA1 = RNA1(A, G, T, A)

scala&gt; val rna1 = RNA1(A, U, G, G, T)
rna1: RNA1 = RNA1(A, U, G, G, T)</code></pre>

<h2 id='adapting_the_result_type_of_rna_methods'>Adapting the result type of RNA methods</h2>

<p>Here are some more interactions with the <code>RNA1</code> abstraction:</p>

<pre><code>scala&gt; rna1.length
res2: Int = 5

scala&gt; rna1.last
res3: Base = T

scala&gt; rna1.take(3)
res4: IndexedSeq[Base] = Vector(A, U, G)</code></pre>

<p>The first two results are as expected, but the last result of taking the first three elements of <code>rna1</code> might not be. In fact, you see a <code>IndexedSeq[Base]</code> as static result type and a <code>Vector</code> as the dynamic type of the result value. You might have expected to see an <code>RNA1</code> value instead. But this is not possible because all that was done in <a href='#first_version_of_rna_strands_class'>class <code>RNA1</code></a> was making <code>RNA1</code> extend <code>IndexedSeq</code>. Class <code>IndexedSeq</code>, on the other hand, has a <code>take</code> method that returns an <code>IndexedSeq</code>, and that&#8217;s implemented in terms of <code>IndexedSeq</code>&#8217;s default implementation, <code>Vector</code>. So that&#8217;s what you were seeing on the last line of the previous interaction.</p>

<h3 id='second_version_of_rna_strands_class'>Second version of RNA strands class</h3>

<pre><code>final class RNA2 private (
  val groups: Array[Int],
  val length: Int
) extends IndexedSeq[Base] with IndexedSeqLike[Base, RNA2] {

  import RNA2._

  override def newBuilder: Builder[Base, RNA2] = 
    new ArrayBuffer[Base] mapResult fromSeq

  def apply(idx: Int): Base = // as before
}</code></pre>

<p>Now that you understand why things are the way they are, the next question should be what needs to be done to change them? One way to do this would be to override the <code>take</code> method in class <code>RNA1</code>, maybe like this:</p>

<pre><code>def take(count: Int): RNA1 = RNA1.fromSeq(super.take(count))</code></pre>

<p>This would do the job for <code>take</code>. But what about <code>drop</code>, or <code>filter</code>, or <code>init</code>? In fact there are over fifty methods on sequences that return again a sequence. For consistency, all of these would have to be overridden. This looks less and less like an attractive option. Fortunately, there is a much easier way to achieve the same effect. The RNA class needs to inherit not only from <code>IndexedSeq</code>, but also from its implementation trait <code>IndexedSeqLike</code>. This is shown in the above listing of class <code>RNA2</code>. The new implementation differs from the previous one in only two aspects. First, class <code>RNA2</code> now also extends from <code>IndexedSeqLike[Base, RNA2]</code>. The <code>IndexedSeqLike</code> trait implements all concrete methods of <code>IndexedSeq</code> in an extensible way. For instance, the return type of methods like <code>take</code>, <code>drop</code>, <code>filter</code>, or <code>init</code> is the second type parameter passed to class <code>IndexedSeqLike</code>, i.e., in class <code>RNA2</code> it is <code>RNA2</code> itself.</p>

<p>To be able to do this, <code>IndexedSeqLike</code> bases itself on the <code>newBuilder</code> abstraction, which creates a builder of the right kind. Subclasses of trait <code>IndexedSeqLike</code> have to override <code>newBuilder</code> to return collections of their own kind. In class <code>RNA2</code>, the <code>newBuilder</code> method returns a builder of type <code>Builder[Base, RNA2]</code>.</p>

<p>To construct this builder, it first creates an <code>ArrayBuffer</code>, which itself is a <code>Builder[Base, ArrayBuffer]</code>. It then transforms the <code>ArrayBuffer</code> builder by calling its <code>mapResult</code> method to an <code>RNA2</code> builder. The <code>mapResult</code> method expects a transformation function from <code>ArrayBuffer</code> to <code>RNA2</code> as its parameter. The function given is simply <code>RNA2.fromSeq</code>, which converts an arbitrary base sequence to an <code>RNA2</code> value (recall that an array buffer is a kind of sequence, so <code>RNA2.fromSeq</code> can be applied to it).</p>

<p>If you had left out the <code>newBuilder</code> definition, you would have gotten an error message like the following:</p>

<pre><code>RNA2.scala:5: error: overriding method newBuilder in trait
TraversableLike of type =&gt; scala.collection.mutable.Builder[Base,RNA2];
 method newBuilder in trait GenericTraversableTemplate of type
 =&gt; scala.collection.mutable.Builder[Base,IndexedSeq[Base]] has
 incompatible type
class RNA2 private (val groups: Array[Int], val length: Int) 
      ^
one error found</code></pre>

<p>The error message is quite long and complicated, which reflects the intricate way the collection libraries are put together. It&#8217;s best to ignore the information about where the methods come from, because in this case it detracts more than it helps. What remains is that a method <code>newBuilder</code> with result type <code>Builder[Base, RNA2]</code> needed to be defined, but a method <code>newBuilder</code> with result type <code>Builder[Base,IndexedSeq[Base]]</code> was found. The latter does not override the former. The first method, whose result type is <code>Builder[Base, RNA2]</code>, is an abstract method that got instantiated at this type in <a href='#second_version_of_rna_strands_class'>class <code>RNA2</code></a> by passing the <code>RNA2</code> type parameter to <code>IndexedSeqLike</code>. The second method, of result type <code>Builder[Base,IndexedSeq[Base]]</code>, is what&#8217;s provided by the inherited <code>IndexedSeq</code> class. In other words, the <code>RNA2</code> class is invalid without a definition of <code>newBuilder</code> with the first result type.</p>

<p>With the refined implementation of the <a href='#second_version_of_rna_strands_class'><code>RNA2</code> class</a>, methods like <code>take</code>, <code>drop</code>, or <code>filter</code> work now as expected:</p>

<pre><code>scala&gt; val rna2 = RNA2(A, U, G, G, T)
rna2: RNA2 = RNA2(A, U, G, G, T)

scala&gt; rna2 take 3
res5: RNA2 = RNA2(A, U, G)

scala&gt; rna2 filter (U !=)
res6: RNA2 = RNA2(A, G, G, T)</code></pre>

<h2 id='dealing_with_map_and_friends'>Dealing with map and friends</h2>

<p>However, there is another class of methods in collections that are not dealt with yet. These methods do not always return the collection type exactly. They might return the same kind of collection, but with a different element type. The classical example of this is the <code>map</code> method. If <code>s</code> is a <code>Seq[Int]</code>, and <code>f</code> is a function from <code>Int</code> to <code>String</code>, then <code>s.map(f)</code> would return a <code>Seq[String]</code>. So the element type changes between the receiver and the result, but the kind of collection stays the same.</p>

<p>There are a number of other methods that behave like <code>map</code>. For some of them you would expect this (e.g., <code>flatMap</code>, <code>collect</code>), but for others you might not. For instance, the append method, <code>++</code>, also might return a result of different type as its arguments&#8211;appending a list of <code>String</code> to a list of <code>Int</code> would give a list of <code>Any</code>. How should these methods be adapted to RNA strands? Ideally we&#8217;d expect that mapping bases to bases over an RNA strand would yield again an RNA strand:</p>

<pre><code>scala&gt; val rna = RNA(A, U, G, G, T)
rna: RNA = RNA(A, U, G, G, T)

scala&gt; rna map { case A =&gt; T case b =&gt; b }
res7: RNA = RNA(T, U, G, G, T)</code></pre>

<p>Likewise, appending two RNA strands with <code>++</code> should yield again another RNA strand:</p>

<pre><code>scala&gt; rna ++ rna
res8: RNA = RNA(A, U, G, G, T, A, U, G, G, T)</code></pre>

<p>On the other hand, mapping bases to some other type over an RNA strand cannot yield another RNA strand because the new elements have the wrong type. It has to yield a sequence instead. In the same vein appending elements that are not of type <code>Base</code> to an RNA strand can yield a general sequence, but it cannot yield another RNA strand.</p>

<pre><code>scala&gt; rna map Base.toInt
res2: IndexedSeq[Int] = Vector(0, 3, 2, 2, 1)

scala&gt; rna ++ List(&quot;missing&quot;, &quot;data&quot;)
res3: IndexedSeq[java.lang.Object] = 
  Vector(A, U, G, G, T, missing, data)</code></pre>

<p>This is what you&#8217;d expect in the ideal case. But this is not what the <a href='#second_version_of_rna_strands_class'><code>RNA2</code> class</a> provides. In fact, if you ran the first two examples above with instances of this class you would obtain:</p>

<pre><code>scala&gt; val rna2 = RNA2(A, U, G, G, T)
rna2: RNA2 = RNA2(A, U, G, G, T)

scala&gt; rna2 map { case A =&gt; T case b =&gt; b }
res0: IndexedSeq[Base] = Vector(T, U, G, G, T)

scala&gt; rna2 ++ rna2
res1: IndexedSeq[Base] = Vector(A, U, G, G, T, A, U, G, G, T)</code></pre>

<p>So the result of <code>map</code> and <code>++</code> is never an RNA strand, even if the element type of the generated collection is a <code>Base</code>. To see how to do better, it pays to have a close look at the signature of the <code>map</code> method (or of <code>++</code>, which has a similar signature). The <code>map</code> method is originally defined in class <code>scala.collection.TraversableLike</code> with the following signature:</p>

<pre><code>def map[B, That](f: A =&gt; B)
  (implicit cbf: CanBuildFrom[Repr, B, That]): That</code></pre>

<p>Here <code>A</code> is the type of elements of the collection, and <code>Repr</code> is the type of the collection itself, that is, the second type parameter that gets passed to implementation classes such as <code>TraversableLike</code> and <code>IndexedSeqLike</code>. The <code>map</code> method takes two more type parameters, <code>B</code> and <code>That</code>. The <code>B</code> parameter stands for the result type of the mapping function, which is also the element type of the new collection. The <code>That</code> appears as the result type of <code>map</code>, so it represents the type of the new collection that gets created.</p>

<p>How is the <code>That</code> type determined? In fact it is linked to the other types by an implicit parameter <code>cbf</code>, of type <code>CanBuildFrom[Repr, B, That]</code>. These <code>CanBuildFrom</code> implicits are defined by the individual collection classes. In essence, an implicit value of type <code>CanBuildFrom[From, Elem, To]</code> says: &#8220;Here is a way, given a collection of type <code>From</code>, to build with elements of type <code>Elem</code> a collection of type <code>To</code>.&#8221;</p>

<h3 id='final_version_of_rna_strands_class'>Final version of RNA strands class</h3>

<pre><code>final class RNA private (val groups: Array[Int], val length: Int) 
  extends IndexedSeq[Base] with IndexedSeqLike[Base, RNA] {
  
  import RNA._
  
  // Mandatory re-implementation of `newBuilder` in `IndexedSeq`
  override protected[this] def newBuilder: Builder[Base, RNA] = 
    RNA.newBuilder
  
  // Mandatory implementation of `apply` in `IndexedSeq`
  def apply(idx: Int): Base = {
    if (idx &lt; 0 || length &lt;= idx)
      throw new IndexOutOfBoundsException
    Base.fromInt(groups(idx / N) &gt;&gt; (idx % N * S) &amp; M)
  }
  
  // Optional re-implementation of foreach, 
  // to make it more efficient.
  override def foreach[U](f: Base =&gt; U): Unit = {
    var i = 0
    var b = 0
    while (i &lt; length) {
      b = if (i % N == 0) groups(i / N) else b &gt;&gt;&gt; S
      f(Base.fromInt(b &amp; M))
      i += 1
    }
  }
}</code></pre>

<h3 id='final_version_of_rna_companion_object'>Final version of RNA companion object</h3>

<pre><code>object RNA {

  private val S = 2            // number of bits in group
  private val M = (1 &lt;&lt; S) - 1 // bitmask to isolate a group
  private val N = 32 / S       // number of groups in an Int

  def fromSeq(buf: Seq[Base]): RNA = {
    val groups = new Array[Int]((buf.length + N - 1) / N)
    for (i &lt;- 0 until buf.length)
      groups(i / N) |= Base.toInt(buf(i)) &lt;&lt; (i % N * S)
    new RNA(groups, buf.length)
  }

  def apply(bases: Base*) = fromSeq(bases)

  def newBuilder: Builder[Base, RNA] = 
    new ArrayBuffer mapResult fromSeq

  implicit def canBuildFrom: CanBuildFrom[RNA, Base, RNA] = 
    new CanBuildFrom[RNA, Base, RNA] {
      def apply(): Builder[Base, RNA] = newBuilder
      def apply(from: RNA): Builder[Base, RNA] = newBuilder
    }
}</code></pre>

<p>Now the behavior of <code>map</code> and <code>++</code> on <code>RNA2</code> sequences becomes clearer. There is no <code>CanBuildFrom</code> instance that creates <code>RNA2</code> sequences, so the next best available <code>CanBuildFrom</code> was found in the companion object of the inherited trait <code>IndexedSeq</code>. That implicit creates <code>IndexedSeq</code>s, and that&#8217;s what you saw when applying <code>map</code> to <code>rna2</code>.</p>

<p>To address this shortcoming, you need to define an implicit instance of <code>CanBuildFrom</code> in the companion object of the RNA class. That instance should have type <code>CanBuildFrom[RNA, Base, RNA]</code>. Hence, this instance states that, given an RNA strand and a new element type <code>Base</code>, you can build another collection which is again an RNA strand. The two listings above on <a href='#final_version_of_rna_strands_class'>class <code>RNA</code></a> and <a href='#final_version_of_rna_companion_object'>its companion object</a> show the details. Compared to <a href='#second_version_of_rna_strands_class'>class <code>RNA2</code></a> there are two important differences. First, the <code>newBuilder</code> implementation has moved from the RNA class to its companion object. The <code>newBuilder</code> method in class <code>RNA</code> simply forwards to this definition. Second, there is now an implicit <code>CanBuildFrom</code> value in object <code>RNA</code>. To create such an object you need to define two <code>apply</code> methods in the <code>CanBuildFrom</code> trait. Both create a new builder for an <code>RNA</code> collection, but they differ in their argument list. The <code>apply()</code> method simply creates a new builder of the right type. By contrast, the <code>apply(from)</code> method takes the original collection as argument. This can be useful to adapt the dynamic type of builder&#8217;s return type to be the same as the dynamic type of the receiver. In the case of <code>RNA</code> this does not come into play because <code>RNA</code> is a final class, so any receiver of static type <code>RNA</code> also has <code>RNA</code> as its dynamic type. That&#8217;s why <code>apply(from)</code> also simply calls <code>newBuilder</code>, ignoring its argument.</p>

<p>That is it. The final <a href='#final_version_of_rna_strands_class'><code>RNA</code> class</a> implements all collection methods at their natural types. Its implementation requires a little bit of protocol. In essence, you need to know where to put the <code>newBuilder</code> factories and the <code>canBuildFrom</code> implicits. On the plus side, with relatively little code you get a large number of methods automatically defined. Also, if you don&#8217;t intend to do bulk operations like <code>take</code>, <code>drop</code>, <code>map</code>, or <code>++</code> on your collection you can choose to not go the extra length and stop at the implementation shown in for <a href='#first_version_of_rna_strands_class'>class <code>RNA1</code></a>.</p>

<p>The discussion so far centered on the minimal amount of definitions needed to define new sequences with methods that obey certain types. But in practice you might also want to add new functionality to your sequences or to override existing methods for better efficiency. An example of this is the overridden <code>foreach</code> method in class <code>RNA</code>. <code>foreach</code> is an important method in its own right because it implements loops over collections. Furthermore, many other collection methods are implemented in terms of <code>foreach</code>. So it makes sense to invest some effort optimizing the method&#8217;s implementation. The standard implementation of <code>foreach</code> in <code>IndexedSeq</code> will simply select every <code>i</code>&#8216;th element of the collection using <code>apply</code>, where <code>i</code> ranges from 0 to the collection&#8217;s length minus one. So this standard implementation selects an array element and unpacks a base from it once for every element in an RNA strand. The overriding <code>foreach</code> in class <code>RNA</code> is smarter than that. For every selected array element it immediately applies the given function to all bases contained in it. So the effort for array selection and bit unpacking is much reduced.</p>

<h2 id='integrating_new_sets_and_maps'>Integrating new sets and maps</h2>

<p>As a second example you&#8217;ll learn how to integrate a new kind of map into the collection framework. The idea is to implement a mutable map with <code>String</code> as the type of keys by a &#8220;Patricia trie&#8221;. The term <em>Patricia</em> is in fact an abbreviation for &#8220;Practical Algorithm to Retrieve Information Coded in Alphanumeric.&#8221; The idea is to store a set or a map as a tree where subsequent character in a search key determines uniquely a descendant tree. For instance a Patricia trie storing the three strings &#8220;abc&#8221;, &#8220;abd&#8221;, &#8220;al&#8221;, &#8220;all&#8221;, &#8220;xy&#8221; would look like this:</p>

<p>A sample patricia tree: <img width='550' src='/resources/images/patricia.png' /></p>

<p>To find the node corresponding to the string &#8220;abc&#8221; in this trie, simply follow the subtree labeled &#8220;a&#8221;, proceed from there to the subtree labelled &#8220;b&#8221;, to finally reach its subtree labelled &#8220;c&#8221;. If the Patricia trie is used as a map, the value that&#8217;s associated with a key is stored in the nodes that can be reached by the key. If it is a set, you simply store a marker saying that the node is present in the set.</p>

<p>An implementation of prefix maps with Patricia tries:</p>

<pre><code>import collection._
  
class PrefixMap[T]
extends mutable.Map[String, T] 
   with mutable.MapLike[String, T, PrefixMap[T]] {
  
  var suffixes: immutable.Map[Char, PrefixMap[T]] = Map.empty
  var value: Option[T] = None
  
  def get(s: String): Option[T] =
    if (s.isEmpty) value
    else suffixes get (s(0)) flatMap (_.get(s substring 1))
  
  def withPrefix(s: String): PrefixMap[T] = 
    if (s.isEmpty) this
    else {
      val leading = s(0)
      suffixes get leading match {
        case None =&gt;
          suffixes = suffixes + (leading -&gt; empty)
        case _ =&gt;
      }
      suffixes(leading) withPrefix (s substring 1)
    }
  
  override def update(s: String, elem: T) =
    withPrefix(s).value = Some(elem)
  
  override def remove(s: String): Option[T] =
    if (s.isEmpty) { val prev = value; value = None; prev }
    else suffixes get (s(0)) flatMap (_.remove(s substring 1))
  
  def iterator: Iterator[(String, T)] =
    (for (v &lt;- value.iterator) yield (&quot;&quot;, v)) ++
    (for ((chr, m) &lt;- suffixes.iterator; 
          (s, v) &lt;- m.iterator) yield (chr +: s, v))
  
  def += (kv: (String, T)): this.type = { update(kv._1, kv._2); this }
  
  def -= (s: String): this.type  = { remove(s); this }
  
  override def empty = new PrefixMap[T]
}</code></pre>

<p>Patricia tries support very efficient lookups and updates. Another nice feature is that they support selecting a subcollection by giving a prefix. For instance, in the patricia tree above you can obtain the sub-collection of all keys that start with an &#8220;a&#8221; simply by following the &#8220;a&#8221; link from the root of the tree.</p>

<p>Based on these ideas we will now walk you through the implementation of a map that&#8217;s implemented as a Patricia trie. We call the map a <code>PrefixMap</code>, which means that it provides a method <code>withPrefix</code> that selects a submap of all keys starting with a given prefix. We&#8217;ll first define a prefix map with the keys shown in the running example:</p>

<pre><code>scala&gt; val m = PrefixMap(&quot;abc&quot; -&gt; 0, &quot;abd&quot; -&gt; 1, &quot;al&quot; -&gt; 2, 
  &quot;all&quot; -&gt; 3, &quot;xy&quot; -&gt; 4)
m: PrefixMap[Int] = Map((abc,0), (abd,1), (al,2), (all,3), (xy,4))</code></pre>

<p>Then calling <code>withPrefix</code> on <code>m</code> will yield another prefix map:</p>

<pre><code>scala&gt; m withPrefix &quot;a&quot;
res14: PrefixMap[Int] = Map((bc,0), (bd,1), (l,2), (ll,3))</code></pre>

<p>The previous listing shows the definition of <code>PrefixMap</code>. This class is parameterized with the type of associated values <code>T</code>, and extends <code>mutable.Map[String, T]</code> and <code>mutable.MapLike[String, T, PrefixMap[T]]</code>. You have seen this pattern already for sequences in the RNA strand example; then as now inheriting an implementation class such as <code>MapLike</code> serves to get the right result type for transformations such as <code>filter</code>.</p>

<p>A prefix map node has two mutable fields: <code>suffixes</code> and <code>value</code>. The <code>value</code> field contains an optional value that&#8217;s associated with the node. It is initialized to <code>None</code>. The <code>suffixes</code> field contains a map from characters to <code>PrefixMap</code> values. It is initialized to the empty map.</p>

<p>You might ask why did we pick an immutable map as the implementation type for <code>suffixes</code>? Would not a mutable map have been more standard, since <code>PrefixMap</code> as a whole is also mutable? The answer is that immutable maps that contain only a few elements are very efficient in both space and execution time. For instance, maps that contain fewer than 5 elements are represented as a single object. By contrast, the standard mutable map is a <code>HashMap</code>, which typically occupies around 80 bytes, even if it is empty. So if small collections are common, it&#8217;s better to pick immutable over mutable. In the case of Patricia tries, we&#8217;d expect that most nodes except the ones at the very top of the tree would contain only a few successors. So storing these successors in an immutable map is likely to be more efficient.</p>

<p>Now have a look at the first method that needs to be implemented for a map: <code>get</code>. The algorithm is as follows: To get the value associated with the empty string in a prefix map, simply select the optional <code>value</code> stored in the root of the tree. Otherwise, if the key string is not empty, try to select the submap corresponding to the first character of the string. If that yields a map, follow up by looking up the remainder of the key string after its first character in that map. If the selection fails, the key is not stored in the map, so return with <code>None</code>. The combined selection over an option value is elegantly expressed using <code>flatMap</code>. When applied to an optional value, <code>ov</code>, and a closure, <code>f</code>, which in turn returns an optional value, <code>ov flatMap f</code> will succeed if both <code>ov</code> and <code>f</code> return a defined value. Otherwise <code>ov flatMap f</code> will return <code>None</code>.</p>

<p>The next two methods to implement for a mutable map are <code>+=</code> and <code>-=</code>. In the implementation of <code>PrefixMap</code>, these are defined in terms of two other methods: <code>update</code> and <code>remove</code>.</p>

<p>The <code>remove</code> method is very similar to <code>get</code>, except that before returning any associated value, the field containing that value is set to <code>None</code>. The <code>update</code> method first calls <code>withPrefix</code> to navigate to the tree node that needs to be updated, then sets the <code>value</code> field of that node to the given value. The <code>withPrefix</code> method navigates through the tree, creating sub-maps as necessary if some prefix of characters is not yet contained as a path in the tree.</p>

<p>The last abstract method to implement for a mutable map is <code>iterator</code>. This method needs to produce an iterator that yields all key/value pairs stored in the map. For any given prefix map this iterator is composed of the following parts: First, if the map contains a defined value, <code>Some(x)</code>, in the <code>value</code> field at its root, then <code>(&quot;&quot;, x)</code> is the first element returned from the iterator. Furthermore, the iterator needs to traverse the iterators of all submaps stored in the <code>suffixes</code> field, but it needs to add a character in front of every key string returned by those iterators. More precisely, if <code>m</code> is the submap reached from the root through a character <code>chr</code>, and <code>(s, v)</code> is an element returned from <code>m.iterator</code>, then the root&#8217;s iterator will return <code>(chr +: s, v)</code> instead. This logic is implemented quite concisely as a concatenation of two <code>for</code> expressions in the implementation of the <code>iterator</code> method in <code>PrefixMap</code>. The first <code>for</code> expression iterates over <code>value.iterator</code>. This makes use of the fact that <code>Option</code> values define an iterator method that returns either no element, if the option value is <code>None</code>, or exactly one element <code>x</code>, if the option value is <code>Some(x)</code>.</p>

<p>The companion object for prefix maps:</p>

<pre><code>import scala.collection.mutable.{Builder, MapBuilder}
import scala.collection.generic.CanBuildFrom
  
object PrefixMap extends {
  def empty[T] = new PrefixMap[T]
  
  def apply[T](kvs: (String, T)*): PrefixMap[T] = {
    val m: PrefixMap[T] = empty
    for (kv &lt;- kvs) m += kv
    m
  }
  
  def newBuilder[T]: Builder[(String, T), PrefixMap[T]] = 
    new MapBuilder[String, T, PrefixMap[T]](empty)
  
  implicit def canBuildFrom[T]
    : CanBuildFrom[PrefixMap[_], (String, T), PrefixMap[T]] = 
      new CanBuildFrom[PrefixMap[_], (String, T), PrefixMap[T]] {
        def apply(from: PrefixMap[_]) = newBuilder[T]
        def apply() = newBuilder[T]
      }
}</code></pre>

<p>Note that there is no <code>newBuilder</code> method defined in <code>PrefixMap</code>. There is no need to, because maps and sets come with default builders, which are instances of class <code>MapBuilder</code>. For a mutable map the default builder starts with an empty map and then adds successive elements using the map&#8217;s <code>+=</code> method. Mutable sets behave the same. The default builders for immutable maps and sets use the non-destructive element addition method <code>+</code>, instead of method <code>+=</code>.</p>

<p>However, in all these cases, to build the right kind of set or map, you need to start with an empty set or map of this kind. This is provided by the <code>empty</code> method, which is the last method defined in <code>PrefixMap</code>. This method simply returns a fresh <code>PrefixMap</code>.</p>

<p>We&#8217;ll now turn to the companion object <code>PrefixMap</code>. In fact it is not strictly necessary to define this companion object, as class <code>PrefixMap</code> can stand well on its own. The main purpose of object <code>PrefixMap</code> is to define some convenience factory methods. It also defines a <code>CanBuildFrom</code> implicit to make typing work out better.</p>

<p>The two convenience methods are <code>empty</code> and <code>apply</code>. The same methods are present for all other collections in Scala&#8217;s collection framework so it makes sense to define them here, too. With the two methods, you can write <code>PrefixMap</code> literals like you do for any other collection:</p>

<pre><code>scala&gt; PrefixMap(&quot;hello&quot; -&gt; 5, &quot;hi&quot; -&gt; 2)
res0: PrefixMap[Int] = Map((hello,5), (hi,2))
  
scala&gt; PrefixMap.empty[String]
res2: PrefixMap[String] = Map()</code></pre>

<p>The other member in object <code>PrefixMap</code> is an implicit <code>CanBuildFrom</code> instance. It has the same purpose as the <code>CanBuildFrom</code> definition in the last section: to make methods like <code>map</code> return the best possible type. For instance, consider <code>map</code>ping a function over the key/value pairs of a <code>PrefixMap</code>. As long as that function produces pairs of strings and some second type, the result collection will again be a <code>PrefixMap</code>. Here&#8217;s an example:</p>

<pre><code>scala&gt; res0 map { case (k, v) =&gt; (k + &quot;!&quot;, &quot;x&quot; * v) }
res8: PrefixMap[String] = Map((hello!,xxxxx), (hi!,xx))</code></pre>

<p>The given function argument takes the key/value bindings of the prefix map <code>res0</code> and produces pairs of strings. The result of the <code>map</code> is a <code>PrefixMap</code>, this time with value type <code>String</code> instead of <code>Int</code>. Without the <code>canBuildFrom</code> implicit in <code>PrefixMap</code> the result would just have been a general mutable map, not a prefix map.</p>

<h2 id='summary'>Summary</h2>

<p>To summarize, if you want to fully integrate a new collection class into the framework you need to pay attention to the following points:</p>

<ol>
<li>Decide whether the collection should be mutable or immutable.</li>

<li>Pick the right base traits for the collection.</li>

<li>Inherit from the right implementation trait to implement most collection operations.</li>

<li>If you want <code>map</code> and similar operations to return instances of your collection type, provide an implicit <code>CanBuildFrom</code> in your class&#8217;s companion object.</li>
</ol>

<p>You have now seen how Scala&#8217;s collections are built and how you can build new kinds of collections. Because of Scala&#8217;s rich support for abstraction, each new collection type can have a large number of methods without having to reimplement them all over again.</p>

<h3 id='acknowledgement'>Acknowledgement</h3>

<p>These pages contain material adapted from the 2nd edition of <a href='http://www.artima.com/shop/programming_in_scala'>Programming in Scala</a> by Odersky, Spoon and Venners. We thank Artima for graciously agreeing to its publication.</p>
      
    </div>
    
    <div class="span6">
      <div id="scroller-anchor">
  <div id="scroller">
    <p class="contents">Contents</p>
    <div id="toc"></div>    
              
  </div>
</div>

    </div>
    
	
  </div>
</div>

<div class="footer">
	<div class="container">
		<ul>
			<li><h5>API</h5></li>
			<li><a href="http://www.scala-lang.org/api/current/">Current</a></li>
			<li><a href="http://www.scala-lang.org/archives/downloads/distrib/files/nightly/docs/library/index.html">Nightly</a></li>
		</ul>
		<ul>
			<li><h5>Learn</h5></li>
			<li><a href="/overviews">Guides & Overviews</a></li>
			<li><a href="/tutorials">Tutorials</a></li>
			<li><a href="/style">Scala Style Guide</a></li>				
		</ul>
		<ul>
			<li><h5>Quickref</h5></li>
			<li><a href="/glossary">Glossary</a></li>
			<li><a href="/cheatsheets">Cheatsheets</a></li>
		</ul>
		<ul>
			<li><h5>Contribute</h5></li>
			<li><a href="http://github.com/scala/scala.github.com">Source Code</a></li>
			<li><a href="/contribute.html">Contributors Guide</a></li>
			<li><a href="http://getsatisfaction.com/scaladocs">Suggestions</a></li>			
		</ul>
		<ul>
			<li><h5>Other Resources</h5></li>
			<li><a href="http://wiki.scala-lang.org">Wiki</a></li>
			<li><a href="/sips">Scala Improvement Process</a></li>				
		</ul>						
	</div>
	<div class="container copyright">
 		<p>
			Copyright &copy; 2011-2013 EPFL. All rights reserved.
			<a href="https://github.com/scala/scala.github.com/commits/gh-pages.atom"><img align="right" height="20px" width="20px" src="/resources/images/rss.png" alt="RSS feed of updates to the github repo hosting this site"></a>
		</p>		
	</div>
</div>


<script type="text/javascript">
  $('#toc').toc({exclude: 'h1, h5, h6', context: '', autoId: true, numerate: false});
</script>

<script type="text/javascript">
  $(function() {
    moveScroller();
  });
</script>

  </body>
</html>

    
