---
layout: glossary
title: Glossary

language: zh-cn
---

<h5>该术语表摘自Scala权威书籍《<a href="https://www.artima.com/shop/programming_in_scala">Programming in Scala</a>》</h5>

<div class="filterbar">
  <div class="icon-search">
    <i class="fa fa-search"></i>
  </div>
  <input type="text" id="filter-glossary-terms" placeholder="Look up a term...">
  <!-- <input class="field" id="filter" type="text" /> -->
  <span id="filter-count">&nbsp;</span>
</div>

* #### 代数数据类型（algebraic data type）
通过提供若干个带有独立构造器的备选项来定义的类型。它一般通过模式匹配的方式来结构类型，在规约语言和函数式编程语言中常见到这个概念。Scala可通过案例类来模拟代数数据类型。

* #### 备选项（alternative）
match表达式的一个分支，形如 “`case` _pattern_ => _expression_”。备选项的别名是 _案例_（_case_）。

* #### 注解（annotation）
注解一般出现在源码中，并附加到语法的某个部分。注解对于计算机来说都是可处理的，所以可以用来有效的增加Scala扩展。

* #### 匿名类（anonymous class）
匿名类是由Scala编译器根据一种new表达式生成的合成子类，这种new表达式由类名或特质名后面紧跟一对花括号组成。花括号内包含了匿名子类的构造体，可为空，不过一旦跟在new后面名称指向的特质或类包含了抽象成员，则这些抽象成员就必须在其匿名子类的构造体内具化，即在花括号内要实现这些成员。

* #### 匿名函数（anonymous function）
[函数字面量](#函数字面量function-literal)的另一种叫法。

* #### 应用（apply）
方法、函数或闭包应用于参数，意思是说通过这些实参来调用方法、函数或闭包。

* #### 实参（argument）
在函数调用过程中实参被传给函数的各个参数，其中参数就是指向实参的变量，实参则是调用发生时被传入的对象。另外，应用程序都可以获取被传入单例对象的main方法且类型为`Array[String]`的实参（来自命令行）。

* #### 赋值（assign）
可把对象赋值给变量，之后，变量就会指向对象。

* #### 辅助构造器（auxiliary constructor）
在类定义体花括号里面定义的所有附加构造器，其形似名为`this`但无结果类型的方法定义。

* #### 块（block）
被花括号围起来的一个或多个表达式和声明。求值块的时候，块内所有表达式和声明会被顺序处理，然后会返回最后一个表达式的值作为其自身的值。块通常被用来作为构造体，诸如函数、[for表达式](#for表达式for-expression)、`while`循环以及其他任何需要把语句组织到一起的地方，都会用到块。更正式点说，块是一个只其副作用和结果值对外可见的封装构造体。因此，类或对象的花括号是不会形成块的，因其内部定义字段和方法均对外可见。这样的花括号形成的是模板。

* #### 绑定变量（bound variable）
表达式的绑定变量是定义和使用都在表达式内部的变量。例如，在函数字面量表达式`(x: Int) => (x, y)`里面，`x`和`y`都被用到了，但只有`x`被绑定了，因为它在表达式中被定义为一个`Int`变量，并且它也是表达式所描述函数的唯一实参。

* #### 传名参数（by-name parameter）
参数类型前面带有`=>`的参数，如`(x: => Int)`。传名参数对应的实参求值不在方法被调用前，而是在每次方法通过名称引用到参数的时候。参数若不是传名的，则定是传值的。

* #### 传值参数（by-value parameter）
参数类型前面不带`=>`的参数，如`(x: Int)`。传值参数对应的实参是在方法调用前被求值的。传值参数是相对传名参数而言的。

* #### 类（class）
通过关键字`class`来定义的类，可抽象可具体，且在实例化时可用类型和值对其进行参数化处理。比如`new Array[String](2)`，被实例化的类是`Array`，产生的值类型为`Array[String]`。带有类型参数的类被称为 _类型构造器_ ，也可说成是类型具有类属性，如：类型`Array[String]`具有的类属性是`Array`。

* #### 闭包（closure）
可以捕获自由变量，或者说"关闭"函数创建时可见变量的函数对象。

* #### 伴生类（companion class）
和定义在相同源文件中的单例对象共享同一个名称的类，这样的类就叫做那个单例对象的伴生类。

* #### 伴生对象（companion object）
和定义在相同源文件中的类共享同一个名称的单例对象。伴生对象和伴生类具备访问彼此私有成员的能力。另外，类不管被用在何处，其伴生对象中定义的任何隐式转换都在其作用域内。

* #### 逆变（contravariant）
逆变标注可应用于类或特质的类型参数上，把减号（-）置于类型参数前即可。标注为逆变后类或特质的子类型将逆向（向相反的方向）协变于类型标注的参数。比如，`Function1`的第一个类型参数就是逆变的，所以`Function1[Any, Any]`是`Function1[String, Any]`的子类。

* #### 协变（covariant）
协变标注可应用于类或特质的类型参数上，把加号（+）置于类型参数前即可。标注为协变后类或特质的子类型将正向（向相同的方向）协变于类型标注的参数。比如，`List`的类型参数是协变的，所以`List[String]`是`List[Any]`的子类。 

* #### 柯里化（currying）
把函数写成多个参数列表的方式。例如：`def f(x: Int)(y: Int)`是一个带有两个参数列表的柯里化函数。应用柯里化函数时需传入若干个实参列表，像`f(3)(4)`这样。不过也可以写成柯里化函数的 _部分应用_（partial application），像`f(3)`这样。

* #### 声明（declare）
可以通过 _声明_ 抽象的字段、方法或类型来赋给实体一个名称，但是没有具体实现。声明和定义最关键的差异就是定义会为命名实体创建具体实现，而声明则不会。

* #### 定义（define）
在Scala程序中若提到 _定义_ 什么东西，就是说给它赋个名称并给出实现。可以定义的东西包括类、特质、单例对象、字段、方法、局部函数、局部变量等。由于提到定义常常会涉及到某种具体实现，故而抽象成员应为声明而非定义。

* #### 直接子类（direct subclass）
类是其 _直接子类_ 的直接超类。

* #### 直接超类（direct superclass）
从某个类直接衍生出类或特质，或者说在继承层级结构最接近自己的上层的某个类，这样的类就是直接超类。若类`Child`的可选的extends子句中含有类`Parent`，则`Parent`就是`Child`的直接超类。若`Child`的可选extends子句中含有特质，则特质的直接超类也是`Child`的直接超类。若`Child`没有extends子句，则`AnyRef`就是`Child`的直接超类。若类的直接超类带有类型参数，比如`Child extends Parent[String]`，`Child`的直接超类依旧是`Parent`，而不是`Parent[String]`。另一方面，`Parent[String]`应该叫做`Child`的直接超类型。参见[超类型](#超类型supertype)了解更多关于类和类型间的区别。

* #### 相等性（equality）
在没有条件限制的情况下使用时，_相等性_ 就是`==`所表达的两个值之间的关系。参见[引用相等性](#引用相等性reference-equality)。

* #### 存在类型（existential type）
存在类型包含未知类型变量的引用。比如：`Array[T] forSome { type T }`是个存在类型，是`T`的数组，而`T`是某个完全未知的类型，关于`T`唯一能够假定的是它是确定存在的。尽管这个假定很虚，但是至少意味着`Array[T] forSome { type T }`确实是个数组，而不是香蕉什么的东西。

* #### 表达式（expression）
任何能够得到结果的Scala代码，也可说成表达式求值为某个结果或结果为某个值。

* #### 过滤器（filter）
[for表达式](#for表达式for-expression)中的`if`及跟在其后的布尔表达式。在`for(i <- 1 to 10; if i % 2 == 0)`中，过滤器为"`if i % 2 == 0`"。`if`右边的值就是[过滤器表达式](#过滤器表达式filter-expression)，也称为守卫。

* #### 过滤器表达式（filter expression）
过滤器表达式就是[for表达式](#for表达式for-expression)里面跟在`if`后面的布尔表达式。`for( i <- 1 to 10 ; if i % 2 == 0)`的过滤器表达式为"`i % 2 == 0`"。

* #### 头等函数（first-class function）
Scala支持 _头等函数_ ，意味着可以通过函数字面量语法来表达函数。如：`(x: Int) => x + 1`，并且函数可由对象来表达，叫做[函数值](#函数值function-value)。

* #### for推解式（for comprehension）
_for推解式_ 是[for表达式](#for表达式for-expression)的一种，一般用来创建新的集合。对`for`推解式的每次迭代，[yield](#产生yield)子句都会定义新集合的一个元素。比如：`for (i <- (0 until 2); j <- (2 until 4)) yield (i, j)`将返回集合`Vector((0,2), (0,3), (1,2), (1,3))`。

* #### for表达式（for expression）
_for表达式_ 要么是个[for循环](#for循环for-loop)，可以迭代一个或多个集合，要么是个[for推解式](#for推解式for-comprehension)，可以从一个或多个集合的元素中推解出一个新的集合。`for`表达式建于[生成器](#生成器generator)、[过滤器](#过滤器filter)、变量定义和[yield](#产生yield)子句（针对[for推解式](#for推解式for-comprehension)）基础之上，

* #### for循环（for loop）
_for循环_ 是[for表达式](#for表达式for-expression)的一种，一般用来循环迭代一个或多个集合。因为`for`循环返回unit，所以经常被用来产生副作用。比如：`for (i <- 0 until 100) println(i)`打印数字0到99。

* #### 自由变量（free variable）
一个表达式的 _自由变量_ 指的是在表达式中使用但不定义在其中的变量。例如，在函数字面量表达式`(x: Int) => (x, y)`中，变量`x`和`y`都被用到了，但只有`y`是自由变量，因其未在表达式中定义。

* #### 函数（function）
_函数_ 可通过一列实参来[调用](#调用invoke)然后产生结果。函数一般具有参数列表、函数体和结果类型。作为类、特质或单例对象的函数叫做[方法](#方法method)。定义在其他函数内部的函数叫做[局部函数](#局部函数local-function)。结果类型为`Unit`的函数叫做[过程](#过程procedure)。源码里面的匿名函数叫做[函数字面量](#函数字面量function-literal)。运行时，函数字面量被实例化为对象，叫做[函数值](#函数值function-value)。

* #### 函数字面量（function literal）
在Scala源码中的无名函数，通过函数字面量语法来特别对待。比如：`(x: Int, y: Int) => x + y`。

* #### 函数值（function value）
可以像其他函数一样被调用的函数对象。函数值的类一般是继承了`scala`包中的`FunctionN`（比如`Function0`，`Function1`等）这类特质的其中之一，且在源码中常通过[函数字面量](#函数字面量function-literal)语法来表示。当函数值的apply方法被调用时就说这个函数值被调用。捕获自由变量的函数值为[闭包](#闭包closure)。

* #### 函数式风格（functional style）
_函数式风格_ 编程注重函数和求值结果而非操作发生的顺序。这种风格的特征是可传递函数值给循环方法、不可变数据、方法无副作用，是像Haskell和Erlang等这些语言的主要范式，与[命令式风格](#命令式风格imperative-style)相对应。

* #### 生成器（generator）
生成器在[for表达式](#for表达式for-expression)中定义一个命名的val变量并赋予其一系列值。比如：`for(i <- 1 to 10)`的生成器是"`i <- 1 to 10`"，`<-`右边的值是[生成器表达式](#生成器表达式generator-expression)。

* #### 生成器表达式（generator expression）
生成器表达式在[for表达式](#for表达式for-expression)中生成一些列值。比如：`for(i <- 1 to 10)`的生成器表达式是"`1 to 10`"。

* #### 泛型类（generic class）
带有类型参数的类。例如，因`scala.List`带一类型参数，故其为泛型类。

* #### 泛型特质（generic trait）
带有类型参数的特质。例如，因`scala.collection.Set`带一类型参数，故其为泛型特质。

* #### 守卫（guard）
参见[过滤器](#过滤器filter).

* #### 辅助函数（helper function）
目的是为一个或多个其他邻近函数提供服务的函数。辅助函数常实现为局部函数。

* #### 辅助方法（helper method）
作为类成员的[辅助函数](#辅助函数helper-function)。辅助方法常为私有方法。

* #### 不可变（immutable）
若对象的值在任何对客户端可见的方式下创建后不会被修改则称对象是 _不可变_ 的。对象既可以是不可变的，也可以是可变的。

* #### 命令式风格（imperative style）
_命令式风格_ 编程强调严谨的操作序列以令效用能在正确的顺序发生。这种风格的特征是循环迭代、适当变更数据、方法有副作用，是像C, C++, C#和Java等这些语言的主要范式，与[函数式风格](#函数式风格functional-style)相对应。

* #### 初始化（initialize）
变量在Scala源码中被定义时，必须用对象对其进行初始化。

* #### 实例（instance）
_实例_ ，或叫类实例，是个对象，是个仅在运行时存在的概念

* #### 实例化（instantiate）
_实例化_ 类是根据类创建一个新对象，是仅在运行时发生的动作。

* #### 不变性（invariant）
_不变性_ 用在两个地方。首先在数据结构组织良好的情况下它可以表示某个属性始终为真。比如，若排序二叉树具有右子节点，则其各节点就会在其右子节点前完成排序，这就属于排序二叉树的不变性。其次有时不变性也作为非协变的同义词，如："类`Array`在类型参数上具备不变性"。

* #### 调用（invoke）
在实参上 _调用_ 方法、函数或闭包，意即其方法体会在指定实参上执行。

* #### Java虚拟机（JVM）
_JVM_ 是Java虚拟机(#runtime)的缩写，或叫[运行时](#运行时runtime)，是运行Scala程序的宿主。

* #### 字面量（literal）
`1`，`"One"`，和`(x: Int) => x + 1`是 _字面量_ 的例子，字面量是描述对象的便捷方式，便捷在这种方式正好反映了所创建对象的结构。

* #### 局部函数（local function）
_局部函数_ 是块内`def`定义的，作为对比，同为`def`定义的作为类、特质或单例对象的成员则被称作[方法](#方法method)。

* #### 局部变量（local variable）
_局部变量_ 是块内`val`或`var`定义的。尽管函数参数和[局部变量](#局部变量local-variable)类似，但并不叫局部变量，而是去掉"局部"直接叫"参数"或"变量"。

* #### 成员（member）
_成员_ 是类、特质或单例对象模板中被命名的元素。成员可通过所有者名称，点及其简名访问。例如，定义在类的最顶层字段和方法是这个类的成员。定义在类中的特质是包围它的类的成员。类中通过type关键字定义的类型是这个类的成员。类是其定义所在的包的成员。相比之下，局部变量或局部函数就不是包围他们的块的成员。

* #### 消息（message）
Actor是通过给彼此之间发送 _消息_ 来进行通信的。发送消息不会打断接收者正在处理的事情，接收者可一直等到当前活动结束且其不变性被重建之后。

* #### 元编程（meta-programming）
元编程程序是指其输入是其自身程序的程序。编译器都是元程序，像`scaladoc`这样的工具也是。要用注解做任何事都需要元编程程序。

* #### 方法（method）
_方法_ 就是类、特质或单例对象的成员函数。

* #### 混入（mixin）
_混入_ 就是特质用在混入组合时的名称。换言之，在"`trait Hat`"里面，`Hat`仅为特质，而"`new Cat extends AnyRef with Hat`"里面的`Hat`就可叫混入。用作动词时，"混"和"入"（"mix in"）是两个词。比如，可 _混_ 特质 _入_ 至类或其他特质。

* #### 混入组合（mixin composition）
把特质混入类或其他特质的过程。_混入组合_ 与传统的多重继承不同之处在于父级引用的类型不是在特质定义时已知的，而是在每次特质每次混入到类或其他特质时才被重新确定。

* #### 修饰符（modifier）
用来以某种方式限定类、特质、字段或方法等的定义的关键字。比如，`private`修饰符表明被定义的类、特质、字段或方法是私有的。

* #### 多重定义（multiple definitions）
通过使用类似这样的语法`val v1, v2, v3 = exp`，同一个表达式根据 _多重定义_ 概念可被赋值给多个变量。

* #### 非协变（nonvariant）
类或特质的类型参数默认是 _非协变_ 的，故而参数变化并不会子类化相应的类或特质。比如，因类`Array`非协变于其类型参数，故`Array[String]`既非`Array[Any]`之子类，亦非其超类。

* #### 操作（operation）
在Scala中，每个 _操作_ 都是一个方法调用。方法也可以 _操作符符号_ 的方式被调用，像在`b + 2`里面符号`+`就是一个 _操作符_。

* #### 参数（parameter）
函数可带有零至多个 _参数_，每个参数都有名称和类型。参数与实参之间的区别在于函数调用时实参指向具体的对象，参数则是指向这些传入实参的变量。

* #### 无参函数（parameterless function）
不带参数的函数，其定义时没有任何空括号。无参函数可不带括号调用，这种方式符合[统一访问原则](#统一访问原则uniform-access-principle)，就是在客户端不改变任何代码的情况下把`def`改成`val`。

* #### 无参方法（parameterless method）
_无参方法_ 就是作为类、特质或单例对象成员的无参函数。

* #### 参数化字段（parametric field）
定义为类参数的字段。

* #### 偏应用函数（部分应用函数）（partially applied function）
用在表达式中，省掉某些参数的函数。例如：若函数`f`的类型为`Int => Int => Int`，则`f`和`f(1)`就是 _偏应用函数_。

* #### 路径依赖类型（path-dependent type）
类似`swiss.cow.Food`的一种类型，`swiss.cow`部分形成一个对象引用的路径。这种类型的含义对于用来访问它的路径是敏感的，比如，`swiss.cow.Food`和`fish.Food`这两个是不同的类型。

* #### 模式（pattern）
在`match`表达式的某个备选项中，_模式_ 跟在`case`关键字后，先于 _模式守卫_ 或`=>`符号二者之一。

* #### 模式守卫（pattern guard）
在`match`表达式的某个备选项中，_模式守卫_ 可跟在某个[模式](#模式pattern)后面。比如，"`case x if x % 2 == 0 => x + 1`"中的模式守卫为"`if x % 2 == 0`"。带有模式守卫的备选项（case）仅当其模式匹配了并且模式守卫为真的时候才会被选中。

* #### 断言（predicate）
断言是结果类型为`Boolean`的函数。

* #### 主构造器（primary constructor）
类的主要构造器，会调用超类构造器，如果有必要，也会初始化字段进行传值，并且会执行类的花括号内定义的的顶层（top-level）代码。字段仅由不传给超类构造器的值参数做初始化，那些类构造体内因未用到而被优化掉的除外。

* #### 过程（procedure）
_过程_ 是结果类型为`Unit`的函数，其存在的理由仅为产生副作用。

* #### 可重新赋值（reassignable）
变量可以是可重新赋值的，也可以不是可重新赋值的。`var`是可重新赋值的，而`val`则不是。

* #### 递归的（recursive）
若函数可调用自身就说它是 _递归的_。若函数调用自身的唯一位置是函数的最后一个表达式，则函数是[尾递归](#尾递归tail-recursive)的。

* #### 引用（reference）
_引用_ 是指针的Java抽象，可唯一确定存在JVM堆中的对象。引用类型变量持有对象的引用，因为引用类型（`AnyRef`的实例）是存在JVM堆上的Java对象实现的。相比之下，值类型变量有时会持有一个（装箱类型的）引用，也有时（当对象表示基础类型值的时候）不会。一般说来，Scala变量[指向](#指向refers)对象。术语"指向"比"持有引用"更加抽象。如果类型为`scala.Int`的变量当前代表Java基础类型`int`的值，则这个变量仍然指向`Int`对象，但并不涉及任何引用。

* #### 引用相等性（reference equality）
_引用相等性_ 意思是两个引用指向同一个Java对象。引用相等性仅针对引用类型有意义，是可以通过调用`AnyRef`中的`eq`来确定的（在Java程序中，引用相等性通过在Java[引用类型](#引用类型reference-type)上调用`==`来确定）。

* #### 引用类型（reference type）
_引用类型_ 是`AnyRef`的子类。在运行时，引用类型的实例常驻JVM堆中。

* #### 引用透明（referential transparency）
独立于临时上下文且无副作用的函数属性。对于特定输入，引用透明函数的调用可由其结果替换而不改变程序语义。

* #### 指向（refers）
运行的Scala程序中的变量常 _指向_ 某个对象。变量即使被赋为`null`，概念上也是指向`Null`对象。在运行时，对象可由Java对象或基础类型值来实现，不过Scala允许程序员在更高层次抽象代码以他们设想的方式运行。参见[引用](#引用reference).

* #### 精化类型（refinement type）
通过提供基础类型及其构造体花括号内若干成员而形成的类型。花括号内的成员精细化了基础类型所体现的类型。比如，"食草动物"（animal that eats grass）的类型为`Animal { type SuitableFood = Grass }`。
A type formed by supplying a base type a number of members inside curly braces. The members in the curly braces refine the types that are present in the base type. For example, the type of “animal that eats grass” is `Animal { type SuitableFood = Grass }`.

* #### 结果（result）
Scala程序中的表达式会产生 _结果_。Scala中的每个表达式的结果都是对象。

* #### 结果类型（result type）
方法的 _结果类型_ 是调用方法所产生的值的类型。（在Java中，这个概念被称为返回类型）

* #### 返回（return）
Scala程序中的函数会 _返回_ 值，可把这个值叫做函数的[结果](#结果result)。也可以说函数 _结果是_ 某个值。Scala中的每个函数结果都是一个对象。

* #### 运行时（runtime）
正在运行Scala程序的宿主Java虚拟机，或宿主[JVM](#java虚拟机jvm)。运行时这个概念包含了Java虚拟机规范中定义的虚拟机以及Java API和标准Scala API的运行时库。在运行时的这个阶段，意味着程序正在运行中，与编译时是相对的概念。

* #### 运行时类型（runtime type）
对象在运行时的类型。相比之下，[静态类型](#静态类型static-type)指的是表达式在编译时的类型。多数运行时类型都是无类型参数的裸类，比如，`"Hi"`的运行时类型是`String`，`(x: Int) => x + 1`的运行时类型是`Function1`。运行时类型可通过`isInstanceOf`来检测。

* #### 脚本（script）
包含顶层定义和语句，可直接通过`scala`命令来跑而无需显式编译的文件就是脚本，脚本结尾必须是表达式，而不能是定义。

* #### 选择器（selector）
`match`表达式中被匹配的值。比如，在"`s match { case _ => }`"中，选择器是`s`。

* #### 自身类型（self type）
特质的 _自身类型_ 是特质中用到的接收者`this`的假想类型。任何混入特质的具体类必须要确保其类型符合特质的自身类型。自身类型常被用来把大类分解为若干个特质（[Programming in Scala](https://www.artima.com/shop/programming_in_scala)第29章有述）。

* #### 半结构化数据（semi-structured data）
XML数据就是半结构化的，因其相比于普通的二进制文件或文本文件更加结构化，而又不像编程语言的数据结构具备完全结构化。

* #### 序列化（serialization）
可把对象 _序列化_ 成字节流，以便将其保存至文件或通过网络传输。之后可对字节流进行 _反序列化_ （可发生在不同计算机上）来获取和原始被序列化的对象一样的对象。

* #### 遮掩（shadow）
局部变量的重新声明会 _遮掩_ 作用域内相同名称的变量声明。

* #### 签名（signature）
_签名_ 是[类型签名](#类型签名type-signature)的简写。

* #### 单例对象（singleton object）
由object关键字定义的对象。每个单例对象有且仅有一个实例。与某个类共享名称且与这个类定义在同一源文件中的单例对象，叫这个类的[伴生对象](#伴生对象companion-object)，类则叫单列对象的[伴生类](#伴生类companion-class)。无伴随类的单例对象叫[独立对象](#独立对象standalone-object)。

* #### 独立对象（standalone object）
没有[伴生类](#伴生类companion-class)的[单例对象](#单例对象singleton-object)。

* #### 语句（statement）
指的是表达式、定义或包导入等这些可放到Scala源码的模板或块中的东西。

* #### 静态类型（static type）
参见[类型](#类型type)。

* #### 结构类型（structural type）
也是一种[精化类型](#精化类型refinement-type)，只是精化的目标是未在基类型中的成员。比如`{ def close(): Unit }`就是结构类型，因其基类型是`AnyRef`，而`AnyRef`并无名为`close`的成员。

* #### 子类（subclass）
一个类是其所有[超类](#超类superclass)和[超特质](#超特质supertrait)的 _子类_。

* #### 子特质（subtrait）
一个特质是其所有[超特质](#超特质supertrait)的 _子特质_。

* #### 子类型（subtype）
Scala编译器允许任何类型在需要该类型的地方使用其 _子类型_ 作为替代。对不带类型参数的类和特质来说，子类型的关系会反映子类的关系。比如，若类`Cat`是抽象类`Animal`的子类，且也不带类型参数，则类型`Cat`就是类型`Animal`的子类型。同样，若特质`Apple`是特质`Fruit`的子特质且无类型参数，则类型`Apple`就是类型`Fruit`的子类型。而对于带有类型参数的类和特质来说，协变就起作用了。比如，由于抽象类`List`被声明为在其长类型参数上是协变的（例，`List`被声明为`List[+A]`），`List[Cat]`是`List[Animal]`的子类型，`List[Apple]`是`List[Fruit]`的子类型。尽管这些类型的类都是`List`，但其子类型的关系依旧是存在的。对比来看，因为`Set`未被声明在其类型参数上是协变的（例，`Set`被声明为`Set[A]`，不带加号），所以`Set[Cat]`并不是`Set[Animal]`的子类型。子类型应该正确实现其超类型的契约，以便应用里氏替换原则（Liskov Substitution Principle），不过编译器仅会在类型检查级别核验此属性。

* #### 超类（superclass）
一个类的 _超类_ 包括其直接超类，其直接超类的直接超类，等等一直到`Any`。

* #### 超特质（supertrait）
类或特质的 _超特质_，如果有的话，就包括所有直接混入类或特质或其任意超类的特质，以及这些特质的所有超特质。

* #### 超类型（supertype）
类型是其所有子类型的 _超类型_。

* #### 合成类（synthetic class）
合成类是编译器自动生成的而不是程序员手写的。

* #### 尾递归（tail recursive）
函数是 _尾递归_ 的，仅当函数调用自身的地方是函数的最后一条操作。

* #### 目标类型化（target typing）
_目标类型化_ 是参考所需类型来进行类型推导的一种形式。比如在`nums.filter((x) => x > 0)`中，Scala编译器能推导出`x`的类型是`nums`的元素类型，因为`filter`方法会在`nums`的每个元素上调用函数。

* #### 模板（template）
_模板_ 是类、特质或单例对象定义体，它定义了类、特质或对象的类型签名，行为以及初始状态。

* #### 特质（trait）
_特质_ 通过`trait`关键字定义，是像抽象类一样不带任何值参数，并且可通过被称为[混入组合](#混入组合mixin-composition)的过程"混入到"类或其他特质。当某个特质被混入到其他类或特质，它就被叫做[混入](#混入mixin)。特质可通过一个或多个类型参数化。用类型来参数化后，特质就形成了类型。比如，`Set`是带有单类型参数的特质，而`Set[Int]`却是一个类型。`Set`也被说成是类型`Set[Int]`的"特质"。

* #### 类型（type）
Scala程序中每个变量和表达式都有编译时确定的 _类型_。类型可以在运行时限定变量能指向的值和表达式所能产生的值。如果有必要从对象的[运行时类型](#运行时类型runtime-type)的角度对变量和表达式的类型进行区分的话，他们也被称为 _静态类型_。换句话说，"类型"这个词本身意味着静态类型。类型与类是区分开的因为带有类型参数的类可以构成许多类型。比如，`List`是类不是类型，`List[T]`则是一个带有自由类型参数的类型，`List[Int]`和`List[String]`也是类型（称为实类型因为他们没有自由类型参数）。类型可以有"[类](#类class)"或"[特质](#特质trait)"，比如类型`List[Int]`的类是`List`，类型`Set[String]`的特质是`Set`。

* #### 类型约束（type constraint）
有些[注解](#注解annotation)是 _类型约束_，意味着他们会对类型能够包含的取值增加额外的限制或约束。比如，`@positive`可以是类型`Int`的类型约束，用来限制32位整型的取值为正的整数。类型约束虽然不会被标准Scala编译器检查，但相应的必须可被额外的工具或编译器插件检查。

* #### 类型构造器（type constructor）
带类型参数的类或特质。

* #### 类型参数（type parameter）
必须被填入类型的泛型类或泛型方法的参数。比如，类`List`定义为"`class List[T] { . . . `"，对象`Predef`的一个成员方法`identity`定义为"`def identity[T](x:T) = x`"，二者定义中的`T`就是类型参数。

* #### 类型签名（type signature）
方法的 _类型签名_ 包括名称，参数（如果有的话）的数量、顺序和类型，以及结果类型。类、特质或单例对象的类型签名包括名称，所有成员和构造器的类型签名，及其声明的继承和混入关系。

* #### 统一访问原则（uniform access principle）
_统一访问原则_ 指的是变量和无参函数应以相同的语法来访问。Scala通过不允许在无参函数的调用点放置括号来支持该原则。这样的话，无参函数定义就可以改成`val`而不影响客户端代码，_反之亦然_。

* #### 不可达（unreachable）
在Scala层面，对象可以是 _不可达_ 的，此时其所占据的内存可被运行时回收。不可达并不一定意味着未被引用。引用类型（`AnyRef`的实例）被实现为驻于JVM堆上的对象。当引用类型的实例不可达后，它也确实不被引用了，且可被垃圾回收。值类型（`AnyVal`的实例）可被实现为驻于堆中的基础类型值或Java包装类型实例（如`java.lang.Integer`）。值类型实例可在指向他们的变量的整个生命周期内被装箱（从基础类型值转成包装类型对象）或拆箱（从包装类型对象转成基础类型值）。若表现为JVM堆上的包装类型对象的值类型实例不可达，那就确实不会被引用并且可被垃圾回收。但是若正在表现为基础类型值的值类型不可达，则其仍可被引用，因为此时它并不会以作为对象驻于JVM堆上。运行时可回收不可达对象所占据的内存，但是假如一个Int在运行时被实现为Java基础类型int，在一个运行中的方法的栈帧上占据了一些内存，则这个对象的内存将在方法运行完成且栈帧弹出时才被回收。引用类型的内存，比如`Strings`，可在不可达之后由JVM的垃圾收集器回收。

* #### 未引用（unreferenced）
参见[不可达](#不可达unreachable)。

* #### 值（value）
Scala中的任何计算或表达式的结果都是一个 _值_，而Scala中的每个值都是一个对象。值这个术语本质上是指对象在内存中（在JVM堆或栈上）的镜像。

* #### 值类型（value type）
_值类型_ 是`AnyVal`的任意子类，像`Int`，`Double`或`Unit`。该术语具有Scala源码级别的意味。在运行时，对应于Java基础类型的值类型实例可由基础类型值或包装类型实例来实现，比如`java.lang.Integer`。在值类型实例的整个生命周期内，运行时可将其在基础类型和包装类型间来回转换（如，对其装箱和拆箱）。

* #### 变量（variable）
指向对象的命名实体。变量要么是`val`，要么是 `var`，`val`变量和`var`变量在定义时都必须被初始化，但仅`var`变量可被重新赋值来指向不同对象。

* #### 型变（variance）
类或特质的类型参数可用 _型变_ 标号来做标记，即[协变](#协变covariant)（+）或[逆变](#逆变contravariant)（-）。这样的型变标号表明了泛型类或特质的子类化是如何开展的，比如，泛型类`List`在其类型参数上是协变的，因此`List[String]`就是`List[Any]`的子类型。默认情况下，即缺少标号`+`或`-`的类型参数是[非协变](#非协变nonvariant)的。

* #### 产生（yield）
表达式可以 _产生_ 结果。`yield`关键字指定了[for推解式](#for推解式for-comprehension)的结果。
