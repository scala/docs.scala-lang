
<!DOCTYPE html>
<html>
  <head>

    <title>A Scala Tutorial for Java Programmers - Scala Documentation</title>
    
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>

    <link rel="icon" type="image/png" href="/resources/favicon.ico">

    <!-- prettify js and CSS -->
    <link rel="stylesheet" href="/resources/stylesheets/prettify.css" type="text/css" />
    <script src="/resources/javascript/prettify/prettify.js" type="text/javascript" ></script>


    <!-- jquery js -->
    <script src="/resources/javascript/jquery.js" type="text/javascript" ></script>
    <script src="/resources/javascript/effects.core.js" type="text/javascript" ></script>
    <script src="/resources/javascript/effects.highlight.js" type="text/javascript" ></script>
    <script src="/resources/javascript/moveScroller.js" type="text/javascript" ></script>

    <!-- Bootstrap JS and CSS -->
    <link rel="stylesheet" href="/resources/stylesheets/bootstrap.css" type="text/css" />
	  <script src="/resources/javascript/bootstrap-dropdown.js" type="text/javascript" ></script>
	  <script src="/resources/javascript/bootstrap-dropdown-app.js" type="text/javascript" ></script>

    <!-- Base stylesheet for all pages -->
    <link rel="stylesheet" href="/resources/stylesheets/base.css" type="text/css" />

    <!-- table of contents js -->
    <script src="/resources/javascript/toc.js" type="text/javascript" ></script>

    <!-- google analytics -->
	<script type="text/javascript">

	  var _gaq = _gaq || [];
	  _gaq.push(['_setAccount', 'UA-574683-5']);
	  _gaq.push(['_trackPageview']);

	  (function() {
	    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
	    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
	    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
	  })();

	</script>

    <!-- prettyprint js to prepend generated pre/code tags -->
    <script type="text/javascript">
      function styleCode()
        {
          if (typeof disableStyleCode != "undefined")
          {
              return;
          }
          var a = false;
          $("pre code").parent().each(function()
          {
              if (!$(this).hasClass("prettyprint"))
              {
                  $(this).addClass("prettyprint lang-scala linenums");
                  a = true
              }
          });
          if (a) { prettyPrint() }
      }
    </script>

    <script type="text/javascript">
      jQuery(document).ready(function($) {

            $(".scroll").click(function(event){
              event.preventDefault();
              $('html,body').animate({scrollTop:$(this.hash).offset().top}, 500);
              $('html,body').animate({scrollTop:$(this.hash).offset().top-=50}, 500);
              $(this.hash).effect("highlight", {color: "#FFCC85"}, 3000);
            });
      });
    </script>

    <script type="text/javascript">
      $(window).ready(function goToSubsection() {
          if (window.location.hash)
          {
              $('html,body').animate({scrollTop:$(window.location.hash).offset().top}, 500);
              $('html,body').animate({scrollTop:$(window.location.hash).offset().top-=50}, 500);
              $(window.location.hash).effect("highlight", {color: "#FFCC85"}, 3000);
          }
        });
    </script>

    <style type="text/css">

       p.contents {
           margin-left: 15px;
           font-weight: bold;
           font-size: 16px;
       }

       div#toc ul {
           list-style: none;
       }

       div#toc ul a {
           display: block;
           list-style: none;
           line-height: 22px;
           font-weight: bold;
           width: 100%;
       }

      div#toc ul li ul {
           list-style: disc;
      }

      div#toc ul li ul a {
           line-height: 18px;
           font-weight: normal;
      }

      div#toc ul li ul li ul {
           list-style: square;
      }
       div#toc ul li ul li ul a {
       }

       div#scroller-anchor {
           width: inherit;
       }

       div#scroller {
           width: inherit;
       }

       div#guide-title {
        text-transform: capitalize;
        font-size: 16px;
        padding-bottom: 6px;
        color: #BFBFBF;
        text-transform: uppercase;
        font-weight: bold;
       }

       input, textarea, select, .uneditable-input {
	       width: 165px;
	     }

    </style>

</head>
  <body onload="styleCode()">

    <!-- Topbar
    ================================================== -->
<div class="topbar">
    <div class="topbar-inner">
        <div class="container">
            <a class="brand" href="/index.html"><img src="/resources/images/scala-logo.png"> Documentation</a>
            <ul class="nav">

                <li class="menu">
                      <a href="#" class="menu">API</a>
                      <ul class="menu-dropdown">
                        <li><a href="http://www.scala-lang.org/api/current/">Current</a></li>
                        <li><a href="http://www.scala-lang.org/archives/downloads/distrib/files/nightly/docs/library/index.html">Nightly</a></li>
                        <!--<li class="divider"></li>
                        <li><a href="#">Previous Versions</a></li>
                        -->
                      </ul>
                </li>

                <li class="menu">
                      <a href="#" class="menu">Learn</a>
                      <ul class="menu-dropdown">
                        <li><a href="/overviews">Guides & Overviews</a></li>
                        <li><a href="/tutorials">Tutorials</a></li>
                        <li><a href="/style">Scala Style Guide</a></li>
                      </ul>
                </li>

                <li class="menu">
                      <a href="#" class="menu">Quickref</a>
                      <ul class="menu-dropdown">
                        <li><a href="/glossary">Glossary</a></li>
                        <li><a href="/cheatsheets">Cheatsheets</a></li>
                      </ul>
                </li>

                <li><a href="/contribute.html">Contribute</a></li>
                <li><a href="/sips">SIPs</a></li>
                <li><a href="http://wiki.scala-lang.org">Wiki</a></li>
          </ul>
          <form method="get" id="searchform" action="/search.html">
            <input type="text" placeholder="Search"  class="field" name="q" id="q"/>
          </form>
           </li>
          </ul>
        </div>
    </div>
</div>

<div class="container">
  <div class="row">
    
    <div class="span10"><h1>A Scala Tutorial for Java Programmers</h1></div>

    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    

    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
        
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    

    
      
    

    <div class="span6">
      
        <a href="/tutorials/scala-for-java-programmers.html"><img src="/resources/images/language/en.png" title="Language: en"/></a> 
        
          <a href="/es/tutorials/scala-for-java-programmers.html"><img src="/resources/images/language/es.png" title="Language: es"/></a> 
        
          <a href="/ko/tutorials/scala-for-java-programmers.html"><img src="/resources/images/language/ko.png" title="Language: ko"/></a> 
        
          <a href="/de/tutorials/scala-for-java-programmers.html"><img src="/resources/images/language/de.png" title="Language: de"/></a> 
        
      
    </div>

    <div class="span10">
      <p>By Michel Schinz and Philipp Haller</p>

<h2 id='introduction'>Introduction</h2>

<p>This document gives a quick introduction to the Scala language and compiler. It is intended for people who already have some programming experience and want an overview of what they can do with Scala. A basic knowledge of object-oriented programming, especially in Java, is assumed.</p>

<h2 id='a_first_example'>A First Example</h2>

<p>As a first example, we will use the standard <em>Hello world</em> program. It is not very fascinating but makes it easy to demonstrate the use of the Scala tools without knowing too much about the language. Here is how it looks:</p>

<pre><code>object HelloWorld {
  def main(args: Array[String]) {
    println(&quot;Hello, world!&quot;)
  }
}</code></pre>

<p>The structure of this program should be familiar to Java programmers: it consists of one method called <code>main</code> which takes the command line arguments, an array of strings, as parameter; the body of this method consists of a single call to the predefined method <code>println</code> with the friendly greeting as argument. The <code>main</code> method does not return a value (it is a procedure method). Therefore, it is not necessary to declare a return type.</p>

<p>What is less familiar to Java programmers is the <code>object</code> declaration containing the <code>main</code> method. Such a declaration introduces what is commonly known as a <em>singleton object</em>, that is a class with a single instance. The declaration above thus declares both a class called <code>HelloWorld</code> and an instance of that class, also called <code>HelloWorld</code>. This instance is created on demand, the first time it is used.</p>

<p>The astute reader might have noticed that the <code>main</code> method is not declared as <code>static</code> here. This is because static members (methods or fields) do not exist in Scala. Rather than defining static members, the Scala programmer declares these members in singleton objects.</p>

<h3 id='compiling_the_example'>Compiling the example</h3>

<p>To compile the example, we use <code>scalac</code>, the Scala compiler. <code>scalac</code> works like most compilers: it takes a source file as argument, maybe some options, and produces one or several object files. The object files it produces are standard Java class files.</p>

<p>If we save the above program in a file called <code>HelloWorld.scala</code>, we can compile it by issuing the following command (the greater-than sign <code>&gt;</code> represents the shell prompt and should not be typed):</p>

<pre><code>&gt; scalac HelloWorld.scala</code></pre>

<p>This will generate a few class files in the current directory. One of them will be called <code>HelloWorld.class</code>, and contains a class which can be directly executed using the <code>scala</code> command, as the following section shows.</p>

<h3 id='running_the_example'>Running the example</h3>

<p>Once compiled, a Scala program can be run using the <code>scala</code> command. Its usage is very similar to the <code>java</code> command used to run Java programs, and accepts the same options. The above example can be executed using the following command, which produces the expected output:</p>

<pre><code>&gt; scala -classpath . HelloWorld

Hello, world!</code></pre>

<h2 id='interaction_with_java'>Interaction with Java</h2>

<p>One of Scala&#8217;s strengths is that it makes it very easy to interact with Java code. All classes from the <code>java.lang</code> package are imported by default, while others need to be imported explicitly.</p>

<p>Let&#8217;s look at an example that demonstrates this. We want to obtain and format the current date according to the conventions used in a specific country, say France. (Other regions such as the French-speaking part of Switzerland use the same conventions.)</p>

<p>Java&#8217;s class libraries define powerful utility classes, such as <code>Date</code> and <code>DateFormat</code>. Since Scala interoperates seemlessly with Java, there is no need to implement equivalent classes in the Scala class library&#8211;we can simply import the classes of the corresponding Java packages:</p>

<pre><code>import java.util.{Date, Locale}
import java.text.DateFormat
import java.text.DateFormat._

object FrenchDate {
  def main(args: Array[String]) {
    val now = new Date
    val df = getDateInstance(LONG, Locale.FRANCE)
    println(df format now)
  }
}</code></pre>

<p>Scala&#8217;s import statement looks very similar to Java&#8217;s equivalent, however, it is more powerful. Multiple classes can be imported from the same package by enclosing them in curly braces as on the first line. Another difference is that when importing all the names of a package or class, one uses the underscore character (<code>_</code>) instead of the asterisk (<code>*</code>). That&#8217;s because the asterisk is a valid Scala identifier (e.g. method name), as we will see later.</p>

<p>The import statement on the third line therefore imports all members of the <code>DateFormat</code> class. This makes the static method <code>getDateInstance</code> and the static field <code>LONG</code> directly visible.</p>

<p>Inside the <code>main</code> method we first create an instance of Java&#8217;s <code>Date</code> class which by default contains the current date. Next, we define a date format using the static <code>getDateInstance</code> method that we imported previously. Finally, we print the current date formatted according to the localized <code>DateFormat</code> instance. This last line shows an interesting property of Scala&#8217;s syntax. Methods taking one argument can be used with an infix syntax. That is, the expression</p>

<pre><code>df format now</code></pre>

<p>is just another, slightly less verbose way of writing the expression</p>

<pre><code>df.format(now)</code></pre>

<p>This might seem like a minor syntactic detail, but it has important consequences, one of which will be explored in the next section.</p>

<p>To conclude this section about integration with Java, it should be noted that it is also possible to inherit from Java classes and implement Java interfaces directly in Scala.</p>

<h2 id='everything_is_an_object'>Everything is an Object</h2>

<p>Scala is a pure object-oriented language in the sense that <em>everything</em> is an object, including numbers or functions. It differs from Java in that respect, since Java distinguishes primitive types (such as <code>boolean</code> and <code>int</code>) from reference types, and does not enable one to manipulate functions as values.</p>

<h3 id='numbers_are_objects'>Numbers are objects</h3>

<p>Since numbers are objects, they also have methods. And in fact, an arithmetic expression like the following:</p>

<pre><code>1 + 2 * 3 / x</code></pre>

<p>consists exclusively of method calls, because it is equivalent to the following expression, as we saw in the previous section:</p>

<pre><code>(1).+(((2).*(3))./(x))</code></pre>

<p>This also means that <code>+</code>, <code>*</code>, etc. are valid identifiers in Scala.</p>

<p>The parentheses around the numbers in the second version are necessary because Scala&#8217;s lexer uses a longest match rule for tokens. Therefore, it would break the following expression:</p>

<pre><code>1.+(2)</code></pre>

<p>into the tokens <code>1.</code>, <code>+</code>, and <code>2</code>. The reason that this tokenization is chosen is because <code>1.</code> is a longer valid match than <code>1</code>. The token <code>1.</code> is interpreted as the literal <code>1.0</code>, making it a <code>Double</code> rather than an <code>Int</code>. Writing the expression as:</p>

<pre><code>(1).+(2)</code></pre>

<p>prevents <code>1</code> from being interpreted as a <code>Double</code>.</p>

<h3 id='functions_are_objects'>Functions are objects</h3>

<p>Perhaps more surprising for the Java programmer, functions are also objects in Scala. It is therefore possible to pass functions as arguments, to store them in variables, and to return them from other functions. This ability to manipulate functions as values is one of the cornerstone of a very interesting programming paradigm called <em>functional programming</em>.</p>

<p>As a very simple example of why it can be useful to use functions as values, let&#8217;s consider a timer function whose aim is to perform some action every second. How do we pass it the action to perform? Quite logically, as a function. This very simple kind of function passing should be familiar to many programmers: it is often used in user-interface code, to register call-back functions which get called when some event occurs.</p>

<p>In the following program, the timer function is called <code>oncePerSecond</code>, and it gets a call-back function as argument. The type of this function is written <code>() =&gt; Unit</code> and is the type of all functions which take no arguments and return nothing (the type <code>Unit</code> is similar to <code>void</code> in C/C++). The main function of this program simply calls this timer function with a call-back which prints a sentence on the terminal. In other words, this program endlessly prints the sentence &#8220;time flies like an arrow&#8221; every second.</p>

<pre><code>object Timer {
  def oncePerSecond(callback: () =&gt; Unit) {
    while (true) { callback(); Thread sleep 1000 }
  }
  def timeFlies() {
    println(&quot;time flies like an arrow...&quot;)
  }
  def main(args: Array[String]) {
    oncePerSecond(timeFlies)
  }
}</code></pre>

<p>Note that in order to print the string, we used the predefined method <code>println</code> instead of using the one from <code>System.out</code>.</p>

<h4 id='anonymous_functions'>Anonymous functions</h4>

<p>While this program is easy to understand, it can be refined a bit. First of all, notice that the function <code>timeFlies</code> is only defined in order to be passed later to the <code>oncePerSecond</code> function. Having to name that function, which is only used once, might seem unnecessary, and it would in fact be nice to be able to construct this function just as it is passed to <code>oncePerSecond</code>. This is possible in Scala using <em>anonymous functions</em>, which are exactly that: functions without a name. The revised version of our timer program using an anonymous function instead of <em>timeFlies</em> looks like that:</p>

<pre><code>object TimerAnonymous {
  def oncePerSecond(callback: () =&gt; Unit) {
    while (true) { callback(); Thread sleep 1000 }
  }
  def main(args: Array[String]) {
    oncePerSecond(() =&gt;
      println(&quot;time flies like an arrow...&quot;))
  }
}</code></pre>

<p>The presence of an anonymous function in this example is revealed by the right arrow <code>=&gt;</code> which separates the function&#8217;s argument list from its body. In this example, the argument list is empty, as witnessed by the empty pair of parenthesis on the left of the arrow. The body of the function is the same as the one of <code>timeFlies</code> above.</p>

<h2 id='classes'>Classes</h2>

<p>As we have seen above, Scala is an object-oriented language, and as such it has a concept of class. (For the sake of completeness, it should be noted that some object-oriented languages do not have the concept of class, but Scala is not one of them.) Classes in Scala are declared using a syntax which is close to Java&#8217;s syntax. One important difference is that classes in Scala can have parameters. This is illustrated in the following definition of complex numbers.</p>

<pre><code>class Complex(real: Double, imaginary: Double) {
  def re() = real
  def im() = imaginary
}</code></pre>

<p>This complex class takes two arguments, which are the real and imaginary part of the complex. These arguments must be passed when creating an instance of class <code>Complex</code>, as follows: <code>new
  Complex(1.5, 2.3)</code>. The class contains two methods, called <code>re</code> and <code>im</code>, which give access to these two parts.</p>

<p>It should be noted that the return type of these two methods is not given explicitly. It will be inferred automatically by the compiler, which looks at the right-hand side of these methods and deduces that both return a value of type <code>Double</code>.</p>

<p>The compiler is not always able to infer types like it does here, and there is unfortunately no simple rule to know exactly when it will be, and when not. In practice, this is usually not a problem since the compiler complains when it is not able to infer a type which was not given explicitly. As a simple rule, beginner Scala programmers should try to omit type declarations which seem to be easy to deduce from the context, and see if the compiler agrees. After some time, the programmer should get a good feeling about when to omit types, and when to specify them explicitly.</p>

<h3 id='methods_without_arguments'>Methods without arguments</h3>

<p>A small problem of the methods <code>re</code> and <code>im</code> is that, in order to call them, one has to put an empty pair of parenthesis after their name, as the following example shows:</p>

<pre><code>object ComplexNumbers {
  def main(args: Array[String]) {
    val c = new Complex(1.2, 3.4)
    println(&quot;imaginary part: &quot; + c.im())
  }
}</code></pre>

<p>It would be nicer to be able to access the real and imaginary parts like if they were fields, without putting the empty pair of parenthesis. This is perfectly doable in Scala, simply by defining them as methods <em>without arguments</em>. Such methods differ from methods with zero arguments in that they don&#8217;t have parenthesis after their name, neither in their definition nor in their use. Our <code>Complex</code> class can be rewritten as follows:</p>

<pre><code>class Complex(real: Double, imaginary: Double) {
  def re = real
  def im = imaginary
}</code></pre>

<h3 id='inheritance_and_overriding'>Inheritance and overriding</h3>

<p>All classes in Scala inherit from a super-class. When no super-class is specified, as in the <code>Complex</code> example of previous section, <code>scala.AnyRef</code> is implicitly used.</p>

<p>It is possible to override methods inherited from a super-class in Scala. It is however mandatory to explicitly specify that a method overrides another one using the <code>override</code> modifier, in order to avoid accidental overriding. As an example, our <code>Complex</code> class can be augmented with a redefinition of the <code>toString</code> method inherited from <code>Object</code>.</p>

<pre><code>class Complex(real: Double, imaginary: Double) {
  def re = real
  def im = imaginary
  override def toString() =
    &quot;&quot; + re + (if (im &lt; 0) &quot;&quot; else &quot;+&quot;) + im + &quot;i&quot;
}</code></pre>

<h2 id='case_classes_and_pattern_matching'>Case Classes and Pattern Matching</h2>

<p>A kind of data structure that often appears in programs is the tree. For example, interpreters and compilers usually represent programs internally as trees; XML documents are trees; and several kinds of containers are based on trees, like red-black trees.</p>

<p>We will now examine how such trees are represented and manipulated in Scala through a small calculator program. The aim of this program is to manipulate very simple arithmetic expressions composed of sums, integer constants and variables. Two examples of such expressions are <code>1+2</code> and <code>(x+x)+(7+y)</code>.</p>

<p>We first have to decide on a representation for such expressions. The most natural one is the tree, where nodes are operations (here, the addition) and leaves are values (here constants or variables).</p>

<p>In Java, such a tree would be represented using an abstract super-class for the trees, and one concrete sub-class per node or leaf. In a functional programming language, one would use an algebraic data-type for the same purpose. Scala provides the concept of <em>case classes</em> which is somewhat in between the two. Here is how they can be used to define the type of the trees for our example:</p>

<pre><code>abstract class Tree
case class Sum(l: Tree, r: Tree) extends Tree
case class Var(n: String) extends Tree
case class Const(v: Int) extends Tree</code></pre>

<p>The fact that classes <code>Sum</code>, <code>Var</code> and <code>Const</code> are declared as case classes means that they differ from standard classes in several respects:</p>

<ul>
<li>the <code>new</code> keyword is not mandatory to create instances of these classes (i.e., one can write <code>Const(5)</code> instead of <code>new Const(5)</code>),</li>

<li>getter functions are automatically defined for the constructor parameters (i.e., it is possible to get the value of the <code>v</code> constructor parameter of some instance <code>c</code> of class <code>Const</code> just by writing <code>c.v</code>),</li>

<li>default definitions for methods <code>equals</code> and <code>hashCode</code> are provided, which work on the <em>structure</em> of the instances and not on their identity,</li>

<li>a default definition for method <code>toString</code> is provided, and prints the value in a &#8220;source form&#8221; (e.g., the tree for expression <code>x+1</code> prints as <code>Sum(Var(x),Const(1))</code>),</li>

<li>instances of these classes can be decomposed through <em>pattern matching</em> as we will see below.</li>
</ul>

<p>Now that we have defined the data-type to represent our arithmetic expressions, we can start defining operations to manipulate them. We will start with a function to evaluate an expression in some <em>environment</em>. The aim of the environment is to give values to variables. For example, the expression <code>x+1</code> evaluated in an environment which associates the value <code>5</code> to variable <code>x</code>, written <code>{ x -&gt; 5 }</code>, gives <code>6</code> as result.</p>

<p>We therefore have to find a way to represent environments. We could of course use some associative data-structure like a hash table, but we can also directly use functions! An environment is really nothing more than a function which associates a value to a (variable) name. The environment <code>{ x -&gt; 5 }</code> given above can simply be written as follows in Scala:</p>

<pre><code>{ case &quot;x&quot; =&gt; 5 }</code></pre>

<p>This notation defines a function which, when given the string <code>&quot;x&quot;</code> as argument, returns the integer <code>5</code>, and fails with an exception otherwise.</p>

<p>Before writing the evaluation function, let us give a name to the type of the environments. We could of course always use the type <code>String =&gt; Int</code> for environments, but it simplifies the program if we introduce a name for this type, and makes future changes easier. This is accomplished in Scala with the following notation:</p>

<pre><code>type Environment = String =&gt; Int</code></pre>

<p>From then on, the type <code>Environment</code> can be used as an alias of the type of functions from <code>String</code> to <code>Int</code>.</p>

<p>We can now give the definition of the evaluation function. Conceptually, it is very simple: the value of a sum of two expressions is simply the sum of the value of these expressions; the value of a variable is obtained directly from the environment; and the value of a constant is the constant itself. Expressing this in Scala is not more difficult:</p>

<pre><code>def eval(t: Tree, env: Environment): Int = t match {
  case Sum(l, r) =&gt; eval(l, env) + eval(r, env)
  case Var(n)    =&gt; env(n)
  case Const(v)  =&gt; v
}</code></pre>

<p>This evaluation function works by performing <em>pattern matching</em> on the tree <code>t</code>. Intuitively, the meaning of the above definition should be clear:</p>

<ol>
<li>it first checks if the tree <code>t</code> is a <code>Sum</code>, and if it is, it binds the left sub-tree to a new variable called <code>l</code> and the right sub-tree to a variable called <code>r</code>, and then proceeds with the evaluation of the expression following the arrow; this expression can (and does) make use of the variables bound by the pattern appearing on the left of the arrow, i.e., <code>l</code> and <code>r</code>,</li>

<li>if the first check does not succeed, that is, if the tree is not a <code>Sum</code>, it goes on and checks if <code>t</code> is a <code>Var</code>; if it is, it binds the name contained in the <code>Var</code> node to a variable <code>n</code> and proceeds with the right-hand expression,</li>

<li>if the second check also fails, that is if <code>t</code> is neither a <code>Sum</code> nor a <code>Var</code>, it checks if it is a <code>Const</code>, and if it is, it binds the value contained in the <code>Const</code> node to a variable <code>v</code> and proceeds with the right-hand side,</li>

<li>finally, if all checks fail, an exception is raised to signal the failure of the pattern matching expression; this could happen here only if more sub-classes of <code>Tree</code> were declared.</li>
</ol>

<p>We see that the basic idea of pattern matching is to attempt to match a value to a series of patterns, and as soon as a pattern matches, extract and name various parts of the value, to finally evaluate some code which typically makes use of these named parts.</p>

<p>A seasoned object-oriented programmer might wonder why we did not define <code>eval</code> as a <em>method</em> of class <code>Tree</code> and its subclasses. We could have done it actually, since Scala allows method definitions in case classes just like in normal classes. Deciding whether to use pattern matching or methods is therefore a matter of taste, but it also has important implications on extensibility:</p>

<ul>
<li>when using methods, it is easy to add a new kind of node as this can be done just by defining a sub-class of <code>Tree</code> for it; on the other hand, adding a new operation to manipulate the tree is tedious, as it requires modifications to all sub-classes of <code>Tree</code>,</li>

<li>when using pattern matching, the situation is reversed: adding a new kind of node requires the modification of all functions which do pattern matching on the tree, to take the new node into account; on the other hand, adding a new operation is easy, by just defining it as an independent function.</li>
</ul>

<p>To explore pattern matching further, let us define another operation on arithmetic expressions: symbolic derivation. The reader might remember the following rules regarding this operation:</p>

<ol>
<li>the derivative of a sum is the sum of the derivatives,</li>

<li>the derivative of some variable <code>v</code> is one if <code>v</code> is the variable relative to which the derivation takes place, and zero otherwise,</li>

<li>the derivative of a constant is zero.</li>
</ol>

<p>These rules can be translated almost literally into Scala code, to obtain the following definition:</p>

<pre><code>def derive(t: Tree, v: String): Tree = t match {
  case Sum(l, r) =&gt; Sum(derive(l, v), derive(r, v))
  case Var(n) if (v == n) =&gt; Const(1)
  case _ =&gt; Const(0)
}</code></pre>

<p>This function introduces two new concepts related to pattern matching. First of all, the <code>case</code> expression for variables has a <em>guard</em>, an expression following the <code>if</code> keyword. This guard prevents pattern matching from succeeding unless its expression is true. Here it is used to make sure that we return the constant <code>1</code> only if the name of the variable being derived is the same as the derivation variable <code>v</code>. The second new feature of pattern matching used here is the <em>wildcard</em>, written <code>_</code>, which is a pattern matching any value, without giving it a name.</p>

<p>We did not explore the whole power of pattern matching yet, but we will stop here in order to keep this document short. We still want to see how the two functions above perform on a real example. For that purpose, let&#8217;s write a simple <code>main</code> function which performs several operations on the expression <code>(x+x)+(7+y)</code>: it first computes its value in the environment <code>{ x -&gt; 5, y -&gt; 7 }</code>, then computes its derivative relative to <code>x</code> and then <code>y</code>.</p>

<pre><code>def main(args: Array[String]) {
  val exp: Tree = Sum(Sum(Var(&quot;x&quot;),Var(&quot;x&quot;)),Sum(Const(7),Var(&quot;y&quot;)))
  val env: Environment = { case &quot;x&quot; =&gt; 5 case &quot;y&quot; =&gt; 7 }
  println(&quot;Expression: &quot; + exp)
  println(&quot;Evaluation with x=5, y=7: &quot; + eval(exp, env))
  println(&quot;Derivative relative to x:\n &quot; + derive(exp, &quot;x&quot;))
  println(&quot;Derivative relative to y:\n &quot; + derive(exp, &quot;y&quot;))
}</code></pre>

<p>Executing this program, we get the expected output:</p>

<pre><code>Expression: Sum(Sum(Var(x),Var(x)),Sum(Const(7),Var(y)))
Evaluation with x=5, y=7: 24
Derivative relative to x:
 Sum(Sum(Const(1),Const(1)),Sum(Const(0),Const(0)))
Derivative relative to y:
 Sum(Sum(Const(0),Const(0)),Sum(Const(0),Const(1)))</code></pre>

<p>By examining the output, we see that the result of the derivative should be simplified before being presented to the user. Defining a basic simplification function using pattern matching is an interesting (but surprisingly tricky) problem, left as an exercise for the reader.</p>

<h2 id='traits'>Traits</h2>

<p>Apart from inheriting code from a super-class, a Scala class can also import code from one or several <em>traits</em>.</p>

<p>Maybe the easiest way for a Java programmer to understand what traits are is to view them as interfaces which can also contain code. In Scala, when a class inherits from a trait, it implements that trait&#8217;s interface, and inherits all the code contained in the trait.</p>

<p>To see the usefulness of traits, let&#8217;s look at a classical example: ordered objects. It is often useful to be able to compare objects of a given class among themselves, for example to sort them. In Java, objects which are comparable implement the <code>Comparable</code> interface. In Scala, we can do a bit better than in Java by defining our equivalent of <code>Comparable</code> as a trait, which we will call <code>Ord</code>.</p>

<p>When comparing objects, six different predicates can be useful: smaller, smaller or equal, equal, not equal, greater or equal, and greater. However, defining all of them is fastidious, especially since four out of these six can be expressed using the remaining two. That is, given the equal and smaller predicates (for example), one can express the other ones. In Scala, all these observations can be nicely captured by the following trait declaration:</p>

<pre><code>trait Ord {
  def &lt; (that: Any): Boolean
  def &lt;=(that: Any): Boolean =  (this &lt; that) || (this == that)
  def &gt; (that: Any): Boolean = !(this &lt;= that)
  def &gt;=(that: Any): Boolean = !(this &lt; that)
}</code></pre>

<p>This definition both creates a new type called <code>Ord</code>, which plays the same role as Java&#8217;s <code>Comparable</code> interface, and default implementations of three predicates in terms of a fourth, abstract one. The predicates for equality and inequality do not appear here since they are by default present in all objects.</p>

<p>The type <code>Any</code> which is used above is the type which is a super-type of all other types in Scala. It can be seen as a more general version of Java&#8217;s <code>Object</code> type, since it is also a super-type of basic types like <code>Int</code>, <code>Float</code>, etc.</p>

<p>To make objects of a class comparable, it is therefore sufficient to define the predicates which test equality and inferiority, and mix in the <code>Ord</code> class above. As an example, let&#8217;s define a <code>Date</code> class representing dates in the Gregorian calendar. Such dates are composed of a day, a month and a year, which we will all represent as integers. We therefore start the definition of the <code>Date</code> class as follows:</p>

<pre><code>class Date(y: Int, m: Int, d: Int) extends Ord {
  def year = y
  def month = m
  def day = d
  override def toString(): String = year + &quot;-&quot; + month + &quot;-&quot; + day</code></pre>

<p>The important part here is the <code>extends Ord</code> declaration which follows the class name and parameters. It declares that the <code>Date</code> class inherits from the <code>Ord</code> trait.</p>

<p>Then, we redefine the <code>equals</code> method, inherited from <code>Object</code>, so that it correctly compares dates by comparing their individual fields. The default implementation of <code>equals</code> is not usable, because as in Java it compares objects physically. We arrive at the following definition:</p>

<pre><code>override def equals(that: Any): Boolean =
  that.isInstanceOf[Date] &amp;&amp; {
    val o = that.asInstanceOf[Date]
    o.day == day &amp;&amp; o.month == month &amp;&amp; o.year == year
  }</code></pre>

<p>This method makes use of the predefined methods <code>isInstanceOf</code> and <code>asInstanceOf</code>. The first one, <code>isInstanceOf</code>, corresponds to Java&#8217;s <code>instanceof</code> operator, and returns true if and only if the object on which it is applied is an instance of the given type. The second one, <code>asInstanceOf</code>, corresponds to Java&#8217;s cast operator: if the object is an instance of the given type, it is viewed as such, otherwise a <code>ClassCastException</code> is thrown.</p>

<p>Finally, the last method to define is the predicate which tests for inferiority, as follows. It makes use of another predefined method, <code>error</code>, which throws an exception with the given error message.</p>

<pre><code>def &lt;(that: Any): Boolean = {
  if (!that.isInstanceOf[Date])
    error(&quot;cannot compare &quot; + that + &quot; and a Date&quot;)

  val o = that.asInstanceOf[Date]
  (year &lt; o.year) ||
  (year == o.year &amp;&amp; (month &lt; o.month ||
                     (month == o.month &amp;&amp; day &lt; o.day)))
}</code></pre>

<p>This completes the definition of the <code>Date</code> class. Instances of this class can be seen either as dates or as comparable objects. Moreover, they all define the six comparison predicates mentioned above: <code>equals</code> and <code>&lt;</code> because they appear directly in the definition of the <code>Date</code> class, and the others because they are inherited from the <code>Ord</code> trait.</p>

<p>Traits are useful in other situations than the one shown here, of course, but discussing their applications in length is outside the scope of this document.</p>

<h2 id='genericity'>Genericity</h2>

<p>The last characteristic of Scala we will explore in this tutorial is genericity. Java programmers should be well aware of the problems posed by the lack of genericity in their language, a shortcoming which is addressed in Java 1.5.</p>

<p>Genericity is the ability to write code parametrized by types. For example, a programmer writing a library for linked lists faces the problem of deciding which type to give to the elements of the list. Since this list is meant to be used in many different contexts, it is not possible to decide that the type of the elements has to be, say, <code>Int</code>. This would be completely arbitrary and overly restrictive.</p>

<p>Java programmers resort to using <code>Object</code>, which is the super-type of all objects. This solution is however far from being ideal, since it doesn&#8217;t work for basic types (<code>int</code>, <code>long</code>, <code>float</code>, etc.) and it implies that a lot of dynamic type casts have to be inserted by the programmer.</p>

<p>Scala makes it possible to define generic classes (and methods) to solve this problem. Let us examine this with an example of the simplest container class possible: a reference, which can either be empty or point to an object of some type.</p>

<pre><code>class Reference[T] {
  private var contents: T = _
  def set(value: T) { contents = value }
  def get: T = contents
}</code></pre>

<p>The class <code>Reference</code> is parametrized by a type, called <code>T</code>, which is the type of its element. This type is used in the body of the class as the type of the <code>contents</code> variable, the argument of the <code>set</code> method, and the return type of the <code>get</code> method.</p>

<p>The above code sample introduces variables in Scala, which should not require further explanations. It is however interesting to see that the initial value given to that variable is <code>_</code>, which represents a default value. This default value is 0 for numeric types, <code>false</code> for the <code>Boolean</code> type, <code>()</code> for the <code>Unit</code> type and <code>null</code> for all object types.</p>

<p>To use this <code>Reference</code> class, one needs to specify which type to use for the type parameter <code>T</code>, that is the type of the element contained by the cell. For example, to create and use a cell holding an integer, one could write the following:</p>

<pre><code>object IntegerReference {
  def main(args: Array[String]) {
    val cell = new Reference[Int]
    cell.set(13)
    println(&quot;Reference contains the half of &quot; + (cell.get * 2))
  }
}</code></pre>

<p>As can be seen in that example, it is not necessary to cast the value returned by the <code>get</code> method before using it as an integer. It is also not possible to store anything but an integer in that particular cell, since it was declared as holding an integer.</p>

<h2 id='conclusion'>Conclusion</h2>

<p>This document gave a quick overview of the Scala language and presented some basic examples. The interested reader can go on, for example, by reading the document <em>Scala By Example</em>, which contains much more advanced examples, and consult the <em>Scala Language Specification</em> when needed.</p>
      <div id="disqus_thread"></div>
<script type="text/javascript">
    /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
  
    var disqus_shortname = 'scalasip'; // required: replace example with your forum shortname
  

    /* * * DON'T EDIT BELOW THIS LINE * * */
    (function() {
        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        dsq.src = 'http://' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a href="http://disqus.com" class="dsq-brlink">blog comments powered by <span class="logo-disqus">Disqus</span></a>

    </div>
    
    <div class="span6">
      <div id="scroller-anchor">
  <div id="scroller">
    <p class="contents">Contents</p>
    <div id="toc"></div>    
              
  </div>
</div>

    </div>
    
	
  </div>
</div>

<div class="footer">
	<div class="container">
		<ul>
			<li><h5>API</h5></li>
			<li><a href="http://www.scala-lang.org/api/current/">Current</a></li>
			<li><a href="http://www.scala-lang.org/archives/downloads/distrib/files/nightly/docs/library/index.html">Nightly</a></li>
		</ul>
		<ul>
			<li><h5>Learn</h5></li>
			<li><a href="/overviews">Guides & Overviews</a></li>
			<li><a href="/tutorials">Tutorials</a></li>
			<li><a href="/style">Scala Style Guide</a></li>				
		</ul>
		<ul>
			<li><h5>Quickref</h5></li>
			<li><a href="/glossary">Glossary</a></li>
			<li><a href="/cheatsheets">Cheatsheets</a></li>
		</ul>
		<ul>
			<li><h5>Contribute</h5></li>
			<li><a href="http://github.com/scala/scala.github.com">Source Code</a></li>
			<li><a href="/contribute.html">Contributors Guide</a></li>
			<li><a href="http://getsatisfaction.com/scaladocs">Suggestions</a></li>			
		</ul>
		<ul>
			<li><h5>Other Resources</h5></li>
			<li><a href="http://wiki.scala-lang.org">Wiki</a></li>
			<li><a href="/sips">Scala Improvement Process</a></li>				
		</ul>						
	</div>
	<div class="container copyright">
 		<p>
			Copyright &copy; 2011-2013 EPFL. All rights reserved.
			<a href="https://github.com/scala/scala.github.com/commits/gh-pages.atom"><img align="right" height="20px" width="20px" src="/resources/images/rss.png" alt="RSS feed of updates to the github repo hosting this site"></a>
		</p>		
	</div>
</div>


<script type="text/javascript">
  $('#toc').toc({exclude: 'h1, h5, h6', context: '', autoId: true, numerate: false});
</script>

<script type="text/javascript">
  $(function() {
    moveScroller();
  });
</script>

  </body>
</html>

    
