
<!DOCTYPE html>
<html>
  <head>

    <title>A Scala Tutorial for C# Programmers - Scala Documentation</title>
    
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>

    <link rel="icon" type="image/png" href="/resources/favicon.ico">

    <!-- prettify js and CSS -->
    <link rel="stylesheet" href="/resources/stylesheets/prettify.css" type="text/css" />
    <script src="/resources/javascript/prettify/prettify.js" type="text/javascript" ></script>


    <!-- jquery js -->
    <script src="/resources/javascript/jquery.js" type="text/javascript" ></script>
    <script src="/resources/javascript/effects.core.js" type="text/javascript" ></script>
    <script src="/resources/javascript/effects.highlight.js" type="text/javascript" ></script>
    <script src="/resources/javascript/moveScroller.js" type="text/javascript" ></script>

    <!-- Bootstrap JS and CSS -->
    <link rel="stylesheet" href="/resources/stylesheets/bootstrap.css" type="text/css" />
	  <script src="/resources/javascript/bootstrap-dropdown.js" type="text/javascript" ></script>
	  <script src="/resources/javascript/bootstrap-dropdown-app.js" type="text/javascript" ></script>

    <!-- Base stylesheet for all pages -->
    <link rel="stylesheet" href="/resources/stylesheets/base.css" type="text/css" />

    <!-- table of contents js -->
    <script src="/resources/javascript/toc.js" type="text/javascript" ></script>

    <!-- google analytics -->
	<script type="text/javascript">

	  var _gaq = _gaq || [];
	  _gaq.push(['_setAccount', 'UA-574683-5']);
	  _gaq.push(['_trackPageview']);

	  (function() {
	    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
	    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
	    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
	  })();

	</script>

    <!-- prettyprint js to prepend generated pre/code tags -->
    <script type="text/javascript">
      function styleCode()
        {
          if (typeof disableStyleCode != "undefined")
          {
              return;
          }
          var a = false;
          $("pre code").parent().each(function()
          {
              if (!$(this).hasClass("prettyprint"))
              {
                  $(this).addClass("prettyprint lang-scala linenums");
                  a = true
              }
          });
          if (a) { prettyPrint() }
      }
    </script>

    <script type="text/javascript">
      jQuery(document).ready(function($) {

            $(".scroll").click(function(event){
              event.preventDefault();
              $('html,body').animate({scrollTop:$(this.hash).offset().top}, 500);
              $('html,body').animate({scrollTop:$(this.hash).offset().top-=50}, 500);
              $(this.hash).effect("highlight", {color: "#FFCC85"}, 3000);
            });
      });
    </script>

    <script type="text/javascript">
      $(window).ready(function goToSubsection() {
          if (window.location.hash)
          {
              $('html,body').animate({scrollTop:$(window.location.hash).offset().top}, 500);
              $('html,body').animate({scrollTop:$(window.location.hash).offset().top-=50}, 500);
              $(window.location.hash).effect("highlight", {color: "#FFCC85"}, 3000);
          }
        });
    </script>

    <style type="text/css">

       p.contents {
           margin-left: 15px;
           font-weight: bold;
           font-size: 16px;
       }

       div#toc ul {
           list-style: none;
       }

       div#toc ul a {
           display: block;
           list-style: none;
           line-height: 22px;
           font-weight: bold;
           width: 100%;
       }

      div#toc ul li ul {
           list-style: disc;
      }

      div#toc ul li ul a {
           line-height: 18px;
           font-weight: normal;
      }

      div#toc ul li ul li ul {
           list-style: square;
      }
       div#toc ul li ul li ul a {
       }

       div#scroller-anchor {
           width: inherit;
       }

       div#scroller {
           width: inherit;
       }

       div#guide-title {
        text-transform: capitalize;
        font-size: 16px;
        padding-bottom: 6px;
        color: #BFBFBF;
        text-transform: uppercase;
        font-weight: bold;
       }

       input, textarea, select, .uneditable-input {
	       width: 165px;
	     }

    </style>

</head>
  <body onload="styleCode()">

    <!-- Topbar
    ================================================== -->
<div class="topbar">
    <div class="topbar-inner">
        <div class="container">
            <a class="brand" href="/index.html"><img src="/resources/images/scala-logo.png"> Documentation</a>
            <ul class="nav">

                <li class="menu">
                      <a href="#" class="menu">API</a>
                      <ul class="menu-dropdown">
                        <li><a href="http://www.scala-lang.org/api/current/">Current</a></li>
                        <li><a href="http://www.scala-lang.org/archives/downloads/distrib/files/nightly/docs/library/index.html">Nightly</a></li>
                        <!--<li class="divider"></li>
                        <li><a href="#">Previous Versions</a></li>
                        -->
                      </ul>
                </li>

                <li class="menu">
                      <a href="#" class="menu">Learn</a>
                      <ul class="menu-dropdown">
                        <li><a href="/overviews">Guides & Overviews</a></li>
                        <li><a href="/tutorials">Tutorials</a></li>
                        <li><a href="/style">Scala Style Guide</a></li>
                      </ul>
                </li>

                <li class="menu">
                      <a href="#" class="menu">Quickref</a>
                      <ul class="menu-dropdown">
                        <li><a href="/glossary">Glossary</a></li>
                        <li><a href="/cheatsheets">Cheatsheets</a></li>
                      </ul>
                </li>

                <li><a href="/contribute.html">Contribute</a></li>
                <li><a href="/sips">SIPs</a></li>
                <li><a href="http://wiki.scala-lang.org">Wiki</a></li>
          </ul>
          <form method="get" id="searchform" action="/search.html">
            <input type="text" placeholder="Search"  class="field" name="q" id="q"/>
          </form>
           </li>
          </ul>
        </div>
    </div>
</div>

<div class="container">
  <div class="row">
    
    <div class="span10"><h1>A Scala Tutorial for C# Programmers</h1></div>

    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    

    
      
        
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
        
      
    
      
        
      
    
      
        
      
    
      
        
      
    
      
        
      
    
      
        
      
    
      
        
      
    
      
        
      
    
      
        
      
    
      
        
      
    
      
        
      
    
      
        
      
    
      
        
      
    
      
        
      
    
      
        
      
    
      
        
      
    
      
        
      
    
      
        
      
    
      
        
      
    
      
        
      
    
      
        
      
    
      
        
      
    
      
        
      
    
      
        
      
    
      
        
      
    
      
        
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
        
      
    
      
        
      
    
      
        
      
    
      
        
      
    
      
        
      
    
      
        
      
    
      
        
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
        
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    

    
      
    

    <div class="span6">
      
        <a href="/tutorials/scala-for-csharp-programmers.html"><img src="/resources/images/language/en.png" title="Language: en"/></a> 
        
          <a href="/es/tutorials/scala-for-csharp-programmers.html"><img src="/resources/images/language/es.png" title="Language: es"/></a> 
        
      
    </div>

    <div class="span10">
      <p>By Ivan Towlson</p>

<h2 id='introduction'>Introduction</h2>

<p>Scala is a hybrid of functional and object-oriented languages. Its functional aspects make it very expressive when writing algorithmic code, and play nicely with the brave new world of concurrency; its object-oriented aspects keep it familiar and convenient when creating business objects or other stateful models.</p>

<h2 id='the_same_concepts'>The same concepts</h2>

<p>Scala shares many features and concepts with C#, as well as introducing many that are new. In fact, some of the capabilities that people talk about a lot in Scala introductions or Java-to-Scala guides are very familiar to C# programmers. For example, as a C# programmer, you don&#8217;t need to be gently walked through the idea of function types &#8211; you&#8217;ve been using delegates and lambdas for years.</p>

<p>However, some Scala features and behaviours are quite different from C#, and even those which are common usually have different syntax or work in slightly different ways. So let&#8217;s start out by covering some Scala basics from a C# programmer&#8217;s point of view.</p>

<h3 id='classes'>Classes</h3>

<p>The basic concept of classes is the same in Scala as in C#. A class bundles up a bunch of state (member fields) and hides it behind an interface (member methods). The syntax for declaring classes is just like C#:</p>

<pre><code>class Widget {
}</code></pre>

<h3 id='fields'>Fields</h3>

<p>The syntax for declaring fields is like this:</p>

<pre><code>class Widget {
  val serialNumber = 123
  private var usageCount = 0
}</code></pre>

<p>You can probably figure out what&#8217;s going on here, but let&#8217;s just note a few differences from C#:</p>

<ul>
<li>Fields are public by default, rather than private by default.</li>

<li>You don&#8217;t need to put a semicolon after a field declaration. You can write semicolons if you want (or if your muscle memory makes you), but if you don&#8217;t, Scala will figure it out for you.</li>

<li>Scala automatically figures out the type of the field from its initial value, just like the C# <code>var</code> keyword. (Don&#8217;t be fooled by the appearance of the second field though &#8211; the Scala <code>var</code> keyword doesn&#8217;t mean the same thing as the C# <code>var</code> keyword.)</li>
</ul>

<p>Now, why is one of these fields introduced as <code>val</code> and the other as <code>var</code>? In C#, fields are mutable by default. That is, by default, any code that can access a field can modify it. You can specify <em>readonly</em> to make a field immutable, so that it can&#8217;t be changed once the object has been constructed.</p>

<p>Scala doesn&#8217;t have a default setting for mutability. You have to engage brain, and decide whether each field is mutable or immutable. <code>val</code> means a field is immutable (readonly in C#) and <code>var</code> means it&#8217;s mutable (a normal field in C#).</p>

<p>So the class above is equivalent to the C#:</p>

<pre><code>class Widget {
  public readonly int serialNumber = 123;
  private int usageCount = 0;
}</code></pre>

<p>Notice that C# makes you write extra code to make things immutable, and Scala doesn&#8217;t. This may seem like a small thing, but it&#8217;s going to be a really important theme.</p>

<h3 id='methods'>Methods</h3>

<p>The syntax for declaring methods is like this:</p>

<pre><code>class Widget {
  def reticulate(winding: Int): String = &quot;some value&quot;
}</code></pre>

<p>This is a more dramatic departure from C# so let&#8217;s pick it apart.</p>

<p>The <code>def</code> keyword means we&#8217;re declaring a method rather than a field. There isn&#8217;t a direct equivalent to this in C#, which figures out whether something is a method or a field from context. As with fields, methods are public by default.</p>

<p>The method name is reassuringly language-independent.</p>

<p>Method arguments go in brackets after the method name, just as in C#. However, the way Scala specifies the argument types is different from C#. In C# you would write <code>int winding</code>; in Scala you write <code>winding: Int</code>.</p>

<p>This is a general principle: in Scala, when you want to specify the type of something, you write the type after the something, separated by a colon. (Whereas in C# you write the type before the something, separated by a space.)</p>

<p>You can see the same principle in action for the return type of the function. <code>reticulate</code> returns a <code>String</code>.</p>

<p>Finally, the body of the method has been placed after an equals sign, rather than inside braces. (Braces are only necessary when the method body consists of multiple expressions/statements.) What&#8217;s more, the body of the method is an expression &#8211; that is, something with a value &#8211; rather than a set of statements amongst which is a <code>return</code>. I&#8217;ll come back to this when we look at a more realistic example, but for the time being, let&#8217;s focus on the trivial example and translate it into C# syntax:</p>

<pre><code>class Widget {
  public string Reticulate(int winding) {
    return &quot;some value&quot;;
  }
}</code></pre>

<h3 id='classes_and_structs'>Classes and Structs</h3>

<p>In C#, when you define a type, you can decide whether to make it a reference type (a class) or a value type (a struct). Scala doesn&#8217;t allow you to create custom value types. It has only classes, not structs. This restriction comes from Scala targeting the Java Virtual Machine. Unlike .NET, the JVM doesn&#8217;t really have the concept of value types. Scala tries to disguise this as best it can, but the lack of custom value types is one place where the implementation leaks through. Fortunately, Scala makes it easy to define immutable reference types, which are nearly as good.</p>

<h3 id='base_types'>Base Types</h3>

<p>Scala&#8217;s base types are pretty much the same as C#&#8217;s, except that they are named with initial capitals, e.g. <code>Int</code> instead of <code>int</code>. (In fact every type in Scala starts with an uppercase letter.) There are no unsigned variants, and booleans are called <code>Boolean</code> instead of <code>bool</code>.</p>

<p>Scala&#8217;s name for <code>void</code> is <code>Unit</code>, but unlike <code>void</code>, <code>Unit</code> is a real type. We&#8217;ll see why this is important in a moment.</p>

<h3 id='function_types'>Function Types</h3>

<p>In C#, you can have variables that refer to functions instead of data. These variables have delegate types, such as <em>Predicate<pre class='markdown-html-error' style='border: solid 3px red; background-color: pink'>REXML could not parse this XML/HTML: 
&lt;T&gt;` or
`Func&lt;T, TResult&gt;` or `KeyEventHandler` or `Action&lt;T1, T2&gt;`.</pre></em></p>

<p>Scala has the same concept, but the function types are built into the language, rather than being library types. Function types are spelled <code>(T1, T2, ...) =&gt; TR</code>. For example, a predicate of integers would be type <code>(Int) =&gt; Boolean</code>. If there is only one input type, the parens can be left out like this: <code>Int =&gt; Boolean</code>.</p>

<p>Effectively, Scala gets rid of all those weird custom delegate types like <code>Predicate&lt;T&gt;</code> and <code>Comparer&lt;T&gt;</code> and has a single family of function types like the C# <code>Func&lt;...&gt;</code> family.</p>

<p>What if you want to refer to a method that doesn&#8217;t have a return value? In C#, you can&#8217;t write <code>Func&lt;T, void&gt;</code> because void isn&#8217;t a valid type; you have to write <code>Action&lt;T&gt;</code> instead. But Scala doesn&#8217;t have different families of delegate types, it just has the built-in function types. Fortunately, in Scala, <code>Unit</code> is a real type, so you can write <code>(Int) =&gt; Unit</code> for a function which takes an integer and doesn&#8217;t return a useful value. This means you can pass <code>void</code> methods interchangeably with non-<code>void</code> methods, which is a Good Thing.</p>

<h3 id='implementing_methods'>Implementing Methods</h3>

<p>I showed a method above, but only to illustrate the declaration syntax. Let&#8217;s take a look at a slightly more substantial method.</p>

<pre><code>def power4(x: Int): Int = {
  var square = x * x  // usually wouldn&#39;t write this - see below
  square * square
}</code></pre>

<p>This looks pretty similar to C#, except that:</p>

<ul>
<li>We&#8217;re allowed to leave out semicolons, as mentioned above.</li>

<li>We don&#8217;t need a return statement. The method body consists of an expression, square * square, with some preliminary bits to define the components of the expression. The return value of the method is the value of the expression.</li>
</ul>

<p>In order to make this method look like C#, I used the <code>var</code> keyword to declare the local variable <code>square</code>. But as with fields, the Scala <code>var</code> keyword doesn&#8217;t work quite the same as the C# <code>var</code> keyword:</p>

<p>In C#, <code>var</code> means &#8220;work out the type of the variable from the right hand side&#8221;. But Scala does that automatically &#8211; you don&#8217;t need to ask for it. In Scala, <code>var</code> means &#8220;allow me to change this variable (or field) after initialisation&#8221;. As with fields, you can also use <code>val</code> to mean &#8216;don&#8217;t allow me to change this variable after initialisation.&#8217; And in fact since we don&#8217;t need to change <code>square</code> after initialisation, we&#8217;d be better off using val:</p>

<pre><code>def power4(x: Int): Int = {
  val square = x * x  // val not var
  square * square
}</code></pre>

<p>Incidentally, if you do ever want to explicitly indicate the type of a variable, you can do it the same way as with function arguments:</p>

<pre><code>def power4(x: Int): Int = {
  val square : Int = x * x
  square * square
}</code></pre>

<p>Notice that you still need <code>val</code> or <code>var</code>. Telling Scala the type of the variable is independent of deciding whether the variable should be mutable or immutable.</p>

<h3 id='tuples'>Tuples</h3>

<p>Everybody hates out parameters. We all know that code like this just isn&#8217;t nice:</p>

<pre><code>Widget widget;
if (widgetDictionary.TryGetValue(widgetKey, out widget))
{
  widget.ReticulateSplines();
}</code></pre>

<p>And once you start composing higher-level functions into the mix, it gets positively nasty. Suppose I want to make a HTTP request. Well, that&#8217;s going to produce two outputs in itself, the success code and the response data. But now suppose I want to time it. Writing the timing code isn&#8217;t a problem, but now I have <em>three</em> outputs, and to paraphrase <em>Was Not Was</em>, I feel worse than Jamie Zawinski.</p>

<p>You can get around this in specific situations by creating custom types like <code>DictionaryLookupResult</code> or <code>TimedHttpRequestResult</code>, but eventually the terrible allure wears off, and you just want it to work.</p>

<p>Enter tuples. A tuple is just a small number of values &#8211; a single value, a pair of values, a triplet of values, that sort of thing. You can tell that tuples were named by mathematicians because the name only makes sense when you look at the cases you hardly ever use (quadruple, quintuple, sextuple, etc.). Using tuples, our timed HTTP request might look like this:</p>

<pre><code>public Tuple&lt;bool, Stream, TimeSpan&gt; Time(Func&lt;Tuple&lt;bool, Stream&gt;&gt; action)
{
  StartTimer();
  var result = action();
  TimeSpan howLong = StopTimer();
  return Tuple.Create(result.First, result.Second, howLong);
}

var result = Time(() =&gt; MakeRequest(uri));
var succeeded = result.First;
var response = result.Second;
var howLong = result.Third.
Console.WriteLine(&quot;it took &quot; + howLong);</code></pre>

<p>The reason this keeps getting verbose on us is that C# doesn’t provide any syntatical support for tuples. To C#, a <code>Tuple&lt;&gt;</code> is just another generic type. To us, the readers, a <code>Tuple&lt;&gt;</code> is just another generic type with particularly unhelpful member names.</p>

<p>Really, what we&#8217;re really trying to articulate by returning a <code>Tuple&lt;&gt;</code> is, &#8220;this method has several outputs.&#8221; So what do we want to do with those outputs? We want to access them, for example to stash them in variables, without having to construct and pick apart the tuple one value at a time. That means the language has to provide some kind of syntax-level support for tuples, instead of treating them like every other class the compiler doesn’t know about.</p>

<p>Many functional languages have exactly this kind of syntactical support, and Scala is no exception. Here’s how the above pseudo-C# looks in Scala:</p>

<pre><code>def time(action: =&gt; (Boolean, Stream)): (Boolean, Stream, TimeSpan) = {
  startTimer()
  val (succeeded, response) = action
  (succeeded, response, stopTimer())
}

val (succeeded, response, timeTaken) = time(makeRequest)
Console.WriteLine(&quot;it took &quot; + timeTaken)</code></pre>

<p>Notice the multiple variables on the left hand side of the time call? Notice the <code>(Boolean, Stream, TimeSpan)</code> return type of the time method? That return value is effectively a tuple type, but instead of having to capture the returned tuple in a <code>Tuple&lt;&gt;</code> variable and extract its various bits by hand, we are getting the Scala compiler to (in the time function) compose the tuple implicitly for us, without us having to write the constructor call, and (in the calling code) unpick the tuple into meaningful, named variables for us without us having to explicitly copy the values one by one and by name.</p>

<p>(By the way, a proper implementation of the <code>time()</code> method wouldn’t be restricted to <code>(Boolean, Stream)</code> results: we’d be looking to write a method that could time anything. I’ve skipped that because it would distract from the point at hand.)</p>

<p>How would this play with the dictionary example?</p>

<pre><code>val (found, widget) = widgetDictionary.getValue(key)
if (found)
  widget.reticulateSplines()</code></pre>

<p>We don’t actually save any lines of code, what with having to now capture the “found” value into a variable and test it separately; and it’s not as if the original C# version was horribly unreadable anyway. So maybe this is a matter of taste, but I find this a lot easier to read and to write: all the outputs are on the left of the equals sign where they belong, instead of being spread between the assignment result and the parameter list, and we don’t have that odd Widget declaration at the top.</p>

<h2 id='new_and_different_concepts'>New and different concepts</h2>

<p>Scala&#8217;s primary platform is the Java virtual machine, and some of the interest in Scala comes from Java programmers&#8217; interest in features such as type inference, comprehensions and lambdas, with which C# programmers are already familiar. So what&#8217;s left that might be of interest specifically to C# programmers?</p>

<h3 id='mixins_and_traits'>Mixins and Traits</h3>

<h4 id='motivation'>Motivation</h4>

<p>Interfaces in C# and Java play a dual role. First, they are a set of capabilities that an implementer has to, well, implement. Second, they are a feature set that a client can use.</p>

<p>These two roles can be conflicting: The first means that interfaces want to be minimal, so that implementers don&#8217;t have to implement a whole lot of superfluous and redundant guff. The second means that interfaces want to be maximal, so that clients don&#8217;t have to clog themselves up with boilerplate utility methods.</p>

<p>Consider, for example, <code>IEnumerable</code> (and its sister interface <code>IEnumerator</code>). This is a very minimal interface: implementers just need to be able to produce values in sequence. But this minimalism means that clients of <code>IEnumerable</code> need to write the same old boilerplate again and again and again: foreach loops to filter, foreach loops to call a method on each element of the sequence, foreach loops to aggregate, foreach loops to check whether all elements meet a criterion, or to find the first member that meets a criterion, or&#8230;</p>

<p>This is frustrating because the implementations of &#8220;filter,&#8221; &#8220;apply&#8221;, &#8220;aggregate,&#8221; and so on are always the same. Of course, we could put these methods into concrete types (<code>List&lt;T&gt;</code> includes several), but then those concrete types will contain duplicate code, and users who only have an <code>IEnumerable</code> will still miss out. And yet we can&#8217;t put these methods into the interface because then every implementer of <code>IEnumerable</code> would have to implement them &#8211; and they&#8217;d end up writing the same boilerplate, just now in all the zillions of <code>IEnumerable</code> classes instead of their clients.</p>

<h4 id='the_c_and_scala_solutions'>The C# and Scala Solutions</h4>

<p>We could resolve this tension if we had a way for interfaces to contain implementation: for example, if <code>IEnumerable</code> required the implementer to provide the class-specific iteration functionality, but then provided the standard implementations of &#8220;filter,&#8221; &#8220;apply&#8221;, &#8220;aggregate&#8221; and so on automatically:</p>

<pre><code>public pseudo_interface IEnumerable
{
  IEnumerator GetEnumerator();  // must be implemented
  IEnumerable Filter(Predicate predicate)  // comes for free
  {
    foreach (object o in this)
     if (predicate(o))
    yield return o;
  }
}</code></pre>

<p>C# 3 addresses this using extension methods: the methods mentioned above are all in fact included as extension methods on <code>IEnumerable&lt;T&gt;</code> as part of LINQ.</p>

<p>This has some advantages over the approach described above: specifically, the &#8220;standard methods&#8221; aren&#8217;t bound up in the interface, so you can add your own methods instead of being limited to the ones that the interface author has included.</p>

<p>On the other hand, it means that method implementations have to be packaged in a different class from the interface, which feels less than modular.</p>

<p>Scala takes a different approach. A Scala trait can contain a mix of abstract methods without implementation as well as concrete methods with an implementation. (It can also be a pure interface, with only abstract members.)</p>

<p>Here&#8217;s a Scala trait that represents objects that can be compared and ordered:</p>

<pre><code>trait Ord {
  def &lt; (that: Any): Boolean
  def &lt;=(that: Any): Boolean = (this &lt; that) || (this == that)
  def &gt; (that: Any): Boolean = !(this &lt;= that)
  def &gt;=(that: Any): Boolean = !(this &lt; that)
}</code></pre>

<p>Orderable objects can extend <code>Ord</code>, but only need to implement the method <code>&lt;</code>. They then get the other operators for free, implemented automatically by Ord in terms of <code>&lt;</code>.</p>

<pre><code>class Date extends Ord {
  def &lt; (that: Any): Boolean = /* implementation */
}

// can now write: myDate &gt;= yourDate</code></pre>

<p>A similar trait, called <code>Ordered</code> already exists in Scala, so there is no need to actually define my trait.</p>

<h4 id='scala_traits_vs_c_extension_methods'>Scala Traits vs. C# Extension Methods</h4>

<p>Okay, so Scala has a different way of packaging standard implementations from C#&#8217;s extension methods. It&#8217;s different, but why is it interesting? Well, there are a couple of things that you can do with Scala traits that don&#8217;t fall nicely out of the extension methods approach.</p>

<p>First, you can override the default implementations of trait members, to take advantage of additional information or capabilities available in the implementing type.</p>

<p>Let&#8217;s look at another <code>IEnumerable</code> example, recast as a Scala trait:</p>

<pre><code>trait Enumerable {
  def getEnumerator(): Enumerator
  def count: Int = {
    // Shockingly bad style; for illustrative purposes only
    var c = 0
    val e = getEnumerator()
    while (e.moveNext()) c = c + 1
    c
  }
}</code></pre>

<p>This (ignoring style issues for now) is the only fully general implementation we can provide for count: it will work with any <code>Enumerable</code>. But for collections that know their sizes, such as <code>arrays</code> or <code>List&lt;T&gt;</code>, it&#8217;s gruesomely inefficient. It iterates over the entire collection, counting elements one by one, when it could just consult the <code>size</code> member and return that.</p>

<p>Let&#8217;s fix that:</p>

<pre><code>class MyList extends Enumerable {
  private var _size;
  def getEnumerator(): Enumerator = /* ... */
  override def count: Int = _size
}</code></pre>

<p>The <code>count</code> member of the <code>Enumerable</code> trait works like a virtual method: it can be overridden in classes which implement/derive from <code>Enumerable</code>.</p>

<p>Compare this to the <code>Count()</code> extension method on <code>IEnumerable&lt;T&gt;</code> in LINQ. This achieves the same effect by trying to cast to <code>ICollection</code>, which is fine as far as it goes but isn&#8217;t extensible.</p>

<p>Suppose you create an enumerable class that can count itself quickly but isn&#8217;t a collection &#8211; for example a natural numbers range object. With a Scala trait, the <code>NumberRange</code> type could provide an efficient override of <code>count</code>, just like any other virtual method; with C# extension methods, <code>Enumerable.Count()</code> would have to somehow know about the <code>NumberRange</code> type in advance, or fall back on counting elements one by one.</p>

<p>Second, with Scala you can choose a trait implementation when you instantiate an object, rather than having it baked in at the class level once and for all. This is called mixin-composition.</p>

<p>Suppose you&#8217;re creating a <code>MyList</code> instance, but you want it to puff itself up to look bigger so as to frighten other <code>MyList</code> instances off its territory. (This example would probably work better with fish, but we&#8217;re stuck with <code>Enumerable</code>s now. Work with me here.) In C#, you&#8217;d need to create a <code>PuffedUpMyList</code> class and override the <code>Count</code> property. In Scala, you can just mix in a <code>PuffedUp</code> version of the trait:</p>

<pre><code>trait PuffedUp extends Enumerable {
  override def count: Int = super.count + 100
}

val normal = new MyList
Console.WriteLine(normal.count)  // meh
val puffedUp = new MyList with PuffedUp
Console.WriteLine(puffedUp.count)  // eek!</code></pre>

<p>As you can imagine this gives us much better granularity and composability of traits and implementations than we get from the extension methods approach, or indeed from single implementation inheritance type systems in general.</p>

<p>So Scala traits have some distinct advantages over extension methods. The only downside appears to be the inability for clients to add their own methods to a trait after the fact.</p>

<p>Fortunately, you can work around this in Scala using so-called implicit conversions. They enable Scala programmers to enrich existing types with new functionality.</p>

<h3 id='singletons'>Singletons</h3>

<p>In C#, if you want to create a singleton object, you have to create a class, then stop evildoers creating their own instances of that class, then create and provide an instance of that class yourself.</p>

<p>While this is hardly a Burma Railway of the programming craft, it does feel like pushing against the grain of the language. Nor is it great for maintainers, who have to be able to recognise a singleton by its pattern (private constructor, public static readonly field, &#8230;), or for clients, who have to use a slightly clumsy multipart syntax to refer to the singleton (e.g. <code>Universe.Instance</code>).</p>

<p>What would be easier for all concerned would be if you could just declare objects <em>as</em> singletons. That is, instead of writing class <code>Universe</code> and a <code>public static readonly</code> instance of it, you could just write <code>object Universe</code>.</p>

<p>And that&#8217;s exactly what Scala allows you to do:</p>

<pre><code>object Universe {
  def contains(obj: Any): Boolean = true
}

val v = Universe.contains(42)</code></pre>

<p>What&#8217;s going on behind the scenes here? It pretty much goes without saying that the Scala compiler is creating a new type for the singleton object. In fact it creates two types, one for the implementation and one for the interface. The interface looks like a .NET static class (actually, the .NET 1.x equivalent, a sealed class with only static members). Thus, a C# program would call the example above as <code>Universe.contains(42)</code>.</p>

<p>Singleton objects are first-class citizens in Scala, so they can for example derive from classes. This is a nice way of creating special values with custom behaviour: you don&#8217;t need to create a whole new type, you just define an instance and override methods in it:</p>

<pre><code>abstract class Cat {
  def humiliateSelf()
}

object Slats extends Cat {
  def humiliateSelf() { savage(this.tail) }
}</code></pre>

<p>Obviously this is a frivolous example, but &#8220;special singletons&#8221; turn out to be an important part of the functional idiom, for example for bottoming out recursion. <em>Scala by Example (PDF)</em> describes an implementation of a Set class which is implemented as a tree-like structure (&#8220;left subset - member - right subset&#8221;), and methods such as <code>contains()</code> work by recursing down to the child sets. For this to work requires an <code>EmptySet</code> whose implementation (state) and behaviour are quite different from non-empty sets &#8211; e.g. <code>contains()</code> just returns <code>false</code> instead of trying to delegate to non-existent child sets. Since <code>EmptySet</code> is logically unique it is both simpler and more efficient to represent it as a singleton: i.e. to declare <code>object EmptySet</code> instead of <code>class EmptySet</code>.</p>

<p>In fact the whole thing can become alarmingly deep: <em>Scala by Example</em> also includes a description of <code>Boolean</code> as an <code>abstract class</code>, and <code>True</code> and <code>False</code> as singleton objects which extend <code>Boolean</code> and provide appropriate implementations of the <code>ifThenElse</code> method.</p>

<p>And fans of Giuseppe Peano should definitely check out the hypothetical implementation of <code>Int</code>&#8230;</p>

<h3 id='pass_by_name'>Pass by Name</h3>

<blockquote>
<p>You&#8217;re only on chapter 3 and you&#8217;re already reduced to writing about <em>calling conventions</em>? You suck! Do another post about chimney sweeps being hunted by jars of marmalade!&#8221;</p>
</blockquote>

<p>Silence, cur. Pass by name is not as other calling conventions are. Pass by name, especially in conjunction with some other rather theoretical-sounding Scala features, is your gateway to the wonderful world of language extensibility.</p>

<h4 id='what_is_passing_by_name'>What is Passing By Name?</h4>

<p>First, let&#8217;s talk about what we mean by <em>calling convention</em>. A calling convention describes how stuff gets passed to a method by its caller. In the good old days, this used to mean exciting things like which arguments got passed in registers and who was responsible for resetting the stack pointer. Sadly, the days of being able to refer to &#8220;naked fun calls&#8221; are consigned to history: In modern managed environments, the runtime takes care of all this guff and the main distinction is pass data by value or by reference. (The situation on the CLR is slightly complicated by the need to differentiate passing values by value, values by reference, references by value and references by reference, but I&#8217;m not going to go into that because (a) it&#8217;s irrelevant to the subject at hand and (b) that&#8217;s <a href='http://www.yoda.arachsys.com/csharp/parameters.html'>Jon Skeet</a>&#8217;s turf and I don&#8217;t want him to shank me. Again.)</p>

<p>In <em>pass by value</em>, the called method gets a copy of whatever the caller passed in. Arguments passed by value therefore work like local variables that are initialised before the method runs: when you do anything to them, you&#8217;re doing it to your own copy.</p>

<p>In <em>pass by reference</em>, the called method gets a reference to the caller&#8217;s value. When you do anything to a pass-by-reference argument, you&#8217;re doing it to the caller&#8217;s data.</p>

<p>In <em>pass by name</em>, the called method gets&#8230; well, it&#8217;s a bit messy to explain what the called method gets. But when the called method does anything to the argument, the argument gets evaluated and the &#8220;anything&#8221; is done to that. Crucially, evaluation happens every time the argument gets mentioned, and only when the argument gets mentioned.</p>

<h4 id='not_just_another_calling_convention'>Not Just Another Calling Convention</h4>

<p>Why does this matter? It matters because there are functions you can&#8217;t implement using pass by value or pass by reference, but you can implement using pass by name.</p>

<p>Suppose, for example, that C# didn&#8217;t have the <code>while</code> keyword. You&#8217;d probably want to write a method that did the job instead:</p>

<pre><code>public static void While(bool condition, Action body)
{
  if (condition)
  {
    body();
    While(condition, body);
  }
}</code></pre>

<p>What happens when we call this?</p>

<pre><code>long x = 0;
While(x &lt; 10, () =&gt; x = x + 1);</code></pre>

<p>C# evaluates the arguments to <code>While</code> and invokes the <code>While</code> method with the arguments <code>true</code> and <code>() =&gt; x = x + 1</code>. After watching the CPU sit on 100% for a while you might check on the value of <code>x</code> and find it&#8217;s somewhere north of a trillion. <em>Why?</em> Because the condition argument was <em>passed by value</em>, so whenever the <code>While</code> method tests the value of condition, it&#8217;s always <code>true</code>. The <code>While</code> method doesn&#8217;t know that condition originally came from the expression <code>x &lt; 10</code>; all <code>While</code> knows is that condition is <code>true</code>.</p>

<p>For the <code>While</code> method to work, we need it to re-evaluate <code>x &lt; 10</code> every time it hits the condition argument. While needs not the value of the argument at the call site, nor a reference to the argument at the call site, but the actual expression that the caller wants it to use to generate a value.</p>

<p>Same goes for short-circuit evaluation. If you want short-circuit evaluation in C#, your only hope if to get on the blower to Anders Hejlsberg and persuade him to bake it into the language:</p>

<pre><code>bool result = (a &gt; 0 &amp;&amp; Math.Sqrt(a) &lt; 10);
double result = (a &lt; 0 ? Math.Sqrt(-a) : Math.Sqrt(a));</code></pre>

<p>You can&#8217;t write a function like <code>&amp;&amp;</code> or <code>?:</code> yourself, because C# will always try to evaluate all the arguments before calling your function.</p>

<p>Consider a VB exile who wants to reproduce his favourite keywords in C#:</p>

<pre><code>bool AndAlso(bool condition1, bool condition2)
{
  return condition1 &amp;&amp; condition2;
}

T IIf&lt;T&gt;(bool condition, T ifTrue, T ifFalse)
{
  if (condition)
    return ifTrue;
  else
    return ifFalse;
}</code></pre>

<p>But when C# hits one of these:</p>

<pre><code>bool result = AndAlso(a &gt; 0, Math.Sqrt(a) &lt; 10);
double result = IIf(a &lt; 0, Math.Sqrt(-a), Math.Sqrt(a));</code></pre>

<p>it would try to evaluate all the arguments at the call site, and pass the results of those evaluations to <code>AndAlso</code> or <code>IIf</code>. There&#8217;s no short-circuiting. So the <code>AndAlso</code> call would crash if a were negative, and the <code>IIf</code> call if a were anything other than 0. Again, what you want is for the <code>condition1</code>, <code>condition2</code>, <code>ifTrue</code> and <code>ifFalse</code> arguments to be evaluated by the callee if it needs them, not for the caller to evaluate them before making the call.</p>

<p>And that&#8217;s what <em>pass by name</em> does. A parameter passed by name is not evaluated when it is passed to a method. It is evaluated &#8211; and re-evaluated &#8211; when the called method evaluates the parameter; specifically when the called method requests the value of the parameter by mentioning its name. This might sound weird and academic, but it&#8217;s the key to being able to define your own control constructs.</p>

<h4 id='using_pass_by_name_in_scala'>Using Pass By Name in Scala</h4>

<p>Let&#8217;s see the custom while implementation again, this time with Scala <em>pass by name</em> parameters:</p>

<pre><code>def myWhile(condition: =&gt; Boolean)(body: =&gt; Unit): Unit =
  if (condition) {
    body
    myWhile(condition)(body)
  }</code></pre>

<p>We can call this as follows:</p>

<pre><code>var i = 0
myWhile (i &lt; 10) {
  println(i)
  i += 1
}</code></pre>

<p>Unlike the C# attempt, this prints out the numbers from 0 to 9 and then terminates as you&#8217;d wish.</p>

<p>Pass by name also works for short-circuiting:</p>

<pre><code>import math._

def andAlso(condition1: =&gt; Boolean, condition2: =&gt; Boolean): Boolean =
  condition1 &amp;&amp; condition2

val d = -1.234
val result = andAlso(d &gt; 0, sqrt(d) &lt; 10)</code></pre>

<p>The <code>andAlso</code> call returns <code>false</code> rather than crashing, because <code>sqrt(d) &lt; 10</code> never gets evaluated.</p>

<p>What&#8217;s going on here? What&#8217;s the weird colon-and-pointy-sticks syntax? What is actually getting passed to <code>myWhile</code> and <code>andAlso</code> to make this work?</p>

<p>The answer is a bit surprising. Nothing is going on here. This is the normal Scala function parameter syntax. There is no <em>pass by name</em> in Scala.</p>

<p>Here&#8217;s a bog-standard <em>pass by value</em> Scala function declaration:</p>

<pre><code>def myFunc1(i: Int): Unit = ...</code></pre>

<p>Takes an integer, returns void: easy enough. Here&#8217;s another:</p>

<pre><code>def myFunc2(f: Int =&gt; Boolean): Unit = ...</code></pre>

<p>Even if you&#8217;ve not seen this kind of expression before, it&#8217;s probably not too hard to guess what this means. This function takes a <em>function from <code>Int</code> to <code>Boolean</code></em> as its argument. In C# terms, <code>void MyFunc2(Func&lt;int, bool&gt; f)</code>. We could call this as follows:</p>

<pre><code>myFunc2 { (i: Int) =&gt; i &gt; 0 }</code></pre>

<p>So now you can guess what this means:</p>

<pre><code>def myFunc3(f: =&gt; Boolean) : Unit = ...</code></pre>

<p>Well, if <code>myFunc2</code> took an <em>Int-to-Boolean</em> function, <code>myFunc3</code> must be taking a &#8220;blank-to-Boolean&#8221; function &#8211; a function that takes no arguments and returns a <code>Boolean</code>. In short, a conditional expression. So we can call <code>myFunc3</code> as follows:</p>

<pre><code>val j = 123
myFunc3 { j &gt; 0 }</code></pre>

<p>The squirly brackets are what we&#8217;d expect from an anonymous function, and because the function has no arguments Scala doesn&#8217;t make us write <code>{ () =&gt; j &gt; 0 }</code>, even though that&#8217;s what it means really. The anonymous function has no arguments because <code>j</code> is a captured local variable, not an argument to the function. But there&#8217;s more. Scala also lets us call <code>myFunc3</code> like this:</p>

<pre><code>val j = 123
myFunc3(j &gt; 0)</code></pre>

<p>This is normal function call syntax, but the Scala compiler realises that <code>myFunc3</code> expects a nullary function (a function with no arguments) rather than a <code>Boolean</code>, and therefore treats <code>myFunc3(j &gt; 0)</code> as shorthand for <code>myFunc3(() =&gt; j &gt; 0)</code>. This is the same kind of logic that the C# compiler uses when it decides whether to compile a lambda expression to a delegate or an expression tree.</p>

<p>You can probably figure out where it goes from here:</p>

<pre><code>def myFunc4(f1: =&gt; Boolean)(f2: =&gt; Unit): Unit = ...</code></pre>

<p>This takes two functions: a conditional expression, and a function that takes no arguments and returns no value (in .NET terms, an <code>Action</code>). Using our powers of anticipation, we can imagine how this might be called using some unholy combination of the two syntaxes we saw for calling <code>myFunc3</code>:</p>

<pre><code>val j = 123;
myFunc4(j &gt; 0) { println(j); j -= 1; }</code></pre>

<p>We can mix and match the <code>()</code> and <code>{}</code> bracketing at whim, except that we have to use <code>{}</code> bracketing if we want to batch up multiple expressions. For example, you could legally equally well write the following:</p>

<pre><code>myFunc4 { j &gt; 0 } { println(j); j -= 1; }
myFunc4 { println(j); j &gt; 0 } (j -= 1)
myFunc4 { println(j); j &gt; 0 } { j -= 1 }</code></pre>

<p>And we&#8217;ll bow to the inevitable by supplying a body for this function:</p>

<pre><code>def myFunc5(f1: =&gt; Boolean)(f2: =&gt; Unit): Unit =
  if (f1()) {
  f2()
  myFunc5(f1)(f2)
}</code></pre>

<p>Written like this, it&#8217;s clear that <code>f1</code> is getting evaluated each time we execute the if statement, but is getting passed (as a function) when <code>myFunc5</code> recurses. But Scala allows us to leave the parentheses off function calls with no arguments, so we can write the above as:</p>

<pre><code>def myFunc5(f1: =&gt; Boolean)(f2: =&gt; Unit): Unit =
  if (f1) {
    f2
    myFunc5(f1)(f2)
  }</code></pre>

<p>Again, type inference allows Scala to distinguish the <em>evaluation of <code>f1</code></em> in the if statement from the <em>passing of <code>f1</code></em> in the <code>myFunc5</code> recursion.</p>

<p>And with a bit of renaming, that&#8217;s <code>myWhile</code>. There&#8217;s no separate <em>pass by name</em> convention: just the usual closure behaviour of capturing local variables in an anonymous method or lambda, a bit of syntactic sugar for nullary functions (functions with no arguments), just like C#&#8217;s syntactic sugar for property getters, and the Scala compiler&#8217;s ability to recognise when a closure is required instead of a value.</p>

<p>In fact, armed with this understanding of the Scala &#8220;syntax,&#8221; we can easily map it back to C#:</p>

<pre><code>void While(Func&lt;bool&gt; condition, Action body)
{
  if (condition())
  {
    body();
    While(condition, body);
  }
}

int i = 0;
While(() =&gt; i &lt; 10, () =&gt;
{
  Console.WriteLine(i);
  ++i;
});</code></pre>

<p>The implementation of the <code>While</code> method in C# is, to my eyes, a bit clearer than the Scala version. However, the syntax for <em>calling</em> the <code>While</code> method in C# is clearly way more complicated and less natural than the syntax for calling <code>myWhile</code> in Scala. Calling <code>myWhile</code> in Scala was like using a native language construct. Calling While in C# required a great deal of clutter at the call site to prevent C# from trying to treat <code>i &lt; 10</code> as a once-and-for-all value, and to express the body at all.</p>

<p>So that&#8217;s so-called &#8220;pass by name&#8221; demystified: The Scala Web site, with crushing mundanity, demotes it to &#8220;automatic type-dependent closure construction,&#8221; which is indeed exactly how it works. As we&#8217;ve seen, however, this technical-sounding feature is actually essential to creating nice syntax for your own control constructs. We&#8217;ll shortly see how this works together with other Scala features to give you even more flexibility in defining your construct&#8217;s syntax.</p>

<h3 id='implicits'>Implicits</h3>

<p>Scala implicits offer some features which will be familiar to the C# programmer, but are much more general in nature and go far beyond what can be done in C#.</p>

<h4 id='enriching_types_in_c_and_scala'>Enriching types in C# and Scala</h4>

<p>Scala, like C#, is statically typed: a class’ methods are compiled into the class definition and are not open for renegotiation. You cannot, as you might in Ruby or Python, just go ahead and declare additional methods on an existing class.</p>

<p>This is of course very inconvenient. You end up declaring a load of <code>FooHelper</code> or <code>FooUtils</code> classes full of static methods, and having to write verbose calling code such as <code>if (EnumerableUtils.IsEmpty(sequence))</code> rather than the rather more readable <code>if (sequence.IsEmpty())</code>.</p>

<p>C# 3 tries to address this problem by introducing extension methods. Extension methods are static methods in a <code>FooHelper</code> or <code>FooUtils</code> kind of class, except you’re allowed to write them using member syntax. By defining <code>IsEmpty</code> as an extension method on <code>IEnumerable</code>, you can write <code>if (sequence.IsEmpty())</code> after all.</p>

<p>Scala disapproves of static classes and global methods, so it plumps for an alternative approach. You’ll still write a <code>FooHelper</code> or <code>FooUtils</code> kind of class, but instead of taking the <code>Foo</code> to be Helped or Utilised as a method parameter, your class will wrap <code>Foo</code> and enrich it with additional methods. Let’s see this in action as we try to add a method to the <code>Double</code> type:</p>

<pre><code>class RicherDouble(d : Double) { 
  def toThe(exp: Double): Double = System.Math.Pow(d, exp)
}</code></pre>

<p>(We call the class <code>RicherDouble</code> because Scala already has a <code>RichDouble</code> class defined which provides further methods to <code>Double</code>.)</p>

<p>Notice that <code>toThe</code> is an instance method, and that <code>RicherDouble</code> takes a <code>Double</code> as a constructor parameter. This seems pretty grim, because we’d normally have to access the function like this:</p>

<pre><code>val result = new DoubleExtensions(2.0).toThe(7.0)</code></pre>

<p>Hardly readable. To make it look nice, Scala requires us to define an <em>implicit conversion</em> from <code>Double</code> to <code>RicherDouble</code>:</p>

<pre><code>object Implicits {
  implicit def richerDouble(d: Double) = new RicherDouble(d)
}</code></pre>

<p>and to bring that implicit conversion into scope:</p>

<pre><code>import Implicits._</code></pre>

<p>Now we can write this:</p>

<pre><code>val twoToTheSeven = 2.0.toThe(7.0)</code></pre>

<p>and all will be well. The <code>Double</code> type has apparently been successfully enriched with the <code>toThe</code> method.</p>

<p>This is, of course, just as much an illusion as the C# equivalent. C# extension methods don’t add methods to a type, and nor do Scala implicit conversions. What has happened here is that the Scala compiler has looked around for implicit methods that are applicable to the type of <code>2.0</code> (namely <code>Double</code>), and return a type that has a <code>toThe</code> method. Our <code>Implicits.richerDouble</code> method fits the bill, so the Scala compiler silently inserts a call to that method. At runtime, therefore, Scala calls <code>Implicits.richerDouble(2.0)</code> and calls the <code>toThe</code> of the resulting <code>RicherDouble</code>.</p>

<p>If setting this up seems a bit verbose, well, maybe. C# extension methods are designed to be easily – one might even say implicitly – brought into scope. That’s very important for operators like the LINQ standard query operators, but it can result in unwanted extension methods being dragged into scope and causing havoc. Scala requires the caller to be a bit more explicit about implicits, which results in a slightly higher setup cost but gives the caller finer control over which implicit methods are considered.</p>

<p>But as it happens you can avoid the need for separate definitions of <code>Implicits</code> and <code>RicherDouble</code>, and get back to a more concise representation by using an anonymous class. (As you’d expect, Scala anonymous classes are fully capable, like Java ones, rather than the neutered C# version.) Here’s how it looks:</p>

<pre><code>object Implicits {
  implicit def doubleToThe(d1 : Double) = new {
    def toThe(d2 : Double) : Double = Math.Pow(d1, d2)
  }
}</code></pre>

<p>Well, big deal. Scala can pimp existing types with new methods just like C#, but using a different syntax. In related news, Lisp uses a different kind of bracket: film at eleven. Why should we be interested in Scala implicits if they’re just another take on extension methods?</p>

<h4 id='implicit_parameters'>Implicit Parameters</h4>

<p>What we saw above was an implicit method – a method which, like a C# implicit conversion operator, the compiler is allowed to insert a call to without the programmer writing that call. Scala also has the idea of implicit parameters – that is, parameters which the compiler is allowed to insert a value for without the programmer specifying that value.</p>

<p>That’s just optional parameters with default values, right? Like C++ and Visual Basic have had since “visual” meant ASCII art on a teletype, and like C# is about to get? Well, no.</p>

<p>C++, Visual Basic and C# optional parameters have fixed defaults specified by the called function. For example, if you have a method like this:</p>

<pre><code>public void Fie(int a, int b = 123) { … }</code></pre>

<p>and you call <code>Fie(456)</code>, it’s always going to be equivalent to calling <code>Fie(456, 123)</code>.</p>

<p>A Scala implicit parameter, on the other hand, gets its value from the calling context. That allows programmer calling the method to control the implicit parameter value, creating an extensibility point that optional parameters don’t provide.</p>

<p>This probably all sounds a bit weird, so let’s look at an example. Consider the following <code>Concatenate</code> method:</p>

<pre><code>public T Concatenate&lt;T&gt;(IEnumerable&lt;T&gt; sequence, T seed, Func&lt;T, T, T&gt; concatenator);</code></pre>

<p>We pass this guy a sequence, a start value and a function that combines two values into one, and it returns the result of calling that function across the sequence. For example, you could pass a sequence of strings, a start value of <code>String.Empty</code>, and <code>(s1, s2) =&gt; s1 + s2</code>, and it would return you all the strings concatenated together:</p>

<pre><code>IEnumerable&lt;string&gt; sequence = new string[] { “mog”, “bites”, “man” };
string result = Concatenate(sequence, String.Empty, (s1, s2) =&gt; s1 + s2);
// result is “mogbitesman”</code></pre>

<p>But this is a unpleasantly verbose. We’re having to pass in <code>String.Empty</code> and <code>(s1, s2) =&gt; s1 + s2</code> every time we want to concatenate a sequence of strings. Not only is this tedious, it also creates the opportunity for error when the boss decides to “help” and passes the literal <code>&quot;String.Empty&quot;</code> as the seed value instead. (“Oh, and I upgraded all the semi-colons to colons while I was in there. No, don’t thank me!”) We’d like to just tell the Concatenate function, “Look, this is how you concatenate strings,” once and for all.</p>

<p>Let’s start out by redefining the <code>Concatenate</code> method in Scala. I’m going to factor out the seed and the concatenator method into a trait because we’ll typically be defining them together.</p>

<pre><code>trait Concatenator[T] {
  def startValue: T
  def concat(x: T, y: T): T
}

object implicitParameters {
  def concatenate[T](xs: List[T])(c: Concatenator[T]): T =
    if (xs.isEmpty) c.startValue
    else c.concat(xs.head, concatenate(xs.tail)(c))
}</code></pre>

<p>We can call this as follows:</p>

<pre><code>object stringConcatenator extends Concatenator[String] {
  def startValue: String = &quot;&quot;
  def concat(x: String, y: String) = x.concat(y)
}

object implicitParameters {
  def main(args: Array[String]) = {
    val result = concatenate(List(&quot;mog&quot;, &quot;bites&quot;, &quot;man&quot;))(stringConcatenator)
    println(result)
  }
}</code></pre>

<p>So far, this looks like the C# version except for the factoring out of the <code>Concatenator</code> trait. We’re still having to pass in the <code>stringConcatenator</code> at the point of the call. Let’s fix that:</p>

<pre><code>def concatenate[T](xs: List[T])(implicit c: Concatenator[T]): T =
  if (xs.isEmpty) c.startValue
  else c.concat(xs.head, concatenate(xs.tail))</code></pre>

<p>We’ve changed two things here. First, we’ve declared c to be an <em>implicit parameter</em>, meaning the caller can leave it out. Second, we’ve left it out ourselves, in the recursive call to <code>concatenate(xs.tail)</code>.</p>

<p>Well, okay, it’s nice that <code>concatenate</code> now doesn’t have to pass the <code>Concatenator</code> explicitly to the recursive call, but we’re still having to pass in the <code>stringConcatenator</code> object to get things started. If only there were some way to make the <code>stringConcatenator</code> object itself implicit…</p>

<pre><code>object Implicits {
  implicit object stringConcatenator extends Concatenator[String] {
    def startValue: String = &quot;&quot;
    def concat(x: String, y: String) = x.concat(y)
  }
}</code></pre>

<p>Again, we’ve done two things here. First, we’ve declared the <code>stringConcatenator</code> object implicit. Consequently, we’ve had to move it out of the top level, because Scala doesn’t allow implicits at the top level (because they’d pollute the global namespace, being in scope even without an explicit import statement).</p>

<p>Now we can call <code>concatenate</code> like this:</p>

<pre><code>import Implicits._

object implicitParameters {
  def main(args: Array[String]) = {
    val result = concatenate(List(&quot;mog&quot;, &quot;bites&quot;, &quot;man&quot;))
    println(result)
  }
}</code></pre>

<p>And we’ll still get “mogbitesman” as the output.</p>

<p>Let’s review what’s going on here. The implicit parameter of concatenate has been set to our <code>stringConcatenator</code>, a default value that the <code>concatenate</code> method knew nothing about when it was compiled. This is somewhere north of what classical optional parameters are capable of, and we’re not finished yet. Let’s build a <code>listConcatenator</code>.</p>

<pre><code>object Implicits {
  class ListConcatenator[T] extends Concatenator[List[T]] {
    def startValue: List[T] = Nil
    def concat(x: List[T], y: List[T]) = x ::: y
  }
  implicit object stringListConcatenator extends ListConcatenator[String] { }
}</code></pre>

<p>This is a bit vexing. <code>List</code> in Scala is a generic type, and has a generic concatenation method called <code>:::</code>. But we can’t create a generic object, because an object is an instance. And implicit parameters have to be objects. So the best we can do is build a generic <code>ListConcatenator</code> class, and then create trivial implicit objects for each generic parameter type we might need.</p>

<p>However, let’s not worry about the implementation, and see how this is used at the calling end:</p>

<pre><code>val result = concatenate(List(
  List(&quot;mog&quot;, &quot;bites&quot;, &quot;man&quot;),
  List(&quot;on&quot;, &quot;beard&quot;)
))</code></pre>

<p>This displays <code>List(mog, bites, man, on, beard)</code>; that is, it concatenates the two <code>List[String]</code>s into one. Once again, we have not had to pass <code>stringListConcatenator</code> explicitly: the Scala compiler has gone and found it for us. We can use the exact same calling code to concatenate lists and strings.</p>

<h4 id='why_should_i_care'>Why Should I Care?</h4>

<p>Isn’t this pointless? At the call site, I have access to <code>stringConcatenator</code> and <code>listStringConcatenator</code>. I can easily pass them in rather than relying on spooky compiler magic to do it for me. Aren’t implicit parameters just job security for compiler writers?</p>

<p>Yes, implicit parameters are technically unnecessary. But if we’re going to play that game, C# is technically unnecessary. You could write all that code in IL. Extension methods are unnecessary because you could write the static method out longhand. Optional parameters are unnecessary because you could read the documentation and pass them in explicitly. Post-It notes are unnecessary because you could fire up Outlook and create a Note instead.</p>

<p>Implicit parameters are about convenience and expressiveness. Implicit parameters give you a way of describing how a function should handle different situations, without needing to bake those situations into the function logic or to specify them every time you call the function. You don’t want to have to tell the <code>concatenate</code> function whether to use the <code>List</code> or <code>String</code> concatenator every time you call it: the compiler knows what you’re concatenating; specifying how to concatenate it just gives you a chance to get it wrong!</p>

<p>Consequently, implicit parameters – like implicit conversions – contribute to Scala’s ability to support internal DSLs. By setting up appropriate implicits, you can write code that reads much more naturally than if you had to pepper it with function objects or callbacks.</p>

<h4 id='conclusion'>Conclusion</h4>

<p>Scala’s <code>implicit</code> keyword goes beyond C#’s equivalent. As in C#, it is used for implicit conversions; unlike C#, this is the idiomatic way to add operations to an existing type, removing the need for the separate extension method syntax. Implicit parameters have no equivalent in C#. They are like being able to add default values to a method: just as a C# using statement bring implicit methods into scope, a Scala import statement can bring default values into scope. If implicit conversions are a way of extending classes, then implicit parameters are a way of extending methods, creating simple, reliable shorthands for complex generic methods, and making up another piece of the Scala DSL jigsaw.</p>

<h4 id='method_call_syntax'>Method Call Syntax</h4>

<p>C#, like most object-oriented programming languages, is pretty strict about how you call methods: you use the dot notation, unless the method is a special ‘operator’ method such as <code>operator+</code>, <code>operator==</code> or a conversion operator. The special operator methods are predefined by the compiler: you can write your own implementation, but you can’t create your own operator names. You can teach the <code>+</code> operator how to handle your custom type, but you can’t add an exponentiation operator:</p>

<pre><code>int a = b ** c;</code></pre>

<p>C# has three problems with this: first, it doesn’t like the method name <code>**</code>; second, it doesn’t like that there’s no <code>.</code> before the name; and third, it doesn’t like that there’s no brackets around the method argument.</p>

<p>To get around the objection to the name, let’s compromise and call it <code>ToThe</code> for now. So what C# insists on seeing is <code>a.ToThe(b)</code>.</p>

<p>Scala, like many functional languages, isn’t so strict. Scala allows you to use any method with a single argument in an infix position. Before we can see this in the exponentiation example, we will enrich the <code>Double</code> type with the <code>toThe</code> method as we learned earlier:</p>

<pre><code>import Implicits._
import math._

class RicherDouble(d: Double) {
  def toThe(exp: Double): Double = pow(d, exp)
}

object Implicits {
  implicit def richerDouble(d: Double) = new RicherDouble(d)
}</code></pre>

<p>Recall that this is just the Scala idiom for extension methods – it’s the equivalent of writing <code>public static ToThe(this double first, double second) { … }</code> in C#. (If we were wanting to use infix notation with our own class, we wouldn’t need all this malarkey.) So now we can write:</p>

<pre><code>val raised = 2.0.toThe(7.0)</code></pre>

<p>Okay, so what do we need to do to get this to work in infix position? Nothing, it turns out.</p>

<pre><code>val raised = 2.0 toThe 8.0  // it just works</code></pre>

<p>This still doesn’t look much like a built-in operator, but it turns out Scala is less fussy than C# about method names too.</p>

<pre><code>class DoubleExtensions(d : Double) { 
  def **(exp: Double): Double = Pow(d, exp)
}

val raised = 2.0 ** 9.0  // it still just works</code></pre>

<p>Much nicer.</p>

<p>This sorta-kinda works for postfix operators too:</p>

<pre><code>class RicherString(s: String) {
  def twice: String = s + s
}

val drivel = &quot;bibble&quot; twice</code></pre>

<p>Calling methods in infix and postfix nodadion is obviously fairly simple syntactic sugar over normal dot notation. But this seemingly minor feature is very important in constructing DSLs, allowing Scala to do in internal DSLs what many languages can do only using external tools. For example, where most languages do parsing via an external file format and a tool to translate that file format into native code (a la <code>lex</code> and <code>yacc</code>), Scala’s parser library makes extensive use of infix and postfix methods to provide a “traditional” syntax for describing a parser, but manages it entirely within the Scala language.</p>
      <div id="disqus_thread"></div>
<script type="text/javascript">
    /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
  
    var disqus_shortname = 'scalasip'; // required: replace example with your forum shortname
  

    /* * * DON'T EDIT BELOW THIS LINE * * */
    (function() {
        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        dsq.src = 'http://' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a href="http://disqus.com" class="dsq-brlink">blog comments powered by <span class="logo-disqus">Disqus</span></a>

    </div>
    
    <div class="span6">
      <div id="scroller-anchor">
  <div id="scroller">
    <p class="contents">Contents</p>
    <div id="toc"></div>    
              
  </div>
</div>

    </div>
    
	
  </div>
</div>

<div class="footer">
	<div class="container">
		<ul>
			<li><h5>API</h5></li>
			<li><a href="http://www.scala-lang.org/api/current/">Current</a></li>
			<li><a href="http://www.scala-lang.org/archives/downloads/distrib/files/nightly/docs/library/index.html">Nightly</a></li>
		</ul>
		<ul>
			<li><h5>Learn</h5></li>
			<li><a href="/overviews">Guides & Overviews</a></li>
			<li><a href="/tutorials">Tutorials</a></li>
			<li><a href="/style">Scala Style Guide</a></li>				
		</ul>
		<ul>
			<li><h5>Quickref</h5></li>
			<li><a href="/glossary">Glossary</a></li>
			<li><a href="/cheatsheets">Cheatsheets</a></li>
		</ul>
		<ul>
			<li><h5>Contribute</h5></li>
			<li><a href="http://github.com/scala/scala.github.com">Source Code</a></li>
			<li><a href="/contribute.html">Contributors Guide</a></li>
			<li><a href="http://getsatisfaction.com/scaladocs">Suggestions</a></li>			
		</ul>
		<ul>
			<li><h5>Other Resources</h5></li>
			<li><a href="http://wiki.scala-lang.org">Wiki</a></li>
			<li><a href="/sips">Scala Improvement Process</a></li>				
		</ul>						
	</div>
	<div class="container copyright">
 		<p>
			Copyright &copy; 2011-2013 EPFL. All rights reserved.
			<a href="https://github.com/scala/scala.github.com/commits/gh-pages.atom"><img align="right" height="20px" width="20px" src="/resources/images/rss.png" alt="RSS feed of updates to the github repo hosting this site"></a>
		</p>		
	</div>
</div>


<script type="text/javascript">
  $('#toc').toc({exclude: 'h1, h5, h6', context: '', autoId: true, numerate: false});
</script>

<script type="text/javascript">
  $(function() {
    moveScroller();
  });
</script>

  </body>
</html>

    
