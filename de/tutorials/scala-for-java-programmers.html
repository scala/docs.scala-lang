
<!DOCTYPE html>
<html>
  <head>

    <title>Ein Scala Tutorial für Java Programmierer - Scala Documentation</title>
    
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>

    <link rel="icon" type="image/png" href="/resources/favicon.ico">

    <!-- prettify js and CSS -->
    <link rel="stylesheet" href="/resources/stylesheets/prettify.css" type="text/css" />
    <script src="/resources/javascript/prettify/prettify.js" type="text/javascript" ></script>


    <!-- jquery js -->
    <script src="/resources/javascript/jquery.js" type="text/javascript" ></script>
    <script src="/resources/javascript/effects.core.js" type="text/javascript" ></script>
    <script src="/resources/javascript/effects.highlight.js" type="text/javascript" ></script>
    <script src="/resources/javascript/moveScroller.js" type="text/javascript" ></script>

    <!-- Bootstrap JS and CSS -->
    <link rel="stylesheet" href="/resources/stylesheets/bootstrap.css" type="text/css" />
	  <script src="/resources/javascript/bootstrap-dropdown.js" type="text/javascript" ></script>
	  <script src="/resources/javascript/bootstrap-dropdown-app.js" type="text/javascript" ></script>

    <!-- Base stylesheet for all pages -->
    <link rel="stylesheet" href="/resources/stylesheets/base.css" type="text/css" />

    <!-- table of contents js -->
    <script src="/resources/javascript/toc.js" type="text/javascript" ></script>

    <!-- google analytics -->
	<script type="text/javascript">

	  var _gaq = _gaq || [];
	  _gaq.push(['_setAccount', 'UA-574683-5']);
	  _gaq.push(['_trackPageview']);

	  (function() {
	    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
	    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
	    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
	  })();

	</script>

    <!-- prettyprint js to prepend generated pre/code tags -->
    <script type="text/javascript">
      function styleCode()
        {
          if (typeof disableStyleCode != "undefined")
          {
              return;
          }
          var a = false;
          $("pre code").parent().each(function()
          {
              if (!$(this).hasClass("prettyprint"))
              {
                  $(this).addClass("prettyprint lang-scala linenums");
                  a = true
              }
          });
          if (a) { prettyPrint() }
      }
    </script>

    <script type="text/javascript">
      jQuery(document).ready(function($) {

            $(".scroll").click(function(event){
              event.preventDefault();
              $('html,body').animate({scrollTop:$(this.hash).offset().top}, 500);
              $('html,body').animate({scrollTop:$(this.hash).offset().top-=50}, 500);
              $(this.hash).effect("highlight", {color: "#FFCC85"}, 3000);
            });
      });
    </script>

    <script type="text/javascript">
      $(window).ready(function goToSubsection() {
          if (window.location.hash)
          {
              $('html,body').animate({scrollTop:$(window.location.hash).offset().top}, 500);
              $('html,body').animate({scrollTop:$(window.location.hash).offset().top-=50}, 500);
              $(window.location.hash).effect("highlight", {color: "#FFCC85"}, 3000);
          }
        });
    </script>

    <style type="text/css">

       p.contents {
           margin-left: 15px;
           font-weight: bold;
           font-size: 16px;
       }

       div#toc ul {
           list-style: none;
       }

       div#toc ul a {
           display: block;
           list-style: none;
           line-height: 22px;
           font-weight: bold;
           width: 100%;
       }

      div#toc ul li ul {
           list-style: disc;
      }

      div#toc ul li ul a {
           line-height: 18px;
           font-weight: normal;
      }

      div#toc ul li ul li ul {
           list-style: square;
      }
       div#toc ul li ul li ul a {
       }

       div#scroller-anchor {
           width: inherit;
       }

       div#scroller {
           width: inherit;
       }

       div#guide-title {
        text-transform: capitalize;
        font-size: 16px;
        padding-bottom: 6px;
        color: #BFBFBF;
        text-transform: uppercase;
        font-weight: bold;
       }

       input, textarea, select, .uneditable-input {
	       width: 165px;
	     }

    </style>

</head>
  <body onload="styleCode()">

    <!-- Topbar
    ================================================== -->
<div class="topbar">
    <div class="topbar-inner">
        <div class="container">
            <a class="brand" href="/index.html"><img src="/resources/images/scala-logo.png"> Documentation</a>
            <ul class="nav">

                <li class="menu">
                      <a href="#" class="menu">API</a>
                      <ul class="menu-dropdown">
                        <li><a href="http://www.scala-lang.org/api/current/">Current</a></li>
                        <li><a href="http://www.scala-lang.org/archives/downloads/distrib/files/nightly/docs/library/index.html">Nightly</a></li>
                        <!--<li class="divider"></li>
                        <li><a href="#">Previous Versions</a></li>
                        -->
                      </ul>
                </li>

                <li class="menu">
                      <a href="#" class="menu">Learn</a>
                      <ul class="menu-dropdown">
                        <li><a href="/overviews">Guides & Overviews</a></li>
                        <li><a href="/tutorials">Tutorials</a></li>
                        <li><a href="/style">Scala Style Guide</a></li>
                      </ul>
                </li>

                <li class="menu">
                      <a href="#" class="menu">Quickref</a>
                      <ul class="menu-dropdown">
                        <li><a href="/glossary">Glossary</a></li>
                        <li><a href="/cheatsheets">Cheatsheets</a></li>
                      </ul>
                </li>

                <li><a href="/contribute.html">Contribute</a></li>
                <li><a href="/sips">SIPs</a></li>
                <li><a href="http://wiki.scala-lang.org">Wiki</a></li>
          </ul>
          <form method="get" id="searchform" action="/search.html">
            <input type="text" placeholder="Search"  class="field" name="q" id="q"/>
          </form>
           </li>
          </ul>
        </div>
    </div>
</div>

<div class="container">
  <div class="row">
    
    <div class="span10"><h1>Ein Scala Tutorial für Java Programmierer</h1></div>

    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    

    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
        
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    

    
      
      
    

    <div class="span6">
      
        <a href="/tutorials/scala-for-java-programmers.html"><img src="/resources/images/language/en.png" title="Language: en"/></a> 
        
          <a href="/es/tutorials/scala-for-java-programmers.html"><img src="/resources/images/language/es.png" title="Language: es"/></a> 
        
          <a href="/ko/tutorials/scala-for-java-programmers.html"><img src="/resources/images/language/ko.png" title="Language: ko"/></a> 
        
          <a href="/de/tutorials/scala-for-java-programmers.html"><img src="/resources/images/language/de.png" title="Language: de"/></a> 
        
      
    </div>

    <div class="span10">
      <p>Von Michel Schinz und Philipp Haller. Deutsche Übersetzung von Christian Krause.</p>

<h2 id='einleitung'>Einleitung</h2>

<p>Dieses Tutorial dient einer kurzen Vorstellung der Programmiersprache Scala und deren Compiler. Sie ist für fortgeschrittene Programmierer gedacht, die sich einen Überblick darüber verschaffen wollen, wie man mit Scala arbeitet. Grundkenntnisse in Objekt-orientierter Programmierung, insbesondere Java, werden vorausgesetzt.</p>

<h2 id='das_erste_beispiel'>Das erste Beispiel</h2>

<p>Als erstes folgt eine Implementierung des wohlbekannten <em>Hallo, Welt!</em>-Programmes. Obwohl es sehr einfach ist, eignet es sich sehr gut, Scalas Funktionsweise zu demonstrieren, ohne dass man viel über die Sprache wissen muss.</p>

<pre><code>object HalloWelt {
  def main(args: Array[String]) {
    println(&quot;Hallo, Welt!&quot;)
  }
}</code></pre>

<p>Die Struktur des Programmes sollte Java Anwendern bekannt vorkommen: es besteht aus einer Methode namens <code>main</code>, welche die Kommandozeilenparameter als Feld (Array) von Zeichenketten (String) übergeben bekommt. Der Körper dieser Methode besteht aus einem einzelnen Aufruf der vordefinierten Methode <code>println</code>, die die freundliche Begrüßung als Parameter übergeben bekommt. Weiterhin hat die <code>main</code>-Methode keinen Rückgabewert - sie ist also eine Prozedur. Daher ist es auch nicht notwendig, einen Rückgabetyp zu spezifizieren.</p>

<p>Was Java-Programmierern allerdings weniger bekannt sein sollte, ist die Deklaration <code>object
HalloWelt</code>, welche die Methode <code>main</code> enthält. Eine solche Deklaration stellt dar, was gemeinhin als <em>Singleton Objekt</em> bekannt ist: eine Klasse mit nur einer Instanz. Im Beispiel oben werden also mit dem Schlüsselwort <code>object</code> sowohl eine Klasse namens <code>HalloWelt</code> als auch die dazugehörige, gleichnamige Instanz definiert. Diese Instanz wird erst bei ihrer erstmaligen Verwendung erstellt.</p>

<p>Dem aufmerksamen Leser ist vielleicht aufgefallen, dass die <code>main</code>-Methode nicht als <code>static</code> deklariert wurde. Der Grund dafür ist, dass statische Mitglieder (Attribute oder Methoden) in Scala nicht existieren. Die Mitglieder von Singleton Objekten stellen in Scala dar, was Java und andere Sprachen mit statischen Mitgliedern erreichen.</p>

<h3 id='das_beispiel_kompilieren'>Das Beispiel kompilieren</h3>

<p>Um das obige Beispiel zu kompilieren, wird <code>scalac</code>, der Scala-Compiler verwendet. <code>scalac</code> arbeitet wie die meisten anderen Compiler auch: er akzeptiert Quellcode-Dateien als Parameter, einige weitere Optionen, und übersetzt den Quellcode in Java-Bytecode. Dieser Bytecode wird in ein oder mehrere Java-konforme Klassen-Dateien, Dateien mit der Endung <code>.class</code>, geschrieben.</p>

<p>Schreibt man den obigen Quellcode in eine Datei namens <code>HalloWelt.scala</code>, kann man diese mit dem folgenden Befehl kompilieren (das größer-als-Zeichen <code>&gt;</code> repräsentiert die Eingabeaufforderung und sollte nicht mit geschrieben werden):</p>

<pre><code>&gt; scalac HalloWelt.scala</code></pre>

<p>Damit werden einige Klassen-Dateien in das aktuelle Verzeichnis geschrieben. Eine davon heißt <code>HalloWelt.class</code> und enthält die Klasse, die direkt mit dem Befehl <code>scala</code> ausgeführt werden kann, was im folgenden Abschnitt erklärt wird.</p>

<h3 id='das_beispiel_ausfhren'>Das Beispiel ausführen</h3>

<p>Sobald kompiliert, kann ein Scala-Programm mit dem Befehl <code>scala</code> ausgeführt werden. Die Anwendung ist dem Befehl <code>java</code>, mit dem man Java-Programme ausführt, nachempfunden und akzeptiert dieselben Optionen. Das obige Beispiel kann demnach mit folgendem Befehl ausgeführt werden, was das erwartete Resultat ausgibt:</p>

<pre><code>&gt; scala -classpath . HalloWelt
Hallo, Welt!</code></pre>

<h2 id='interaktion_mit_java'>Interaktion mit Java</h2>

<p>Eine Stärke der Sprache Scala ist, dass man mit ihr sehr leicht mit Java interagieren kann. Alle Klassen des Paketes <code>java.lang</code> stehen beispielsweise automatisch zur Verfügung, während andere explizit importiert werden müssen.</p>

<p>Als nächstes folgt ein Beispiel, was diese Interoperabilität demonstriert. Ziel ist es, das aktuelle Datum zu erhalten und gemäß den Konventionen eines gewissen Landes zu formatieren, zum Beispiel Frankreich.</p>

<p>Javas Klassen-Bibliothek enthält viele nützliche Klassen, beispielsweise <code>Date</code> und <code>DateFormat</code>. Dank Scala Fähigkeit, nahtlos mit Java zu interoperieren, besteht keine Notwendigkeit, äquivalente Klassen in der Scala Klassen-Bibliothek zu implementieren - man kann einfach die entsprechenden Klassen der Java-Pakete importieren:</p>

<pre><code>import java.util.{Date, Locale}
import java.text.DateFormat
import java.text.DateFormat._

object FrenchDate {
  def main(args: Array[String]) {
    val now = new Date
    val df = getDateInstance(LONG, Locale.FRANCE)
    println(df format now)
  }
}</code></pre>

<p>Scala Import-Anweisung ähnelt sehr der von Java, obwohl sie viel mächtiger ist. Mehrere Klassen des gleichen Paketes können gleichzeitig importiert werden, indem sie, wie in der ersten Zeile, in geschweifte Klammern geschrieben werden. Ein weiterer Unterschied ist, dass, wenn man alle Mitglieder eines Paketes importieren will, einen Unterstrich (<code>_</code>) anstelle des Asterisk (<code>*</code>) verwendet. Der Grund dafür ist, dass der Asterisk ein gültiger Bezeichner in Scala ist, beispielsweise als Name für Methoden, wie später gezeigt wird. Die Import-Anweisung der dritten Zeile importiert demnach alle Mitglieder der Klasse <code>DateFormat</code>, inklusive der statischen Methode <code>getDateInstance</code> und des statischen Feldes <code>LONG</code>.</p>

<p>Innerhalb der <code>main</code>-Methode wird zuerst eine Instanz der Java-Klasse <code>Date</code> erzeugt, welche standardmäßig das aktuelle Datum enthält. Als nächstes wird mithilfe der statischen Methode <code>getDateInstance</code> eine Instanz der Klasse <code>DateFormat</code> erstellt. Schließlich wird das aktuelle Datum gemäß der Regeln der lokalisierten <code>DateFormat</code>-Instanz formatiert ausgegeben. Außerdem veranschaulicht die letzte Zeile eine interessante Fähigkeit Scalas Syntax: Methoden, die nur einen Parameter haben, können in der Infix-Syntax notiert werden. Dies bedeutet, dass der Ausdruck</p>

<pre><code>df format now</code></pre>

<p>eine andere, weniger verbose Variante des folgenden Ausdruckes ist:</p>

<pre><code>df.format(now)</code></pre>

<p>Dies scheint nur ein nebensächlicher, syntaktischer Zucker zu sein, hat jedoch bedeutende Konsequenzen, wie im folgenden Abschnitt gezeigt wird.</p>

<p>Um diesen Abschnitt abzuschließen, soll bemerkt sein, dass es außerdem direkt in Scala möglich ist, von Java-Klassen zu erben sowie Java-Schnittstellen zu implementieren.</p>

<h2 id='alles_ist_ein_objekt'>Alles ist ein Objekt</h2>

<p>Scala ist eine pur Objekt-orientierte Sprache, in dem Sinne dass <em>alles</em> ein Objekt ist, Zahlen und Funktionen eingeschlossen. Der Unterschied zu Java ist, dass Java zwischen primitiven Typen, wie <code>boolean</code> und <code>int</code>, und den Referenz-Typen unterscheidet und es nicht erlaubt ist, Funktionen wie Werte zu behandeln.</p>

<h3 id='zahlen_sind_objekte'>Zahlen sind Objekte</h3>

<p>Zahlen sind Objekte und haben daher Methoden. Tatsächlich besteht ein arithmetischer Ausdruck wie der folgende</p>

<pre><code>1 + 2 * 3 / x</code></pre>

<p>exklusiv aus Methoden-Aufrufen, da es äquivalent zu folgendem Ausdruck ist, wie in vorhergehenden Abschnitt gezeigt wurde:</p>

<pre><code>(1).+(((2).*(3))./(x))</code></pre>

<p>Dies bedeutet außerdem, dass <code>+</code>, <code>*</code>, etc. in Scala gültige Bezeichner sind.</p>

<p>Die Zahlen umschließenden Klammern der zweiten Variante sind notwendig, weil Scalas lexikalischer Scanner eine Regel zur längsten Übereinstimmung der Token verwendet. Daher würde der folgende Ausdruck:</p>

<pre><code>1.+(2)</code></pre>

<p>in die Token <code>1.</code>, <code>+</code>, und <code>2</code> zerlegt werden. Der Grund für diese Zerlegung ist, dass <code>1.</code> eine längere, gültige Übereinstimmung ist, als <code>1</code>. Daher würde das Token <code>1.</code> als das Literal <code>1.0</code> interpretiert, also als Gleitkommazahl anstatt als Ganzzahl. Den Ausdruck als</p>

<pre><code>(1).+(2)</code></pre>

<p>zu schreiben, verhindert also, dass <code>1.</code> als Gleitkommazahl interpretiert wird.</p>

<h3 id='funktionen_sind_objekte'>Funktionen sind Objekte</h3>

<p>Vermutlich überraschender für Java-Programmierer ist, dass auch Funktionen in Scala Objekte sind. Daher ist es auch möglich, Funktionen als Parameter zu übergeben, als Werte zu speichern, und von anderen Funktionen zurückgeben zu lassen. Diese Fähigkeit, Funktionen wie Werte zu behandeln, ist einer der Grundsteine eines sehr interessanten Programmier-Paradigmas, der <em>funktionalen Programmierung</em>.</p>

<p>Ein sehr einfaches Beispiel, warum es nützlich sein kann, Funktionen wie Werte zu behandeln, ist eine Timer-Funktion, deren Ziel es ist, eine gewisse Aktion pro Sekunde durchzuführen. Wie übergibt man die durchzuführende Aktion? Offensichtlich als Funktion. Diese einfache Art der Übergabe einer Funktion sollte den meisten Programmieren bekannt vorkommen: dieses Prinzip wird häufig bei Schnittstellen für Rückruf-Funktionen (call-back) verwendet, die ausgeführt werden, wenn ein bestimmtes Ereignis eintritt.</p>

<p>Im folgenden Programm akzeptiert die Timer-Funktion <code>oncePerSecond</code> eine Rückruf-Funktion als Parameter. Deren Typ wird <code>() =&gt; Unit</code> geschrieben und ist der Typ aller Funktionen, die keine Parameter haben und nichts zurück geben (der Typ <code>Unit</code> ist das Äquivalent zu <code>void</code>). Die <code>main</code>-Methode des Programmes ruft die Timer-Funktion mit der Rückruf-Funktion auf, die einen Satz ausgibt. In anderen Worten: das Programm gibt endlos den Satz &#8220;Die Zeit vergeht wie im Flug.&#8221; einmal pro Sekunde aus.</p>

<pre><code>object Timer {
  def oncePerSecond(callback: () =&gt; Unit) {
    while (true) {
      callback()
      Thread sleep 1000
    }
  }

  def timeFlies() {
    println(&quot;Die Zeit vergeht wie im Flug.&quot;)
  }

  def main(args: Array[String]) {
    oncePerSecond(timeFlies)
  }
}</code></pre>

<p>Weiterhin ist zu bemerken, dass, um die Zeichenkette auszugeben, die in Scala vordefinierte Methode <code>println</code> statt der äquivalenten Methode in <code>System.out</code> verwendet wird.</p>

<h4 id='anonyme_funktionen'>Anonyme Funktionen</h4>

<p>Während das obige Programm schon leicht zu verstehen ist, kann es noch verbessert werden. Als erstes sei zu bemerken, dass die Funktion <code>timeFlies</code> nur definiert wurde, um der Funktion <code>oncePerSecond</code> als Parameter übergeben zu werden. Dieser nur einmal verwendeten Funktion einen Namen zu geben, scheint unnötig und es wäre angenehmer, sie direkt mit der Übergabe zu erstellen. Dies ist in Scala mit <em>anonymen Funktionen</em> möglich, die eine Funktion ohne Namen darstellen. Die überarbeitete Variante des obigen Timer-Programmes verwendet eine anonyme Funktion anstatt der Funktion <code>timeFlies</code>:</p>

<pre><code>object TimerAnonymous {
  def oncePerSecond(callback: () =&gt; Unit) {
    while (true) {
      callback()
      Thread sleep 1000
    }
  }

  def main(args: Array[String]) {
    oncePerSecond(() =&gt; println(&quot;Die Zeit vergeht wie im Flug.&quot;))
  }
}</code></pre>

<p>Die anonyme Funktion erkennt man an dem Rechtspfeil <code>=&gt;</code>, der die Parameter der Funktion von deren Körper trennt. In diesem Beispiel ist die Liste der Parameter leer, wie man an den leeren Klammern erkennen kann. Der Körper der Funktion ist derselbe, wie bei der <code>timeFlies</code> Funktion des vorangegangenen Beispiels.</p>

<h2 id='klassen'>Klassen</h2>

<p>Wie weiter oben zu sehen war, ist Scala eine pur Objekt-orientierte Sprache, und als solche enthält sie das Konzept von Klassen (der Vollständigkeit halber soll bemerkt sein, dass nicht alle Objekt-orientierte Sprachen das Konzept von Klassen unterstützen, aber Scala ist keine von denen). Klassen in Scala werden mit einer ähnlichen Syntax wie Java deklariert. Ein wichtiger Unterschied ist jedoch, dass Scalas Klassen Argumente haben. Dies soll mit der folgenden Definition von komplexen Zahlen veranschaulicht werden:</p>

<pre><code>class Complex(real: Double, imaginary: Double) {
  def re() = real
  def im() = imaginary
}</code></pre>

<p>Diese Klasse akzeptiert zwei Argumente, den realen und den imaginären Teil der komplexen Zahl. Sie müssen beim Erzeugen einer Instanz der Klasse übergeben werden:</p>

<pre><code>val c = new Complex(1.5, 2.3)</code></pre>

<p>Weiterhin enthält die Klasse zwei Methoden, <code>re</code> und <code>im</code>, welche als Zugriffsfunktionen (Getter) dienen. Außerdem soll bemerkt sein, dass der Rückgabe-Typ dieser Methoden nicht explizit deklariert ist. Der Compiler schlussfolgert ihn automatisch, indem er ihn aus dem rechten Teil der Methoden ableitet, dass der Rückgabewert vom Typ <code>Double</code> ist.</p>

<p>Der Compiler ist nicht immer fähig, auf den Rückgabe-Typ zu schließen, und es gibt leider keine einfache Regel, vorauszusagen, ob er dazu fähig ist oder nicht. In der Praxis stellt das üblicherweise kein Problem dar, da der Compiler sich beschwert, wenn es ihm nicht möglich ist. Scala-Anfänger sollten versuchen, Typ-Deklarationen, die leicht vom Kontext abzuleiten sind, wegzulassen, um zu sehen, ob der Compiler zustimmt. Nach einer gewissen Zeit, bekommt man ein Gefühl dafür, wann man auf diese Deklarationen verzichten kann und wann man sie explizit angeben sollte.</p>

<h3 id='methoden_ohne_argumente'>Methoden ohne Argumente</h3>

<p>Ein Problem der obigen Methoden <code>re</code> und <code>im</code> ist, dass man, um sie zu verwenden, ein leeres Klammerpaar hinter ihren Namen anhängen muss:</p>

<pre><code>object ComplexNumbers {
  def main(args: Array[String]) {
    val c = new Complex(1.2, 3.4)
    println(&quot;imaginary part: &quot; + c.im())
  }
}</code></pre>

<p>Besser wäre es jedoch, wenn man den realen und imaginären Teil so abrufen könnte, als wären sie Felder, also ohne das leere Klammerpaar. Mit Scala ist dies möglich, indem Methoden <em>ohne Argumente</em> definiert werden. Solche Methoden haben keine Klammern nach ihrem Namen, weder bei ihrer Definition noch bei ihrer Verwendung. Die Klasse für komplexe Zahlen kann demnach folgendermaßen umgeschrieben werden:</p>

<pre><code>class Complex(real: Double, imaginary: Double) {
  def re = real
  def im = imaginary
}</code></pre>

<h3 id='vererbung_und_berschreibung'>Vererbung und Überschreibung</h3>

<p>Alle Klassen in Scala erben von einer Oberklasse. Wird keine Oberklasse angegeben, wie bei der Klasse <code>Complex</code> des vorhergehenden Abschnittes, wird implizit <code>scala.AnyRef</code> verwendet.</p>

<p>Außerdem ist es möglich, von einer Oberklasse vererbte Methoden zu überschreiben. Dabei muss jedoch explizit das Schlüsselwort <code>override</code> angegeben werden, um versehentliche Überschreibungen zu vermeiden. Als Beispiel soll eine Erweiterung der Klasse <code>Complex</code> dienen, die die Methode <code>toString</code> neu definiert:</p>

<pre><code>class Complex(real: Double, imaginary: Double) {
  def re = real
  def im = imaginary

  override def toString() =
    &quot;&quot; + re + (if (im &lt; 0) &quot;&quot; else &quot;+&quot;) + im + &quot;i&quot;
}</code></pre>

<h2 id='containerklassen_und_musterabgleiche'>Container-Klassen und Musterabgleiche</h2>

<p>Eine Datenstruktur, die häufig in Programmen vorkommt, ist der Baum. Beispielsweise repräsentieren Interpreter und Compiler Programme intern häufig als Bäume, XML-Dokumente sind Bäume und einige Container basieren auf Bäumen, wie Rot-Schwarz-Bäume.</p>

<p>Als nächstes wird anhand eines kleinen Programmes für Berechnungen gezeigt, wie solche Bäume in Scala repräsentiert und manipuliert werden können. Das Ziel dieses Programmes ist, einfache arithmetische Ausdrücke zu manipulieren, die aus Summen, Ganzzahlen und Variablen bestehen. Beispiele solcher Ausdrücke sind: <code>1+2</code> und <code>(x+x)+(7+y)</code>.</p>

<p>Dafür muss zuerst eine Repräsentation für die Ausdrücke gewählt werden. Die natürlichste ist ein Baum, dessen Knoten Operationen (Additionen) und dessen Blätter Werte (Konstanten und Variablen) darstellen.</p>

<p>In Java würde man solche Bäume am ehesten mithilfe einer abstrakten Oberklasse für den Baum und konkreten Implementierungen für Knoten und Blätter repräsentieren. In einer funktionalen Sprache würde man algebraische Datentypen mit dem gleichen Ziel verwenden. Scala unterstützt das Konzept einer Container-Klasse (case class), die einen gewissen Mittelweg dazwischen darstellen. Der folgenden Quellcode veranschaulicht deren Anwendung:</p>

<pre><code>abstract class Tree
case class Sum(l: Tree, r: Tree) extends Tree
case class Var(n: String) extends Tree
case class Const(v: Int) extends Tree</code></pre>

<p>Die Tatsache, dass die Klassen <code>Sum</code>, <code>Var</code> und <code>Const</code> als Container-Klassen deklariert sind, bedeutet, dass sie sich in einigen Gesichtspunkten von normalen Klassen unterscheiden:</p>

<ul>
<li>das Schlüsselwort <code>new</code> ist nicht mehr notwendig, um Instanzen dieser Klassen zu erzeugen (man kann also <code>Const(5)</code> anstelle von <code>new Const(5)</code> schreiben)</li>

<li>Zugriffsfunktionen werden automatisch anhand der Parameter des Konstruktors erstellt (man kann den Wert <code>v</code> einer Instanz <code>c</code> der Klasse <code>Const</code> erhalten, indem man <code>c.v</code> schreibt)</li>

<li>der Compiler fügt Container-Klassen automatisch Implementierungen der Methoden <code>equals</code> und <code>hashCode</code> hinzu, die auf der <em>Struktur</em> der Klassen basieren, anstelle deren Identität</li>

<li>außerdem wird eine <code>toString</code>-Methode bereitgestellt, die einen Wert in Form der Quelle darstellt (der String-Wert des Baum-Ausdruckes <code>x+1</code> ist <code>Sum(Var(x),Const(1))</code>)</li>

<li>Instanzen dieser Klassen können mithilfe von Musterabgleichen zerlegt werden, wie weiter unten zu sehen ist</li>
</ul>

<p>Da jetzt bekannt ist, wie die Datenstruktur der arithmetischen Ausdrücke repräsentiert wird, können jetzt Operationen definiert werden, um diese zu manipulieren. Der Beginn dessen soll eine Funktion darstellen, die Ausdrücke in einer bestimmten <em>Umgebung</em> auswertet. Das Ziel einer Umgebung ist es, Variablen Werte zuzuweisen. Beispielsweise wird der Ausdruck <code>x+1</code> in der Umgebung, die der Variable <code>x</code> den Wert <code>5</code> zuweist, geschrieben als <code>{ x -&gt; 5 }</code>, mit dem Resultat <code>6</code> ausgewertet.</p>

<p>Demnach muss ein Weg gefunden werden, solche Umgebungen auszudrücken. Dabei könnte man sich für eine assoziative Datenstruktur entscheiden, wie eine Hash-Tabelle, man könnte jedoch auch direkt eine Funktion verwenden. Eine Umgebung ist nicht mehr als eine Funktion, die Werte mit Variablen assoziiert. Die obige Umgebung <code>{ x -&gt; 5 }</code> wird in Scala folgendermaßen notiert:</p>

<pre><code>{ case &quot;x&quot; =&gt; 5 }</code></pre>

<p>Diese Schreibweise definiert eine Funktion, welche bei dem String <code>&quot;x&quot;</code> als Argument die Ganzzahl <code>5</code> zurückgibt, und in anderen Fällen mit einer Ausnahme fehlschlägt.</p>

<p>Vor dem Schreiben der Funktionen zum Auswerten ist es sinnvoll, für die Umgebungen einen eigenen Typ zu definieren. Man könnte zwar immer <code>String =&gt; Int</code> verwenden, es wäre jedoch besser einen dedizierten Namen dafür zu verwenden, der das Programmieren damit einfacher macht und die Lesbarkeit erhöht. Dies wird in Scala mit der folgenden Schreibweise erreicht:</p>

<pre><code>type Environment = String =&gt; Int</code></pre>

<p>Von hier an wird <code>Environment</code> als Alias für den Typ von Funktionen von <code>String</code> nach <code>Int</code> verwendet.</p>

<p>Nun ist alles für die Definition der Funktion zur Auswertung vorbereitet. Konzeptionell ist die Definition sehr einfach: der Wert der Summe zweier Ausdrücke ist die Summe der Werte der einzelnen Ausdrücke, der Wert einer Variablen wird direkt der Umgebung entnommen und der Wert einer Konstante ist die Konstante selbst. Dies in Scala auszudrücken, ist nicht viel schwieriger:</p>

<pre><code>def eval(t: Tree, env: Environment): Int = t match {
  case Sum(l, r) =&gt; eval(l, env) + eval(r, env)
  case Var(n)    =&gt; env(n)
  case Const(v)  =&gt; v
}</code></pre>

<p>Diese Funktion zum Auswerten von arithmetischen Ausdrücken nutzt einen <em>Musterabgleich</em> (pattern matching) am Baumes <code>t</code>. Intuitiv sollte die Bedeutung der einzelnen Fälle klar sein:</p>

<ol>
<li>
<p>Als erstes wird überprüft, ob <code>t</code> eine Instanz der Klasse <code>Sum</code> ist. Falls dem so ist, wird der linke Teilbaum der Variablen <code>l</code> und der rechte Teilbaum der Variablen <code>r</code> zugewiesen. Daraufhin wird der Ausdruck auf der rechten Seite des Pfeiles ausgewertet, der die auf der linken Seite gebundenen Variablen <code>l</code> und <code>r</code> verwendet.</p>
</li>

<li>
<p>Sollte die erste Überprüfung fehlschlagen, also <code>t</code> ist keine <code>Sum</code>, wird der nächste Fall abgehandelt und überprüft, ob <code>t</code> eine <code>Var</code> ist. Ist dies der Fall, wird analog zum ersten Fall der Wert an <code>n</code> gebunden und der Ausdruck rechts vom Pfeil ausgewertet.</p>
</li>

<li>
<p>Schlägt auch die zweite Überprüfung fehl, also <code>t</code> ist weder <code>Sum</code> noch <code>Val</code>, wird überprüft, ob es eine Instanz des Typs <code>Const</code> ist. Analog wird bei einem Erfolg wie bei den beiden vorangegangenen Fällen verfahren.</p>
</li>

<li>
<p>Schließlich, sollten alle Überprüfungen fehlschlagen, wird eine Ausnahme ausgelöst, die signalisiert, dass der Musterabgleich nicht erfolgreich war. Dies wird unweigerlich geschehen, sollten neue Baum-Unterklassen erstellt werden.</p>
</li>
</ol>

<p>Die prinzipielle Idee eines Musterabgleiches ist, einen Wert anhand einer Reihe von Mustern abzugleichen und, sobald ein Treffer erzielt wird, Werte zu extrahieren, mit denen darauf weitergearbeitet werden kann.</p>

<p>Erfahrene Objekt-orientierte Programmierer werden sich fragen, warum <code>eval</code> nicht als Methode der Klasse <code>Tree</code> oder dessen Unterklassen definiert wurde. Dies wäre möglich, da Container-Klassen Methoden definieren können, wie normale Klassen auch. Die Entscheidung, einen Musterabgleich oder Methoden zu verwenden, ist Geschmackssache, hat jedoch wichtige Auswirkungen auf die Erweiterbarkeit:</p>

<ul>
<li>einerseits ist es mit Methoden einfach, neue Arten von Knoten als Unterklassen von <code>Tree</code> hinzuzufügen, andererseits ist die Ergänzung einer neuen Operation zur Manipulation des Baumes mühsam, da sie die Modifikation aller Unterklassen von <code>Tree</code> erfordert</li>

<li>nutzt man einen Musterabgleich kehrt sich die Situation um: eine neue Art von Knoten erfordert die Modifikation aller Funktionen die einen Musterabgleich am Baum vollführen, wogegen eine neue Operation leicht hinzuzufügen ist, indem einfach eine unabhängige Funktion dafür definiert wird</li>
</ul>

<p>Einen weiteren Einblick in Musterabgleiche verschafft eine weitere Operation mit arithmetischen Ausdrücken: partielle Ableitungen. Dafür gelten zur Zeit folgende Regeln:</p>

<ol>
<li>die Ableitung einer Summe ist die Summe der Ableitungen</li>

<li>die Ableitung einer Variablen ist eins, wenn sie die abzuleitende Variable ist, ansonsten <code>0</code></li>

<li>die Ableitung einer Konstanten ist <code>0</code></li>
</ol>

<p>Auch diese Regeln können fast wörtlich in Scala übersetzt werden:</p>

<pre><code>def derive(t: Tree, v: String): Tree = t match {
  case Sum(l, r) =&gt; Sum(derive(l, v), derive(r, v))
  case Var(n) if (v == n) =&gt; Const(1)
  case _ =&gt; Const(0)
}</code></pre>

<p>Diese Funktion führt zwei neue, mit dem Musterabgleich zusammenhängende Konzepte ein. Der zweite, sich auf eine Variable beziehende Fall hat eine <em>Sperre</em> (guard), einen Ausdruck, der dem Schlüsselwort <code>if</code> folgt. Diese Sperre verhindert eine Übereinstimmung, wenn der Ausdruck falsch ist. In diesem Fall wird sie genutzt, die Konstante <code>1</code> nur zurückzugeben, wenn die Variable die abzuleitende ist. Die zweite Neuerung ist der <em>Platzhalter</em> <code>_</code>, der mit allem übereinstimmt, jedoch ohne einen Namen dafür zu verwenden.</p>

<p>Die volle Funktionalität von Musterabgleichen wurde mit diesen Beispielen nicht demonstriert, doch soll dies fürs Erste genügen. Eine Vorführung der beiden Funktionen an realen Beispielen steht immer noch aus. Zu diesem Zweck soll eine <code>main</code>-Methode dienen, die den Ausdruck <code>(x+x)+(7+y)</code> als Beispiel verwendet: zuerst wird der Wert in der Umgebung <code>{ x -&gt; 5, y -&gt; 7 }</code> berechnet und darauf die beiden partiellen Ableitungen gebildet:</p>

<pre><code>def main(args: Array[String]) {
  val exp: Tree = Sum(Sum(Var(&quot;x&quot;),Var(&quot;x&quot;)),Sum(Const(7),Var(&quot;y&quot;)))
  val env: Environment = {
    case &quot;x&quot; =&gt; 5
    case &quot;y&quot; =&gt; 7
  }
  println(&quot;Ausdruck: &quot; + exp)
  println(&quot;Auswertung mit x=5, y=7: &quot; + eval(exp, env))
  println(&quot;Ableitung von x:\n &quot; + derive(exp, &quot;x&quot;))
  println(&quot;Ableitung von y:\n &quot; + derive(exp, &quot;y&quot;))
}</code></pre>

<p>Führt man das Programm aus, erhält man folgende Ausgabe:</p>

<pre><code>Ausdruck: Sum(Sum(Var(x),Var(x)),Sum(Const(7),Var(y)))
Auswertung mit x=5, y=7: 24
Ableitung von x:
 Sum(Sum(Const(1),Const(1)),Sum(Const(0),Const(0)))
Ableitung von y:
 Sum(Sum(Const(0),Const(0)),Sum(Const(0),Const(1)))</code></pre>

<p>Beim Anblick dieser Ausgabe ist offensichtlich, dass man die Ergebnisse der Ableitungen noch vereinfachen sollte. Eine solche Funktion zum Vereinfachen von Ausdrücken, die Musterabgleiche nutzt, ist ein interessantes, aber gar nicht so einfaches Problem, was als Übung offen steht.</p>

<h2 id='traits'>Traits</h2>

<p>Neben dem Vererben von Oberklassen ist es in Scala auch möglich von mehreren, sogenannten <em>Traits</em> zu erben. Der beste Weg für einen Java-Programmierer einen Trait zu verstehen, ist sich eine Schnittstelle vorzustellen, die Implementierungen enthält. Wenn in Scala eine Klasse von einem Trait erbt, implementiert sie dessen Schnittstelle und erbt dessen Implementierungen.</p>

<p>Um die Nützlichkeit von Traits zu demonstrieren, werden wir ein klassisches Beispiel implementieren: Objekte mit einer natürlichen Ordnung oder Rangfolge. Es ist häufig hilfreich, Instanzen einer Klasse untereinander vergleichen zu können, um sie beispielsweise sortieren zu können. In Java müssen die Klassen solcher Objekte die Schnittstelle <code>Comparable</code> implementieren. In Scala kann dies mit einer äquivalenten, aber besseren Variante von <code>Comparable</code> als Trait bewerkstelligt werden, die im Folgenden <code>Ord</code> genannt wird.</p>

<p>Wenn Objekte verglichen werden, sind sechs verschiedene Aussagen sinnvoll: kleiner, kleiner gleich, gleich, ungleich, größer, und größer gleich. Allerdings ist es umständlich, immer alle sechs Methoden dafür zu implementieren, vor allem in Anbetracht der Tatsache, dass vier dieser sechs durch die verbliebenen zwei ausgedrückt werden können. Sind beispielsweise die Aussagen für gleich und kleiner gegeben, kann man die anderen damit ausdrücken. In Scala können diese Beobachtungen mit dem folgenden Trait zusammengefasst werden:</p>

<pre><code>trait Ord {
  def &lt; (that: Any): Boolean
  def &lt;=(that: Any): Boolean =  (this &lt; that) || (this == that)
  def &gt; (that: Any): Boolean = !(this &lt;= that)
  def &gt;=(that: Any): Boolean = !(this &lt; that)
}</code></pre>

<p>Diese Definition erzeugt sowohl einen neuen Typ namens <code>Ord</code>, welcher dieselbe Rolle wie Javas Schnittstelle <code>Comparable</code> spielt, und drei vorgegebenen Funktionen, die auf einer vierten, abstrakten basieren. Die Methoden für Gleichheit und Ungleichheit erscheinen hier nicht, da sie bereits in allen Objekten von Scala vorhanden sind.</p>

<p>Der Typ <code>Any</code>, welcher oben verwendet wurde, stellt den Ober-Typ aller Typen in Scala dar. Er kann als noch allgemeinere Version von Javas <code>Object</code> angesehen werden, da er außerdem Ober-Typ der Basis-Typen wie <code>Int</code> und <code>Float</code> ist.</p>

<p>Um Objekte einer Klasse vergleichen zu können, ist es also hinreichend, Gleichheit und die kleiner-als-Beziehung zu implementieren, und dieses Verhalten gewissermaßen mit der eigentlichen Klasse zu vermengen (mix in). Als Beispiel soll eine Klasse für Datumsangaben dienen, die Daten eines gregorianischen Kalenders repräsentiert. Solche Daten bestehen aus Tag, Monat und Jahr, welche durch Ganzzahlen dargestellt werden:</p>

<pre><code>class Date(y: Int, m: Int, d: Int) extends Ord {
  def year  = y
  def month = m
  def day   = d

  override def toString = year + &quot;-&quot; + month + &quot;-&quot; + day</code></pre>

<p>Der wichtige Teil dieser Definition ist die Deklaration <code>extends Ord</code>, welche dem Namen der Klasse und deren Parametern folgt. Sie sagt aus, dass <code>Date</code> vom Trait <code>Ord</code> erbt.</p>

<p>Nun folgt eine Re-Implementierung der Methode <code>equals</code>, die von <code>Object</code> geerbt wird, so dass die Daten korrekt nach ihren Feldern verglichen werden. Die vorgegebene Implementierung von <code>equals</code> ist dafür nicht nützlich, da in Java Objekte physisch, also nach deren Adressen im Speicher, verglichen werden. Daher verwenden wir folgende Definition:</p>

<pre><code>  override def equals(that: Any): Boolean =
    that.isInstanceOf[Date] &amp;&amp; {
      val o = that.asInstanceOf[Date]
      o.day == day &amp;&amp; o.month == month &amp;&amp; o.year == year
    }</code></pre>

<p>Diese Methode verwendet die vordefinierten Methoden <code>isInstanceOf</code> und <code>asInstanceOf</code>. Erstere entspricht Javas <code>instanceof</code>-Operator und gibt <code>true</code> zurück, wenn das zu testende Objekt eine Instanz des angegebenen Typs ist. Letztere entspricht Javas Operator für Typ-Umwandlungen (cast): ist das Objekt eine Instanz des angegebenen Typs, kann es als solcher angesehen und gehandhabt werden, ansonsten wird eine <code>ClassCastException</code> ausgelöst.</p>

<p>Schließlich kann die letzte Methode definiert werden, die für <code>Ord</code> notwendig ist, und die kleiner-als-Beziehung implementiert. Diese nutzt eine andere, vordefinierte Methode, namens <code>error</code>, des Paketes <code>sys</code>, welche eine <code>RuntimeException</code> mit der angegebenen Nachricht auslöst.</p>

<pre><code>  def &lt;(that: Any): Boolean = {
    if (!that.isInstanceOf[Date])
      sys.error(&quot;cannot compare &quot; + that + &quot; and a Date&quot;)

    val o = that.asInstanceOf[Date]
    (year &lt; o.year) ||
    (year == o.year &amp;&amp; (month &lt; o.month ||
                       (month == o.month &amp;&amp; day &lt; o.day)))
  }
}</code></pre>

<p>Diese Methode vervollständigt die Definition der <code>Date</code>-Klasse. Instanzen dieser Klasse stellen sowohl Daten als auch vergleichbare Objekte dar. Vielmehr implementiert diese Klasse alle sechs Methoden, die für das Vergleichen von Objekten notwendig sind: <code>equals</code> und <code>&lt;</code>, die direkt in der Definition von <code>Date</code> vorkommen, sowie die anderen, in dem Trait <code>Ord</code> definierten Methoden.</p>

<p>Traits sind nützlich in Situationen wie der obigen, den vollen Funktionsumfang hier zu zeigen, würde allerdings den Rahmen dieses Dokumentes sprengen.</p>

<h2 id='generische_programmierung'>Generische Programmierung</h2>

<p>Eine weitere Charakteristik Scalas, die in diesem Tutorial vorgestellt werden soll, behandelt das Konzept der generischen Programmierung. Java-Programmierer, die die Sprache noch vor der Version 1.5 kennen, sollten mit den Problemen vertraut sein, die auftreten, wenn generische Programmierung nicht unterstützt wird.</p>

<p>Generische Programmierung bedeutet, Quellcode nach Typen zu parametrisieren. Beispielsweise stellt sich die Frage für einen Programmierer bei der Implementierung einer Bibliothek für verkettete Listen, welcher Typ für die Elemente verwendet werden soll. Da diese Liste in verschiedenen Zusammenhängen verwendet werden soll, ist es nicht möglich, einen spezifischen Typ, wie <code>Int</code>, zu verwenden. Diese willkürliche Wahl wäre sehr einschränkend.</p>

<p>Aufgrund dieser Probleme griff man in Java vor der Einführung der generischen Programmierung zu dem Mittel, <code>Object</code>, den Ober-Typ aller Typen, als Element-Typ zu verwenden. Diese Lösung ist allerdings auch weit entfernt von Eleganz, da sie sowohl ungeeignet für die Basis-Typen, wie <code>int</code> oder <code>float</code>, ist, als auch viele explizite Typ-Umwandlungen für den nutzenden Programmierer bedeutet.</p>

<p>Scala ermöglicht es, generische Klassen und Methoden zu definieren, um diesen Problemen aus dem Weg zu gehen. Für die Demonstration soll ein einfacher, generischer Container als Referenz-Typ dienen, der leer sein kann, oder auf ein Objekt des generischen Typs zeigt:</p>

<pre><code>class Reference[T] {
  private var contents: T = _

  def get: T = contents

  def set(value: T) {
    contents = value
  }
}</code></pre>

<p>Die Klasse <code>Reference</code> ist anhand des Types <code>T</code> parametrisiert, der den Element-Typ repräsentiert. Dieser Typ wird im Körper der Klasse genutzt, wie bei dem Feld <code>contents</code>. Dessen Argument wird durch die Methode <code>get</code> abgefragt und mit der Methode <code>set</code> verändert.</p>

<p>Der obige Quellcode führt veränderbare Variablen in Scala ein, welche keiner weiteren Erklärung erfordern sollten. Schon interessanter ist der initiale Wert dieser Variablen, der mit <code>_</code> gekennzeichnet wurde. Dieser Standardwert ist für numerische Typen <code>0</code>, <code>false</code> für Wahrheitswerte, <code>()</code> für den Typ <code>Unit</code> und <code>null</code> für alle anderen Typen.</p>

<p>Um diese Referenz-Klasse zu verwenden, muss der generische Typ bei der Erzeugung einer Instanz angegeben werden. Für einen Ganzzahl-Container soll folgendes Beispiel dienen:</p>

<pre><code>object IntegerReference {
  def main(args: Array[String]) {
    val cell = new Reference[Int]
    cell.set(13)
    println(&quot;Reference contains the half of &quot; + (cell.get * 2))
  }
}</code></pre>

<p>Wie in dem Beispiel zu sehen ist, muss der Wert, der von der Methode <code>get</code> zurückgegeben wird, nicht umgewandelt werden, wenn er als Ganzzahl verwendet werden soll. Es wäre außerdem nicht möglich, einen Wert, der keine Ganzzahl ist, in einem solchen Container zu speichern, da er speziell und ausschließlich für Ganzzahlen erzeugt worden ist.</p>

<h2 id='zusammenfassung'>Zusammenfassung</h2>

<p>Dieses Dokument hat einen kurzen Überblick über die Sprache Scala gegeben und dazu einige einfache Beispiele verwendet. Interessierte Leser können beispielsweise mit dem Dokument <em>Scala by Example</em> fortfahren, welches fortgeschrittenere Beispiele enthält, und die <em>Scala Language Specification</em> konsultieren, sofern nötig.</p>
      <div id="disqus_thread"></div>
<script type="text/javascript">
    /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
  
    var disqus_shortname = 'scalasip'; // required: replace example with your forum shortname
  

    /* * * DON'T EDIT BELOW THIS LINE * * */
    (function() {
        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        dsq.src = 'http://' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a href="http://disqus.com" class="dsq-brlink">blog comments powered by <span class="logo-disqus">Disqus</span></a>

    </div>
    
    <div class="span6">
      <div id="scroller-anchor">
  <div id="scroller">
    <p class="contents">Contents</p>
    <div id="toc"></div>    
              
  </div>
</div>

    </div>
    
	
  </div>
</div>

<div class="footer">
	<div class="container">
		<ul>
			<li><h5>API</h5></li>
			<li><a href="http://www.scala-lang.org/api/current/">Current</a></li>
			<li><a href="http://www.scala-lang.org/archives/downloads/distrib/files/nightly/docs/library/index.html">Nightly</a></li>
		</ul>
		<ul>
			<li><h5>Learn</h5></li>
			<li><a href="/overviews">Guides & Overviews</a></li>
			<li><a href="/tutorials">Tutorials</a></li>
			<li><a href="/style">Scala Style Guide</a></li>				
		</ul>
		<ul>
			<li><h5>Quickref</h5></li>
			<li><a href="/glossary">Glossary</a></li>
			<li><a href="/cheatsheets">Cheatsheets</a></li>
		</ul>
		<ul>
			<li><h5>Contribute</h5></li>
			<li><a href="http://github.com/scala/scala.github.com">Source Code</a></li>
			<li><a href="/contribute.html">Contributors Guide</a></li>
			<li><a href="http://getsatisfaction.com/scaladocs">Suggestions</a></li>			
		</ul>
		<ul>
			<li><h5>Other Resources</h5></li>
			<li><a href="http://wiki.scala-lang.org">Wiki</a></li>
			<li><a href="/sips">Scala Improvement Process</a></li>				
		</ul>						
	</div>
	<div class="container copyright">
 		<p>
			Copyright &copy; 2011-2013 EPFL. All rights reserved.
			<a href="https://github.com/scala/scala.github.com/commits/gh-pages.atom"><img align="right" height="20px" width="20px" src="/resources/images/rss.png" alt="RSS feed of updates to the github repo hosting this site"></a>
		</p>		
	</div>
</div>


<script type="text/javascript">
  $('#toc').toc({exclude: 'h1, h5, h6', context: '', autoId: true, numerate: false});
</script>

<script type="text/javascript">
  $(function() {
    moveScroller();
  });
</script>

  </body>
</html>

    
